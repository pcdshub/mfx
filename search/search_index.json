{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"MFX Hutch Python Documentation Guide","text":"<p>For full documentation visit the private MFX repo on github.</p>"},{"location":"index.html#quick-links","title":"Quick links","text":"<ul> <li>LCLS MFX Homepage</li> <li>MFX Confluence</li> </ul>"},{"location":"DoT.html","title":"DoT","text":""},{"location":"DoT.html#mfx-droplet-on-tape-dot-operations-notes","title":"MFX Droplet on Tape (DOT) Operations Notes","text":"<p>MFX X-1001621 Last Revised: 08/18/2023 By: Victor Sosa Alfaro</p>"},{"location":"DoT.html#procedures","title":"Procedures","text":"<ol> <li>Start up</li> <li>Align beam</li> <li>Setup DOT</li> </ol> <pre><code># launch MFX home gui\nmfxhome\n# start the daq\nrestartdaq\n# start camViewer session\ncamViewer -w 100\n# launch python 3 session\nmfx3\n# bring up LFE home, should bring up current stable version (one in MFX home may not be current)\nlfe\n</code></pre> <ul> <li>ePix100_1: go to idle, issue epix tripped temp is 16, dewpoint set     to 20, reduce dewpoint # to 15 and try idling again, then turn on;     helium flow was off<ul> <li>Humidity ~15% and 19% for epix_1 and epix_2 now, still tripping</li> <li>Epix_1 down to ~10%</li> </ul> </li> <li>[camviewer - look at xcs_yag3m (farthest downstream on the mainline)</li> <li>Pull up eloggrabber (LCLS tab in MFX Home)</li> <li>MFX Home - middle click and open in new window to have certain     things from MFX home in separate window, do that for attenuators</li> <li>To re-enable F12 key: Restart gnome shell: alt + f2 and typing r in     command window<ul> <li>[Terminal: gnome-settings.sh]</li> <li>Moves in pulse picker, blocks beam</li> </ul> </li> <li>MFX Home &gt; LCLS &gt; HOMS overview: MR1L4 is MFX/MEC mirror</li> <li>[python: tfs.find_best_combo(energy = 9800)] - does it work?</li> <li>Transfocator has 9 different lenses, for a given energy, need     particular combo of lenses<ul> <li>Look at MFX elog and find post at similar energy and use the lens settings</li> </ul> </li> <li>Timeout error starting daq<ul> <li>[Terminal: serverStat 172.21.24.123 cycle] to restart node     (this node was the one in the error)</li> <li>[Terminal: serverStat 172.21.24.123 status]</li> <li>Once you can ssh into it, it should be good (takes several minutes to fully come back)</li> </ul> </li> <li>Edit Config in DAQ &gt; EVR, should be 30 Hz</li> <li>Rayonix have to connect directly to computer for it<ul> <li>[ssh -X hsuser\\@con-ics-mfx-rayonix]</li> <li>[killall procServ]</li> <li>[capxure]</li> <li>[cd ~/slac/]</li> <li>[./startDaqInterface_newcraydl] start DAQ process that was killed with the killall command</li> </ul> </li> <li>DG2 STP 1 closed (delivers beam to CXI), will need to have it opened to see beam on xcs_yag3m</li> <li>XRT Common Vacuum window</li> <li>YAGs for MFX:<ul> <li>UM6 (upstream of mirror for hutch 6) (not sure what this is in camVieiwer)</li> <li>MEC YAG0 (just after mirror)</li> <li>XCS YAG3M (HFX DG3:PIM &amp; IPM)</li> <li>MFX_dia_yag (dia = diagnostics stand, right after MFX stopper, equivalent of SB at XCS)<ul> <li>Slowly</li> </ul> </li> <li>MFX_DG1_YAG<ul> <li>PIM DIA, IPM DIA</li> <li>Beam moved vertical positive by 80 um\u00a0</li> </ul> </li> <li>MFX_DG2_YAG (usually brighter w/ lenses in because it's after transfocator)</li> <li>MFX_DG3_YAG (after rayonix)<ul> <li>Take cover off rayonix, slowly bringing up beam making sure centered on detector (Rayonix window in AMI)</li> </ul> </li> </ul> </li> <li>MFX Lens System (mfx home)<ul> <li>For 9.8 keV: 50, 125, 250 radius in position (TFS04, TFS06, TFS09)</li> </ul> </li> <li>EVR Trigger card (the physical card is between the beam pipes just before endstation):<ul> <li>MFXhome &gt; Laser &gt; ns laser EVR</li> <li>We connected the camera to this card, set EVR to 42 (30 Hz)</li> </ul> </li> <li>Focus<ul> <li>LBL_inline camera, yag screen in place,\u00a0</li> <li>Get focus right</li> <li>Cross hair #1 somewhere top left of spot, cross hair #2 bottom right, defining ROI for integration</li> <li>[Terminal: cd bin</li> <li>[focus_scan --h] get help to see how it runs</li> <li>[focus_scan {camera name} --scan] camera PV = MFX:GIGE:LBL:01 (does not take the alias)<ul> <li>[Terminal: camViewer -c LBL_Inline -m] bring up config window</li> </ul> </li> </ul> </li> <li>Ref laser \"in\" position is 54 mm</li> <li>Align von Hamos Fe K\u03b1 and K\u03b2 crystals<ul> <li>Issues with alignment due to motor control connection/movement (encoder error), but was able to align K\u03b1 crystals</li> <li>Could not algin the K\u03b2 due to a lack of signal in the VH detectors (the chamber is not under He which reduces signal to noise)</li> </ul> </li> <li>Insert/move Rayonix into DOT chamber<ul> <li>Collect dark background ( issues with connections: rayonix damaging only in 3x3 mode with or without even sequencer. 4x4 works and 5x5 seemingly worked)</li> </ul> </li> </ul>"},{"location":"DoT.html#8192023","title":"8/19/2023","text":"<ul> <li>XRT Spectrometer = FEE-SPEC0_H in DAQ<ul> <li>In XRT, gives single shot beam profile</li> <li>Useful for crystallography to have shot-to-shot energy distribution for correct indexing of the Bragg peaks</li> </ul> </li> <li>Talking to Newport controller<ul> <li>Franklin Sample Delivery window in MFX Home</li> <li>\"Newport screen\", try \"Initialize All\", Try \"Reboot IOC\" in top right of window</li> </ul> </li> <li>[Terminal: awr]: are we ready<ul> <li>Current photon energy getting read is (PV1 SIOC:SYS0:ML00:A0627) at 1032.66 eV</li> </ul> </li> <li>[capxsure]<ul> <li>Frame Trigger Mode: None</li> <li>Exposure Type: Normal</li> <li>Click Collect New Background</li> <li>Change exposure type to Dark then collect new background</li> <li>Then turn exposure type back to normal</li> <li>[./startDaqInterface_newcraydl]</li> <li>Restart DAQ</li> </ul> </li> <li>Checking mfx_dia_yag<ul> <li>Make sure s4.5 stopper open, pp open</li> <li>Checking beam then on mfx_dg1_yag</li> <li>Can walk down beamline on MFX home</li> <li>Checking beam then on mfx_dg2_yag</li> <li>Jaws ~0.7 mm open</li> </ul> </li> <li>Took off Rayonix cover to see beam on mfx_dg3_yag (post detector)<ul> <li>Slowly unattenuating</li> </ul> </li> <li>Bring in Rayonix into DOT chamber<ul> <li>Move in the z- directions initially position should be at 1100mm</li> <li>Slowly move by 100mm steps until we get to 800mm then move by 50mm steps until we get to 250mm then smaller steps until we get to 188mm (final position)</li> <li>*During movement always have clicker ready to stop incase an     issues arises</li> </ul> </li> <li>Plan to run samples:<ul> <li>Fe(bpy)3 [10mM]</li> <li>Ferri cyanide [9mM]</li> <li>Ferro cyande [10mM]</li> </ul> </li> <li>To run samples:<ul> <li>initially bring in beam by removing stopper on door screen (Remove 43) and open pulse picker (PP)</li> <li>Slowly unattenuating from [att(1e-6)] to 10% [att(1e-1)] then full beam [att(1)]</li> <li>Make sure we are in 30hz sequencer for timing is proper [ mfx_timing.set30hz()]</li> <li>Make sure pp is in flip-flop</li> <li>On DAQ clip on record and start run</li> </ul> </li> <li>*If computer freezes just wait ~5-10mins until things get back to     normal if this is not the case then call tech support.</li> <li>To end shift:<ul> <li>remove Rayonix from 188mm to 1100mm (all at once no steps need unless they state it)</li> <li>take full screen in eblogger and type [end of shift]</li> <li>in terminal type [takepads]</li> <li>copy e-milano message and inset uniname</li> </ul> </li> </ul>"},{"location":"DoT.html#8202023","title":"8/20/2023","text":"<ul> <li>Visualize on first diagnostic yag<ul> <li>PIM DIA</li> </ul> </li> <li>Then visualize on DG1 yag<ul> <li>DG1 slit width is open 0.85 mm</li> </ul> </li> <li>Z Translation set to 120 mm for TFS</li> <li>[python: att(1e-9)]</li> <li>Taking pedastals is a way to get background [Samples for Co K\u03b2]{.ul}</li> </ul> <p>CoCl2 run 122-126</p> <p></p> <p>Reduced Cobaloxime run 127-131</p> <p></p> <p>Oxidized Coblaloxime run 132-136</p> <p></p> <p>We can compare the CoCl2 counts with the reduced cobaloxime.</p>"},{"location":"DoT.html#8232023","title":"8/23/2023","text":"<p>Hydrogenase samples:</p> <p>Switched the crystals to Ni k\u03b1</p> <p>Then able to run samples (prepared inside the glovebox)</p> <p>Used commands to run:</p> <p>To turn on PP and to start run.</p>"},{"location":"DropsDriver.html","title":"DropsDriver","text":""},{"location":"DropsDriver.html#dod.DropsDriver.myClient","title":"<code>myClient</code>","text":"Source code in <code>dod/DropsDriver.py</code> <pre><code>class myClient:\n  def __init__(self, ip, port, supported_json=\"supported.json\", reload=True, queue=None, **kwargs):\n    # dto pipelines\n    self.__queue__ = Queue()\n    self.__queue_ready__ = Semaphore(value=0)\n    # configure connection object\n    self.__IP__ = ip\n    self.__PORT__ = port\n    self.conn = HTTPConnection(host=self.__IP__, port=self.__PORT__)\n    self.transceiver = HTTPTransceiver(self.conn, self.__queue__, self.__queue_ready__)\n    logger.info(f\"Connected to ip: {ip} port: {port}\")\n\n    # configuration persitence, updating\n    self.supported_ends_handler = SupportedEndsHandler(supported_json,self.conn)\n    if (reload):\n      self.supported_ends_handler.reload_all()\n\n    # convinient member lambda for grabbing supported endpoitns\n    self.supported_ends = lambda : self.supported_ends_handler.get_endpoints()\n    pprint.pprint(self.supported_ends())\n\n  def __del__(self):\n      # close network connection\n      self.conn.close()\n\n  '''\n  Middleware interaction defintions\n  Here we define specific interactions that the machine is capable of fielding\n  These actions are exposed as member functions of this driver class. \n  '''\n\n  def middle_invocation_wrapper(func):\n    '''\n    Define a decorator function to adorn all of these 'high' middleware calls\n    Logs what functions is being called and returns the response. \n    '''\n    def inner(self, *args):\n      logger.info(f\"Invoking {func.__name__}\")\n      func(self, *args)\n      resp = self.get_response()\n      # TODO: Do something with None response globally\n      # Check if we have a GUI (get_status) that needs to be cleared, May need\n      # to happen per function basis\n      return resp\n    return inner\n\n  @middle_invocation_wrapper\n  def connect(self, user : str):\n      \"\"\"\n        Required to send 'Do' requests\n      \"\"\"\n      self.send(f\"/DoD/Connect?ClientName={user}\")\n\n  @middle_invocation_wrapper\n  def disconnect(self):\n      \"\"\"\n        The client can end the connection with access to \u2018Do\u2019 requests.\n        Clicking the button \u2018Disable API Control\u2019 on the UI has the same effect.\n      \"\"\"\n      self.send(\"/DoD/Disconnect\")\n\n  @middle_invocation_wrapper\n  def get_status(self):\n      \"\"\"\n        Returns Robot Status\n      \"\"\"\n      self.send(\"/DoD/get/Status\")\n\n\n  @middle_invocation_wrapper\n  def move(self, position : str):\n      \"\"\"\n        Moves the drive to a position taken from the list of 'PositionNames'\n      \"\"\"\n      self.send(f\"/DoD/do/Move?PositionName={position}\")\n\n  @middle_invocation_wrapper\n  def get_position_names(self):\n      \"\"\"\n        Returns the list of positions in DOD robot\n      \"\"\"\n      self.send(f\"/DoD/get/PositionNames\")\n\n  @middle_invocation_wrapper\n  def get_task_names(self):\n      \"\"\"\n        Returns the list of tasks that are stored in the Robot by name\n      \"\"\"\n      self.send(f\"/DoD/get/TaskNames\")\n\n  @middle_invocation_wrapper\n  def get_current_positions(self):\n      \"\"\"\n        Returns the name and properties of the last selected position,\n        together with the real current position coordinates.\n        (The drives can have been stepped away from the stored position or \n        they include small dispenser related offsets.)\n      \"\"\"\n      self.send(f\"/DoD/get/CurrentPosition\")\n\n  @middle_invocation_wrapper\n  def execute_task(self, value : str):\n      \"\"\"\n        Runs a task from the list of \u2018TaskName\u2019.\n        This operation is safe in general.\n        It simulates the analog action on the UI.\n      \"\"\"\n      self.send(f\"/DoD/do/ExecuteTask?TaskName={value}\")\n\n  @middle_invocation_wrapper\n  def auto_drop(self):\n      \"\"\"\n        Runs the particular task that is linked to the UI button.\n        Its name is \u2018AutoDropDetection\u2019. In principalm this endpoint is not needed.\n        \u2018ExecuteTask\u2019 can be used instead.\n      \"\"\"\n      self.send(f\"/DoD/do/AutoDrop\")\n\n  @middle_invocation_wrapper\n  def move_to_interaction_point(self):\n      \"\"\"\n        The moving to the predefined position of the interaction point corresponds\n        to the use of the endpoint \u2018Move\u2019. But only with this endpoint the UI\n        elemts for the dispensers\u2019 position adjustment become visible on the UI.\n        The request simulates the button (beam simbol) on the UI.\n      \"\"\"\n      self.send(f\"/DoD/do/InteractionPoint\")\n\n  @middle_invocation_wrapper\n  def move_x(self, value : float):\n      \"\"\"\n        The X drive can be sent to any coordinate (the value\u2019s unit is \u00b5m)\n        within the allowed range.\n\n        NOTE: This does not include a Z move up to the safe height nor any\n        other safety feature checking whether the move from the current position\n        to the selected coordinate can lead to collision or breaking of a\n        dispenser Tip.\n      \"\"\"\n      self.send(f\"/DoD/do/MoveX?X={value}\")\n\n    ## API V2\n  @middle_invocation_wrapper\n  def get_pulse_names(self):\n      \"\"\"\n        Returns the list of available pulse shapes for the sciPULSE channels.\n      \"\"\"\n      self.send(f\"/DoD/get/PulseNames\")\n\n  @middle_invocation_wrapper\n  def get_nozzle_status(self):\n      \"\"\"\n        Returns the activated and selected nozzles an the parameters for all\n        activated nozzles. The parameter \u2018Trigger\u2019 (true/false) is not linked\n        to a nozzle.\n\n        Note: Nozzle parameters\n        \u2018ID\u2019 (number),\n        \u2018Volt\u2019,\n        \u2018Pulse\u2019 (name or number),\n        \u2018Freq\u2019 ,\n        \u2018Volume\u2019 appear as an array of strings (JSON).\n      \"\"\"\n      self.send(\"/DoD/get/NozzleStatus\")\n\n  @middle_invocation_wrapper\n  def select_nozzle(self, channel: str):\n      \"\"\"\n        Set the selected nozzle for dispensing and task execution etc.\n        Returns a reject if the channel value is not one of the\n        \u2018Activated Nozzles\u2019 (see \u2018NozzleStatus\u2019).\n      \"\"\"\n      self.send(f\"/DoD/do/SelectNozzle?Channel={channel}\")\n\n\n  @middle_invocation_wrapper\n  def dispensing(self, state: str):\n      \"\"\"\n        Switches between the dispensing states\n        \u2018Trigger\u2019 (includes \u2018Stat Continuous Dispensing\u2019),\n        \u2018Free\u2019 (\u2018Continuous Dispensing\u2019 without trigger) and\n        \u2018Off\u2019. Returns a reject if the value is not one of the three strings.\n\n        (Some tasks can set the state to \u2018Off\u2019 without restarting dispensing afterwards.)\n      \"\"\"\n      self.send(f\"/DoD/do/Dispensing?State={state}\")\n\n\n  @middle_invocation_wrapper\n  def setLED(self, duration: int, delay : int):\n      \"\"\"\n      Sets the two strobe LED parameters \u2018Delay\u2019 (0 to 6500) and Duration (1 to 65000).\n      Returns a reject if one of the values is out of range.\n      \"\"\"\n      self.send(f\"/DoD/do/SetLED?Duration={duration}&amp;Delay={delay}\")\n\n  @middle_invocation_wrapper\n  def move_y(self, value : float):\n      \"\"\"\n          Same as for Y\n      \"\"\"\n      #TODO: handle Dialog, Caputure None, Check if dialog and clear\n      self.send(f\"/DoD/do/MoveY?Y={value}\")\n\n  @middle_invocation_wrapper\n  def move_z(self, value : float):\n      \"\"\"\n          Same as for Z\n      \"\"\"\n      self.send(f\"/DoD/do/MoveZ?Z={value}\")\n\n  @middle_invocation_wrapper\n  def take_probe(self, channel : int, probe_well : str, volume : float):\n      \"\"\"\n      This endpoint requires the presence of the task \u2018ProbeUptake\u2019 (attached).\n      If that is not given, the return is not a reject, but nothing happens.\n      The parameters are\n\n        \u2018Channel\u2019 (number of nozzle, includes effect as \u2018SelectNozzle\u2019),\n        \u2018ProbeWell\u2019 (e.g. A1), Volume (\u00b5L). Returns a reject  if \u2018Channel\u2019 is not among\n        \u2018Active Nozzles\u2019, Volume is &gt; 250 or\n        \u2018ProbeWell\u2019 is not one of the allowed wells for the selected nozzle.\n\n      \"\"\"\n      self.send(f\"/DoD/do/TakeProbe?Channel={channel}&amp;ProbeWell={probe_well}&amp;Volume={volume}\")\n\n## API V3 ##\n\n  @middle_invocation_wrapper\n  def get_task_details(self, task_name):\n    '''\n        Returns the content of the tasks that is specified be \u2018TaskName\u2019.\n    '''\n    self.send(f\"/DoD/get/TaskDetails?TaskName={task_name}\")\n\n  @middle_invocation_wrapper\n  def get_drive_range(self):\n    '''\n      Returns the maximum range of each axis (X,Y,Z) in units of \u00b5m.\n    '''\n    self.send(f\"/DoD/get/DriveRange\")\n\n  @middle_invocation_wrapper\n  def set_nozzle_parameters(self,\n                            active_nozzles : str,\n                            selected_nozzles: str,\n                            volts : int,\n                            pulse : str,\n                            frequency : int):\n    '''\n      Sets the list of activate nozzles and of the selected nozzles for\n        operations that work with more than one nozzle.\n      (This overwrites and is overwritten by SelectNozzle, which only sets one nozzle channel.)\n      Both values are strings with commas separating the channel numbers (e.g. \u201c1,2,3\u201d).\n      \u2018Volt\u2019 and \u2018Freq\u2019 are integers.\n      \u2018Pulse\u2019 is read as a string. It is either a integer number or the pulse\n        shape name for sciPULSE channels (from PulseNames).\n\n    '''\n\n    self.send(f\"/DoD/do/SetNozzleParameters?Active={active_nozzles}&amp;Selected={selected_nozzles}&amp;Volt={volts}&amp;Pulse={pulse}&amp;Freq={frequency}\")\n\n  @middle_invocation_wrapper\n  def stop_task(self):\n    '''\n            Stops the running task (and moves).\n    '''\n    self.send(f\"/DoD/do/StopTask\")\n\n  @middle_invocation_wrapper\n  def set_ip_offest(self):\n    '''\n            This endpoint uses the current coordinates for the currently selected\n            nozzle (SelectNozzle) to set the IP position (Nozzle 1) or calculates\n            and sets the IP offsets (Nozzles 2, \u2026).\n            (Note: The \u2018Nozzle Offset\u2019 values in the nozzle parameter table are \n            always considered.\n            Changing these would require a readjustment of the IP offsets.)\n            Offsets are rejected if they exceed a maximum of 2 mm.\n            Thus, the selected nozzle must be moved to the IP (InteractionPoint)\n            before requesting SetIPOffset.\n    '''\n    self.send(f\"/DoD/do/InteractionPoint\")\n\n  @middle_invocation_wrapper\n  def set_humidity(self, value):\n    '''\n        Sets the wanted relative humidity as %rH. Values are integer.\n    '''\n    self.send(f\"/DoD/do/SetHumidity?rH={value}\")\n\n  @middle_invocation_wrapper\n  def set_cooling_temp(self, temp):\n    '''\n            Sets the temperature of the cooling device.\n            Besides the setting of a \u00b0C value (float),\n                there is the option to send the string \u201cdewpoint\u201d,\n                which enables an automatic adjustment.\n    '''\n    self.send(f\"/DoD/do/SetCoolingTemp?Temp={temp}\")\n\n  @middle_invocation_wrapper\n  def close_dialog(self, reference, selection):\n    '''\n            In situations of \u201cStatus\u201d = \u201cDialog\u201d the endpoint Status provides the\n                dialog\u2019s reference, message text and button labels.\n            (If the response of \u2018Button2\u2019 is empty, there is only one selection \n            available, typically with the label \u2018OK.).\n            This endpoint allows to close the dialog by specifying the reference and t\n                he selection (\u201c1\u201d or \u201c2\u201d).\n            The reference is individual, incrementing integer for each occurrence\n                of a dialog, it starts a \u201c1\u201d when the device is initialized.\n\n            In case of more than one open dialogs \u201cStatus\u201d reports the last one,\n                which is typically the first to be closed.\n            But the remote control can try to close the earlier dialog.\n    '''\n    self.send(f\"/DoD/do/CloseDialog?Reference={reference}&amp;Selection={selection}\")\n\n  @middle_invocation_wrapper\n  def reset_error(self):\n    '''\n            This endpoint is needed if after closing all (error) dialogs the status \n            \u201cError\u201d persists and \u201cErrorMessage\u201d (header) is not \u201cNA\u201d.\n    '''\n    self.send(f\"/DoD/do/ResetError\")\n\n  '''\n  send transmits a formatted HTTP GET request\n  it will not check the validity of request\n  it will persist result in a place that can be read... TODO: actually do this\n  '''\n  def send(self, endpoint):\n    self.transceiver.send(endpoint)\n    return\n\n  '''\n  Pops most recent response from response queue\n  '''\n  def get_response(self):\n    return self.transceiver.get_response()\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.auto_drop","title":"<code>auto_drop()</code>","text":"<p>Runs the particular task that is linked to the UI button. Its name is \u2018AutoDropDetection\u2019. In principalm this endpoint is not needed. \u2018ExecuteTask\u2019 can be used instead.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef auto_drop(self):\n    \"\"\"\n      Runs the particular task that is linked to the UI button.\n      Its name is \u2018AutoDropDetection\u2019. In principalm this endpoint is not needed.\n      \u2018ExecuteTask\u2019 can be used instead.\n    \"\"\"\n    self.send(f\"/DoD/do/AutoDrop\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.close_dialog","title":"<code>close_dialog(reference, selection)</code>","text":"<p>In situations of \u201cStatus\u201d = \u201cDialog\u201d the endpoint Status provides the     dialog\u2019s reference, message text and button labels. (If the response of \u2018Button2\u2019 is empty, there is only one selection  available, typically with the label \u2018OK.). This endpoint allows to close the dialog by specifying the reference and t     he selection (\u201c1\u201d or \u201c2\u201d). The reference is individual, incrementing integer for each occurrence     of a dialog, it starts a \u201c1\u201d when the device is initialized.</p> <p>In case of more than one open dialogs \u201cStatus\u201d reports the last one,     which is typically the first to be closed. But the remote control can try to close the earlier dialog.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef close_dialog(self, reference, selection):\n  '''\n          In situations of \u201cStatus\u201d = \u201cDialog\u201d the endpoint Status provides the\n              dialog\u2019s reference, message text and button labels.\n          (If the response of \u2018Button2\u2019 is empty, there is only one selection \n          available, typically with the label \u2018OK.).\n          This endpoint allows to close the dialog by specifying the reference and t\n              he selection (\u201c1\u201d or \u201c2\u201d).\n          The reference is individual, incrementing integer for each occurrence\n              of a dialog, it starts a \u201c1\u201d when the device is initialized.\n\n          In case of more than one open dialogs \u201cStatus\u201d reports the last one,\n              which is typically the first to be closed.\n          But the remote control can try to close the earlier dialog.\n  '''\n  self.send(f\"/DoD/do/CloseDialog?Reference={reference}&amp;Selection={selection}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.connect","title":"<code>connect(user)</code>","text":"<p>Required to send 'Do' requests</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef connect(self, user : str):\n    \"\"\"\n      Required to send 'Do' requests\n    \"\"\"\n    self.send(f\"/DoD/Connect?ClientName={user}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.disconnect","title":"<code>disconnect()</code>","text":"<p>The client can end the connection with access to \u2018Do\u2019 requests. Clicking the button \u2018Disable API Control\u2019 on the UI has the same effect.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef disconnect(self):\n    \"\"\"\n      The client can end the connection with access to \u2018Do\u2019 requests.\n      Clicking the button \u2018Disable API Control\u2019 on the UI has the same effect.\n    \"\"\"\n    self.send(\"/DoD/Disconnect\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.dispensing","title":"<code>dispensing(state)</code>","text":"<p>Switches between the dispensing states \u2018Trigger\u2019 (includes \u2018Stat Continuous Dispensing\u2019), \u2018Free\u2019 (\u2018Continuous Dispensing\u2019 without trigger) and \u2018Off\u2019. Returns a reject if the value is not one of the three strings.</p> <p>(Some tasks can set the state to \u2018Off\u2019 without restarting dispensing afterwards.)</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef dispensing(self, state: str):\n    \"\"\"\n      Switches between the dispensing states\n      \u2018Trigger\u2019 (includes \u2018Stat Continuous Dispensing\u2019),\n      \u2018Free\u2019 (\u2018Continuous Dispensing\u2019 without trigger) and\n      \u2018Off\u2019. Returns a reject if the value is not one of the three strings.\n\n      (Some tasks can set the state to \u2018Off\u2019 without restarting dispensing afterwards.)\n    \"\"\"\n    self.send(f\"/DoD/do/Dispensing?State={state}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.execute_task","title":"<code>execute_task(value)</code>","text":"<p>Runs a task from the list of \u2018TaskName\u2019. This operation is safe in general. It simulates the analog action on the UI.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef execute_task(self, value : str):\n    \"\"\"\n      Runs a task from the list of \u2018TaskName\u2019.\n      This operation is safe in general.\n      It simulates the analog action on the UI.\n    \"\"\"\n    self.send(f\"/DoD/do/ExecuteTask?TaskName={value}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_current_positions","title":"<code>get_current_positions()</code>","text":"<p>Returns the name and properties of the last selected position, together with the real current position coordinates. (The drives can have been stepped away from the stored position or  they include small dispenser related offsets.)</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_current_positions(self):\n    \"\"\"\n      Returns the name and properties of the last selected position,\n      together with the real current position coordinates.\n      (The drives can have been stepped away from the stored position or \n      they include small dispenser related offsets.)\n    \"\"\"\n    self.send(f\"/DoD/get/CurrentPosition\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_drive_range","title":"<code>get_drive_range()</code>","text":"<p>Returns the maximum range of each axis (X,Y,Z) in units of \u00b5m.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_drive_range(self):\n  '''\n    Returns the maximum range of each axis (X,Y,Z) in units of \u00b5m.\n  '''\n  self.send(f\"/DoD/get/DriveRange\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_nozzle_status","title":"<code>get_nozzle_status()</code>","text":"<p>Returns the activated and selected nozzles an the parameters for all activated nozzles. The parameter \u2018Trigger\u2019 (true/false) is not linked to a nozzle.</p> <p>Note: Nozzle parameters \u2018ID\u2019 (number), \u2018Volt\u2019, \u2018Pulse\u2019 (name or number), \u2018Freq\u2019 , \u2018Volume\u2019 appear as an array of strings (JSON).</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_nozzle_status(self):\n    \"\"\"\n      Returns the activated and selected nozzles an the parameters for all\n      activated nozzles. The parameter \u2018Trigger\u2019 (true/false) is not linked\n      to a nozzle.\n\n      Note: Nozzle parameters\n      \u2018ID\u2019 (number),\n      \u2018Volt\u2019,\n      \u2018Pulse\u2019 (name or number),\n      \u2018Freq\u2019 ,\n      \u2018Volume\u2019 appear as an array of strings (JSON).\n    \"\"\"\n    self.send(\"/DoD/get/NozzleStatus\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_position_names","title":"<code>get_position_names()</code>","text":"<p>Returns the list of positions in DOD robot</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_position_names(self):\n    \"\"\"\n      Returns the list of positions in DOD robot\n    \"\"\"\n    self.send(f\"/DoD/get/PositionNames\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_pulse_names","title":"<code>get_pulse_names()</code>","text":"<p>Returns the list of available pulse shapes for the sciPULSE channels.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_pulse_names(self):\n    \"\"\"\n      Returns the list of available pulse shapes for the sciPULSE channels.\n    \"\"\"\n    self.send(f\"/DoD/get/PulseNames\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_status","title":"<code>get_status()</code>","text":"<p>Returns Robot Status</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_status(self):\n    \"\"\"\n      Returns Robot Status\n    \"\"\"\n    self.send(\"/DoD/get/Status\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_task_details","title":"<code>get_task_details(task_name)</code>","text":"<p>Returns the content of the tasks that is specified be \u2018TaskName\u2019.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_task_details(self, task_name):\n  '''\n      Returns the content of the tasks that is specified be \u2018TaskName\u2019.\n  '''\n  self.send(f\"/DoD/get/TaskDetails?TaskName={task_name}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.get_task_names","title":"<code>get_task_names()</code>","text":"<p>Returns the list of tasks that are stored in the Robot by name</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef get_task_names(self):\n    \"\"\"\n      Returns the list of tasks that are stored in the Robot by name\n    \"\"\"\n    self.send(f\"/DoD/get/TaskNames\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.middle_invocation_wrapper","title":"<code>middle_invocation_wrapper(func)</code>","text":"<p>Define a decorator function to adorn all of these 'high' middleware calls Logs what functions is being called and returns the response.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>def middle_invocation_wrapper(func):\n  '''\n  Define a decorator function to adorn all of these 'high' middleware calls\n  Logs what functions is being called and returns the response. \n  '''\n  def inner(self, *args):\n    logger.info(f\"Invoking {func.__name__}\")\n    func(self, *args)\n    resp = self.get_response()\n    # TODO: Do something with None response globally\n    # Check if we have a GUI (get_status) that needs to be cleared, May need\n    # to happen per function basis\n    return resp\n  return inner\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.move","title":"<code>move(position)</code>","text":"<p>Moves the drive to a position taken from the list of 'PositionNames'</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef move(self, position : str):\n    \"\"\"\n      Moves the drive to a position taken from the list of 'PositionNames'\n    \"\"\"\n    self.send(f\"/DoD/do/Move?PositionName={position}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.move_to_interaction_point","title":"<code>move_to_interaction_point()</code>","text":"<p>The moving to the predefined position of the interaction point corresponds to the use of the endpoint \u2018Move\u2019. But only with this endpoint the UI elemts for the dispensers\u2019 position adjustment become visible on the UI. The request simulates the button (beam simbol) on the UI.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef move_to_interaction_point(self):\n    \"\"\"\n      The moving to the predefined position of the interaction point corresponds\n      to the use of the endpoint \u2018Move\u2019. But only with this endpoint the UI\n      elemts for the dispensers\u2019 position adjustment become visible on the UI.\n      The request simulates the button (beam simbol) on the UI.\n    \"\"\"\n    self.send(f\"/DoD/do/InteractionPoint\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.move_x","title":"<code>move_x(value)</code>","text":"<p>The X drive can be sent to any coordinate (the value\u2019s unit is \u00b5m) within the allowed range.</p> <p>NOTE: This does not include a Z move up to the safe height nor any other safety feature checking whether the move from the current position to the selected coordinate can lead to collision or breaking of a dispenser Tip.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef move_x(self, value : float):\n    \"\"\"\n      The X drive can be sent to any coordinate (the value\u2019s unit is \u00b5m)\n      within the allowed range.\n\n      NOTE: This does not include a Z move up to the safe height nor any\n      other safety feature checking whether the move from the current position\n      to the selected coordinate can lead to collision or breaking of a\n      dispenser Tip.\n    \"\"\"\n    self.send(f\"/DoD/do/MoveX?X={value}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.move_y","title":"<code>move_y(value)</code>","text":"<p>Same as for Y</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef move_y(self, value : float):\n    \"\"\"\n        Same as for Y\n    \"\"\"\n    #TODO: handle Dialog, Caputure None, Check if dialog and clear\n    self.send(f\"/DoD/do/MoveY?Y={value}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.move_z","title":"<code>move_z(value)</code>","text":"<p>Same as for Z</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef move_z(self, value : float):\n    \"\"\"\n        Same as for Z\n    \"\"\"\n    self.send(f\"/DoD/do/MoveZ?Z={value}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.reset_error","title":"<code>reset_error()</code>","text":"<p>This endpoint is needed if after closing all (error) dialogs the status  \u201cError\u201d persists and \u201cErrorMessage\u201d (header) is not \u201cNA\u201d.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef reset_error(self):\n  '''\n          This endpoint is needed if after closing all (error) dialogs the status \n          \u201cError\u201d persists and \u201cErrorMessage\u201d (header) is not \u201cNA\u201d.\n  '''\n  self.send(f\"/DoD/do/ResetError\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.select_nozzle","title":"<code>select_nozzle(channel)</code>","text":"<p>Set the selected nozzle for dispensing and task execution etc. Returns a reject if the channel value is not one of the \u2018Activated Nozzles\u2019 (see \u2018NozzleStatus\u2019).</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef select_nozzle(self, channel: str):\n    \"\"\"\n      Set the selected nozzle for dispensing and task execution etc.\n      Returns a reject if the channel value is not one of the\n      \u2018Activated Nozzles\u2019 (see \u2018NozzleStatus\u2019).\n    \"\"\"\n    self.send(f\"/DoD/do/SelectNozzle?Channel={channel}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.setLED","title":"<code>setLED(duration, delay)</code>","text":"<p>Sets the two strobe LED parameters \u2018Delay\u2019 (0 to 6500) and Duration (1 to 65000). Returns a reject if one of the values is out of range.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef setLED(self, duration: int, delay : int):\n    \"\"\"\n    Sets the two strobe LED parameters \u2018Delay\u2019 (0 to 6500) and Duration (1 to 65000).\n    Returns a reject if one of the values is out of range.\n    \"\"\"\n    self.send(f\"/DoD/do/SetLED?Duration={duration}&amp;Delay={delay}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.set_cooling_temp","title":"<code>set_cooling_temp(temp)</code>","text":"<p>Sets the temperature of the cooling device. Besides the setting of a \u00b0C value (float),     there is the option to send the string \u201cdewpoint\u201d,     which enables an automatic adjustment.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef set_cooling_temp(self, temp):\n  '''\n          Sets the temperature of the cooling device.\n          Besides the setting of a \u00b0C value (float),\n              there is the option to send the string \u201cdewpoint\u201d,\n              which enables an automatic adjustment.\n  '''\n  self.send(f\"/DoD/do/SetCoolingTemp?Temp={temp}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.set_humidity","title":"<code>set_humidity(value)</code>","text":"<p>Sets the wanted relative humidity as %rH. Values are integer.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef set_humidity(self, value):\n  '''\n      Sets the wanted relative humidity as %rH. Values are integer.\n  '''\n  self.send(f\"/DoD/do/SetHumidity?rH={value}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.set_ip_offest","title":"<code>set_ip_offest()</code>","text":"<p>This endpoint uses the current coordinates for the currently selected nozzle (SelectNozzle) to set the IP position (Nozzle 1) or calculates and sets the IP offsets (Nozzles 2, \u2026). (Note: The \u2018Nozzle Offset\u2019 values in the nozzle parameter table are  always considered. Changing these would require a readjustment of the IP offsets.) Offsets are rejected if they exceed a maximum of 2 mm. Thus, the selected nozzle must be moved to the IP (InteractionPoint) before requesting SetIPOffset.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef set_ip_offest(self):\n  '''\n          This endpoint uses the current coordinates for the currently selected\n          nozzle (SelectNozzle) to set the IP position (Nozzle 1) or calculates\n          and sets the IP offsets (Nozzles 2, \u2026).\n          (Note: The \u2018Nozzle Offset\u2019 values in the nozzle parameter table are \n          always considered.\n          Changing these would require a readjustment of the IP offsets.)\n          Offsets are rejected if they exceed a maximum of 2 mm.\n          Thus, the selected nozzle must be moved to the IP (InteractionPoint)\n          before requesting SetIPOffset.\n  '''\n  self.send(f\"/DoD/do/InteractionPoint\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.set_nozzle_parameters","title":"<code>set_nozzle_parameters(active_nozzles, selected_nozzles, volts, pulse, frequency)</code>","text":"<p>Sets the list of activate nozzles and of the selected nozzles for   operations that work with more than one nozzle. (This overwrites and is overwritten by SelectNozzle, which only sets one nozzle channel.) Both values are strings with commas separating the channel numbers (e.g. \u201c1,2,3\u201d). \u2018Volt\u2019 and \u2018Freq\u2019 are integers. \u2018Pulse\u2019 is read as a string. It is either a integer number or the pulse   shape name for sciPULSE channels (from PulseNames).</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef set_nozzle_parameters(self,\n                          active_nozzles : str,\n                          selected_nozzles: str,\n                          volts : int,\n                          pulse : str,\n                          frequency : int):\n  '''\n    Sets the list of activate nozzles and of the selected nozzles for\n      operations that work with more than one nozzle.\n    (This overwrites and is overwritten by SelectNozzle, which only sets one nozzle channel.)\n    Both values are strings with commas separating the channel numbers (e.g. \u201c1,2,3\u201d).\n    \u2018Volt\u2019 and \u2018Freq\u2019 are integers.\n    \u2018Pulse\u2019 is read as a string. It is either a integer number or the pulse\n      shape name for sciPULSE channels (from PulseNames).\n\n  '''\n\n  self.send(f\"/DoD/do/SetNozzleParameters?Active={active_nozzles}&amp;Selected={selected_nozzles}&amp;Volt={volts}&amp;Pulse={pulse}&amp;Freq={frequency}\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.stop_task","title":"<code>stop_task()</code>","text":"<p>Stops the running task (and moves).</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef stop_task(self):\n  '''\n          Stops the running task (and moves).\n  '''\n  self.send(f\"/DoD/do/StopTask\")\n</code></pre>"},{"location":"DropsDriver.html#dod.DropsDriver.myClient.take_probe","title":"<code>take_probe(channel, probe_well, volume)</code>","text":"<p>This endpoint requires the presence of the task \u2018ProbeUptake\u2019 (attached). If that is not given, the return is not a reject, but nothing happens. The parameters are</p> <p>\u2018Channel\u2019 (number of nozzle, includes effect as \u2018SelectNozzle\u2019),   \u2018ProbeWell\u2019 (e.g. A1), Volume (\u00b5L). Returns a reject  if \u2018Channel\u2019 is not among   \u2018Active Nozzles\u2019, Volume is &gt; 250 or   \u2018ProbeWell\u2019 is not one of the allowed wells for the selected nozzle.</p> Source code in <code>dod/DropsDriver.py</code> <pre><code>@middle_invocation_wrapper\ndef take_probe(self, channel : int, probe_well : str, volume : float):\n    \"\"\"\n    This endpoint requires the presence of the task \u2018ProbeUptake\u2019 (attached).\n    If that is not given, the return is not a reject, but nothing happens.\n    The parameters are\n\n      \u2018Channel\u2019 (number of nozzle, includes effect as \u2018SelectNozzle\u2019),\n      \u2018ProbeWell\u2019 (e.g. A1), Volume (\u00b5L). Returns a reject  if \u2018Channel\u2019 is not among\n      \u2018Active Nozzles\u2019, Volume is &gt; 250 or\n      \u2018ProbeWell\u2019 is not one of the allowed wells for the selected nozzle.\n\n    \"\"\"\n    self.send(f\"/DoD/do/TakeProbe?Channel={channel}&amp;ProbeWell={probe_well}&amp;Volume={volume}\")\n</code></pre>"},{"location":"General.html","title":"General","text":"<p>Last Revised: 09/01/23 By: Victor Sosa Alfaro</p> <ul> <li>Link to open grafana</li> </ul> <p>+----------------------------------+----------------------------------+ | Operations notes             | Side notes                   | +==================================+==================================+ | -   XRT_Mz_Mi4A is the first yag | (started alignment around 8pm)   | |     that goes into check beam    |                                  | |     alignment                    | If there are issues viewing the  | |                                  | beam always check XPP and see if | | -   When we first arrive an hour | they have their shutter on       | |     early, if we are planning to |                                  | |     use the Rayonix start He(g)  |                                  | |     purging.                     |                                  | |                                  |                                  | | -   During beam alignment they   |                                  | |     notices that beam might be   |                                  | |     clipping. So double check    |                                  | |     and call XPP to pull out     |                                  | |     their monochromator (when we |                                  | |     did this nothing changed,    |                                  | |     but always good to double    |                                  | |     check).                      |                                  | |                                  |                                  | | -   Kept trying to trouble shoot |                                  | |     the beam issue (it looks     |                                  | |     like an oval beam rather     |                                  | |     than circle size) (It turned |                                  | |     out that a slit before the   |                                  | |     FEE was closed and it was    |                                  | |     clipping the beam [SL1LO    |                                  | |     was moved 1mm from 2.5 to    |                                  | |     3.5]. XXP also noticed this |                                  | |     issue and helped resolve     |                                  | |     it.)                         |                                  | +----------------------------------+----------------------------------+ | -   Working on MFX-dg1-yag (this | F12 is the \"oh-shit\" button      | |     is the first one to look at  |                                  | |     while aligning the beam)     |                                  | |     before the lenses            |                                  | |                                  |                                  | | -   Keep moving the beam up/down |                                  | |     to look at the beam size in  |                                  | |     increments of 20 microns     |                                  | |                                  |                                  | | -   Then put in to mfx-dg2-yag   |                                  | |     (after the lenses) this is   |                                  | |     the last one right before    |                                  | |     the sample interactions      |                                  | |                                  |                                  | | -   The final YAG in the         |                                  | |     LBL_inline                   |                                  | +----------------------------------+----------------------------------+ | -   Looking at laser alignment   | Overall having trouble getting   | |     and timing is being          | laser timing                     | |     troubleshoot                 |                                  | |                                  | (this an ongoing issue)          | | -   Having trouble view the peak |                                  | |     that correlates to the       |                                  | |     proper timing.               |                                  | |                                  |                                  | | -   Adding an amplifier to help  |                                  | |     increase laser intensity     |                                  | |                                  |                                  | | -   Overall timing was done:     |                                  | |                                  |                                  | | terminated BNC cable with 50 ohm |                                  | | resistance                       |                                  | |                                  |                                  | | -   Then timing                  |                                  | |                                  |                                  | | -                                |                                  | +----------------------------------+----------------------------------+ | -   ACR is trying to increase    |                                  | |     beam photons by changing the |                                  | |     beam laser we need above     |                                  | |     1.2-1.5mJ at 8-9mhz          |                                  | +----------------------------------+----------------------------------+ |                                  | 09/02/23                     | +----------------------------------+----------------------------------+ | The overall workflow plan for    | Plan to move the beam up since   | | the day:                         | last time there was an issue     | |                                  | with beam clipping               | | -   Bring the beam to the        |                                  | |     alvum_u2 for beam alignment  |                                  | |                                  |                                  | | -   Try to optimize the beam     |                                  | |     slits to have better focus   |                                  | |     in the beam                  |                                  | |                                  |                                  | | -   Last night they did a wire   |                                  | |     scan to determine the laser  |                                  | |     size (in microns) it helps   |                                  | |     to focus the beam.           |                                  | |                                  |                                  | | -   Focus the beam for better    |                                  | |     alignment                    |                                  | |                                  |                                  | | -   Change the laser delay by    |                                  | |     20sec (Panel 6 on FS timing  |                                  | |     EVI)                         |                                  | |                                  |                                  | | -                                |                                  | +----------------------------------+----------------------------------+ | Initial setup                    | Save setup with all the windows  | |                                  |                                  | | 1.  Turn on the epix1 and epix2  | Does not work with               | |     (done after dot is purged    |                                  | |     for 45min)                   | Takepeds with rayonix it's a     | |                                  | calibration                      | | 2.  Restart the DAQ use command  |                                  | |     ( resartdaq -w)              |                                  | |                                  |                                  | | 3.  Load all the windows under   |                                  | |     the DAQ online monitor       |                                  | |     window                       |                                  | |                                  |                                  | | 4.  Open all the windows ( )     |                                  | |                                  |                                  | | he Rayonix ( done when the box   |                                  | | has been purged)                 |                                  | |                                  |                                  | | 5.  Takepeds                     |                                  | |                                  |                                  | | 6.  Blank Rayonix                |                                  | |                                  |                                  | | 9. Cd into slac                 |                                  | |                                  |                                  | | 1.                               |                                  | +----------------------------------+----------------------------------+ |                                  |                                  | +----------------------------------+----------------------------------+ | Takepeds                         |                                  | |                                  |                                  | | 1.  To Take pedistals use        |                                  | |     command (takepeds)           |                                  | |                                  |                                  | | 2.  Copy and paste command line  |                                  | |     and Enter username and then  |                                  | |     password                     |                                  | |                                  |                                  | | 3.  then stop DAQ and restart it |                                  | |     to update graphs             |                                  | |                                  |                                  | | (this helps epix100 detects      |                                  | | become more flat, better         |                                  | | signal-to-noise)                 |                                  | |                                  |                                  | | Take dark/blank on t             |                                  | |                                  |                                  | | (make sure to do this before     |                                  | | running sample and after the LBL |                                  | | box has been purged for a while, |                                  | | the more purge occurs the        |                                  | | overall baseline it gives)       |                                  | +----------------------------------+----------------------------------+ | Insert the Rayonix into the LBL  |                                  | | chamber                          |                                  | |                                  |                                  | | 1.  Rayonix postion starts at    |                                  | |     1100mm and initially you     |                                  | |     move it to 500mm         |                                  | |                                  |                                  | | 2.  Move every 100mm steps until |                                  | |     you get to 300mm         |                                  | |                                  |                                  | | 3.  At this point the LBL group  |                                  | |     clamps the Rayonix with      |                                  | |     their DOT chamber            |                                  | |                                  |                                  | | 4.  Move by 50mm until you get   |                                  | |     to 200mm                 |                                  | |                                  |                                  | | 5.  Lastly type 188 get to the   |                                  | |     final position of 188mm  |                                  | +----------------------------------+----------------------------------+ | EPix100.1 turn on                | FEE on channel 2                 | |                                  |                                  | | 1.  Under detectors go to        |                                  | |     epix100.1                    |                                  | |                                  |                                  | | 2.  Click on detector idle       |                                  | |                                  |                                  | | 3.  Wait until the current is    |                                  | |     below 20 (this is based in   |                                  | |     the LBL box purging)         |                                  | |                                  |                                  | | 4.  Turn on by clicking detector |                                  | |     on                           |                                  | |                                  |                                  | | 5.  Then do the same for         |                                  | |     epix100.2                    |                                  | +----------------------------------+----------------------------------+ | Take Rayonix blank               | Trying to develop a way to move  | |                                  | rayonix motors without the MFX   | | Go to Users home                 | home screen as a script:         | |                                  |                                  | | 1.  Ssh into the comptur ssh. -x |                                  | |     hsuser@con-ics-mfx.rayonix |                                  | |                                  |                                  | | 2.  Kill the terminal by opening |                                  | |     \\$ killall proServ (         |                                  | |     disconnects computer, make   |                                  | |     sure nothing is              |                                  | |     running)(look by clicking    |                                  | |     up)                          |                                  | |                                  |                                  | | 3.  Open Capxure                 |                                  | |                                  |                                  | | <code>{=html}                       |                                  | | &lt;!-- --&gt;                         |                                  | |</code>                              |                                  | | 2.  Change frame to none         |                                  | |                                  |                                  | | 3.  Click normal then collect    |                                  | |     new background               |                                  | |                                  |                                  | | 4.  Click on Dark then collect   |                                  | |     new background               |                                  | |                                  |                                  | | 5.  Then quite/close capxure (go |                                  | |     to file tab and exit)        |                                  | |                                  |                                  | | 6.  On terminal Reconnect to the |                                  | |     original daq ( look for it   |                                  | |     moving up)                   |                                  | +----------------------------------+----------------------------------+ | Beam alignment                   | Alvium-u2 takes the beam on a    | |                                  | YAG                              | | 1.  Attenuate to Att(1e-5)       |                                  | |                                  | MEC after, XCS is before MFX     | | 2.  Put all three YAG on         | (mirrors)                        | |     [camviewer]                |                                  | |                                  | Grab YAG images as you go        | | 3.  Click on yag dia, dia1, dia2 |                                  | |                                  | If beam looks bad in the         | | 4.  Check that the MR14 mirror   | detectors try to move the        | |     is open (under lcls: xrt     |                                  | |                                  |                                  | | 5.  First mfx-dia_yag; att(1e-2) |                                  | |                                  |                                  | | 6.  Remove the 1^st^ yag (click  |                                  | |     on out)                      |                                  | |                                  |                                  | | 7.  Move to align next one       |                                  | |     MFX_dg1_yag                  |                                  | |                                  |                                  | | 8.  Move YAG with MR1L4 (left    |                                  | |     moves to the right and right |                                  | |     click moves to the left) to  |                                  | |     center the beam              |                                  | |                                  |                                  | | 9.  To move the beam up call     |                                  | |     ARC, moves in increments of  |                                  | |     20microns                    |                                  | |                                  |                                  | | 10. Take out DG1 and bring dg2   |                                  | |                                  |                                  | | 11. If it looks good remove dg2  |                                  | |                                  |                                  | | 12. Bring down att(1e-7) and     |                                  | |     close beam (you don't want   |                                  | |     to accidentally burn a       |                                  | |     camera)                      |                                  | |                                  |                                  | | 13. Then bring the beam into     |                                  | |     detectors Alvium and rayonix |                                  | |                                  |                                  | | 14. Make sure beam is centered   |                                  | |     and everything looks good    |                                  | |     before moving to the LBL yag |                                  | +----------------------------------+----------------------------------+ | Look at LBL YAG to [focus        | When daq fails restart           | | scan]{.ul}                       |                                  | |                                  | If terminal is dead restart the  | | 1.  When doing a focus remove    | whole computer                   | |     all the mirrors to avoid any |                                  | |     clipping ( move up 1mm)      | During focusing if the beam is   | |                                  | unstable the focus scan would    | | 2.  Att (1e-4)                   | not be great ( if you need to    | |                                  | rerun it)                        | | 3.  Local average (at 5Hz / #)  |                                  | |     from 1 to 5                  | The projection did not look      | |                                  | good.                            | | 4.  Clear out the markers then   |                                  | |     add the new Marker on left   | Things are not working with the  | |     up corner marker 2 bottom    | focusing                         | |     left                         |                                  | |                                  |                                  | | 5.  Go to cd/cds/                |                                  | |                                  |                                  | | 6.  Run focus scan: greg focus   |                                  | |     scan (under daniels folder)  |                                  | |                                  |                                  | | 7.  Run Script: ./focus _scan   |                                  | |     MFX: GIGE:LBL:01 --scan (    |                                  | |     moves the transfocator in    |                                  | |     the Z-position) (integrates  |                                  | |     the area of the              |                                  | |     full-half-max between the    |                                  | |     two markers that were added) |                                  | |                                  |                                  | | 8.  Open all the slits up to     |                                  | |     2.00 from all the yag        |                                  | |                                  |                                  | | Move to the previous focus that  |                                  | | was found previously on the Z    |                                  | | translation 120 ( this was typed |                                  | | in under (MFX Lens System)       |                                  | |                                  |                                  | | *It plots the xrays hitting a   |                                  | | yag and fitting a gaussian. Then |                                  | | the plot (transforcator z        |                                  | | position vs transforcator y or   |                                  | | x) then the dip of the graph     |                                  | | indicates the good beam focus,   |                                  | | then you can use this            |                                  | | information to update the beam   |                                  | | focus                            |                                  | +----------------------------------+----------------------------------+ | Focus Scan with Python script    | Can either run the python script | |                                  | that Leland wrote or do it       | | Run fucus_Scan('MFX_TFS.....)    | manually (see above).            | +----------------------------------+----------------------------------+ | Wire scans                       |                                  | |                                  |                                  | | 1.  Setup a projection of the    |                                  | |     alvium_u2 (image projection) |                                  | |                                  |                                  | | 2.  Grab image                   |                                  | |                                  |                                  | | 3.  Name (alv2)                  |                                  | |                                  |                                  | | 4.  Normalize Y                  |                                  | |                                  |                                  | | 5.  On DG2 and (click T1 on DG2) |                                  | |                                  |                                  | | 6.  Post                         |                                  | |                                  |                                  | | 7.  Go to Env on daq: under post |                                  | |     to plot: alv2 with jet_y     |                                  | |                                  |                                  | | 8.  Att(2e-3) slowly             |                                  | |                                  |                                  | | 9.  Run script for vertical :    |                                  | |     RE(bp.daq                    |                                  | |     _                           |                                  | | dscan([],x.jety.0.00,0.025,51, |                                  | |     events                       |                                  | |                                  |                                  | | 10. See elog run28               |                                  | |                                  |                                  | | 11. Run horizontal: RE(bp.daq    |                                  | |     _d                          |                                  | | scan([],x.trans.0.00,0.025,51, |                                  | |     events                       |                                  | |                                  |                                  | | 12. See elog run29               |                                  | |                                  |                                  | | 13.                              |                                  | +----------------------------------+----------------------------------+ | Optimize/check the slits:        |                                  | |                                  |                                  | | 1.  Checking by looking at the   |                                  | |     YAG and then on the          |                                  | |     alvium_u2                    |                                  | |                                  |                                  | | 2.  Take the slits in and out    |                                  | |     (still unclear what to look  |                                  | |     for when we move the stilts  |                                  | |     to further refine the beam)  |                                  | |                                  |                                  | | 3.                               |                                  | +----------------------------------+----------------------------------+ | Run Samples:                     | Their Tape had some contaminants | |                                  | and they washed it               | | Run samples with scripts, but    |                                  | | can also use regular daq to run  |                                  | | samples.                         |                                  | |                                  |                                  | | 1.  Have it at flip flop mode    |                                  | |                                  |                                  | | 2.  Att(1) full beam             |                                  | |                                  |                                  | | 3.  Before run start the         |                                  | |     flip-flop mode on then start |                                  | |     run on DAQ or use script     |                                  | |     which can run multiple runs  |                                  | |     back-to-back                 |                                  | |                                  |                                  | | 4.  Inspirational_autor          |                                  | | un(sample='name',run_length=300, |                                  | |     run=5) run=37                |                                  | |                                  |                                  | | 5.  If you stop the run          |                                  | |     premature: stop the          |                                  | |     flip-flop and daq.disconnect |                                  | |                                  |                                  | | 6.                               |                                  | +----------------------------------+----------------------------------+ |                                  |                                  | +----------------------------------+----------------------------------+ | Wherepsana to see where shared   |                                  | | memory is located                |                                  | |                                  |                                  | | Pick mon05 and copy paste        |                                  | |                                  |                                  | | Search history for grep source   |                                  | |                                  |                                  | | The grep lbgee                   |                                  | |                                  |                                  | | Take the python3 /cds /home      |                                  | +----------------------------------+----------------------------------+ | Event sequencer 12 is the new    |                                  | | for the flip-flop                |                                  | |                                  |                                  | | Want to make sure we are sinking |                                  | | on a 30hz with the DOT system    |                                  | +----------------------------------+----------------------------------+ | In case the actual photon energy |                                  | | readout in the attenuator is     |                                  | | wrong; (SIOC:SYS:ML00:A0627)     |                                  | | operating point process in LCLS  |                                  | | home may not be running          |                                  | +----------------------------------+----------------------------------+ | Type takepeds                    |                                  | |                                  |                                  | | When taking peds make sure to    |                                  | | shutdown and rerestart the DAQ   |                                  | | in order to actually implement   |                                  | | the new baseline.                |                                  | +----------------------------------+----------------------------------+ |                                  |                                  | +----------------------------------+----------------------------------+ | Command xkill then point at the  |                                  | | window that you want to close    |                                  | | and this should close any window |                                  | | that you need to close (only do  |                                  | | this as a last resort; make sure |                                  | | never to point at the desktop    |                                  | | since this will kill everything) |                                  | +----------------------------------+----------------------------------+ |                                  | 09/05/23                     | +----------------------------------+----------------------------------+ | How to setup/connect to XFEL GUI |                                  | |                                  |                                  | | 1.  Edit the cctbx.xfel file; by |                                  | |     changing to the proper       |                                  | |     experiment name              |                                  | |                                  |                                  | | 2.  Source the file into Python  |                                  | |                                  |                                  | | 3.  The cctbx.XFEL login window  |                                  | |     will then shows up           |                                  | |                                  |                                  | | 4.  Click on the ok button       |                                  | |                                  |                                  | | 5.  Change trail number to users |                                  | |     preference                   |                                  | |                                  |                                  | | 6.  Click on (Auto plot last     |                                  | |     five run)                    |                                  | |                                  |                                  | | 7.  Go to hide options if you    |                                  | |     cannot see plots             |                                  | +----------------------------------+----------------------------------+ |                                  |                                  | +----------------------------------+----------------------------------+ | Adjust Slits for optimized Beam  | Want to prevent clipping.        | |                                  |                                  | | 1.  Dg1 slits adjust the slits   |                                  | |     around it by adjusting the   |                                  | |     slits in 4jaw X-ray slit     |                                  | |     window (Jaws)                |                                  | |                                  |                                  | | 2.  Moving the center, width,    |                                  | |     and height by moving in 0.05 |                                  | |     movements                    |                                  | |                                  |                                  | | 3.  Then move to the next YAG    |                                  | |     dg2 (Jaws:US)                |                                  | |                                  |                                  | | 4.  move to the YAG dg3          |                                  | |     (Jaws:MS)                    |                                  | |                                  |                                  | | 5.  View the alvium_u2 (make     |                                  | |     sure to zoom-in to really    |                                  | |     view the camera) (Jaws:DS)   |                                  | |                                  |                                  | | *Looking for:                   |                                  | |                                  |                                  | | -Center the beam                 |                                  | |                                  |                                  | | -You don't want parstatic        |                                  | | scattering form the slits, you   |                                  | | want them close but not clipping |                                  | | the beam                         |                                  | +----------------------------------+----------------------------------+ | Moved the Rayonix detector away  |                                  | | from the original position (273  |                                  | | instead of 188mm), makes the     |                                  | | water ring broad on the detector |                                  | +----------------------------------+----------------------------------+</p>"},{"location":"HTTPTransceiver.html","title":"HTTPTransceiver","text":""},{"location":"HTTPTransceiver.html#dod.HTTPTransceiver.logger","title":"<code>logger = logging.getLogger(__name__)</code>  <code>module-attribute</code>","text":"<p>send transmits a formatted HTTP GET request it will not check the validity of request it will persist result in a place that can be read.</p>"},{"location":"JsonFileHandler.html","title":"JsonFileHandler","text":""},{"location":"JsonFileHandler.html#dod.JsonFileHandler.JsonFileHandler","title":"<code>JsonFileHandler</code>","text":"<p>Handle supported.json file</p> Source code in <code>dod/JsonFileHandler.py</code> <pre><code>class JsonFileHandler:\n    \"\"\"\n        Handle supported.json file\n    \"\"\"\n\n    def __init__(self, file_name : str):\n        self.file_name = file_name\n        self.data = dict() \n        self.endpoints = dict() # EndPoints\n        self.endpoints_map= dict() #MAP\n\n    def create_new_supported_file(self):\n        \"\"\"\n            Create New supported enpoints file, will not create if file already\n            exists\n        \"\"\"\n        f = None\n        try:\n            f = open(self.file_name, \"x\")\n        except:\n            logging.info(f\"{self.file_name} already exists\")\n\n        if f != None:\n            self.data = {\n                    \"header\": {\n                        \"Time\": \"\",\n                        \"Status\": {\n                            \"Status\": \"\",\n                            \"StatusCode\": 200\n                            },\n                        \"LastID\": 1,\n                        \"ErrorCode\": 0,\n                        \"ErrorMessage\": \"NA\",\n                        \"Result\": {}\n                        },\n                    \"endpoints\": []\n                    }\n\n            f.write(json.dumps(self.data, indent=4))\n            f.close()\n\n\n    def reload_endpoints(self):\n        file_fd = open(self.file_name, 'r')\n        self.data = json.load(file_fd)\n        self.endpoints = self.data[\"endpoints\"]\n\n        # map endpoint with index\n        endpointIndex = 0\n        for endpoint in self.endpoints:\n            self.endpoints_map[endpoint[\"API\"]] = endpointIndex\n            endpointIndex = endpointIndex + 1\n\n        file_fd.close()\n\n    def get_endpoint_data(self, endpoint : str):\n        logging.info(f\"looking for {endpoint}\")\n        if endpoint not in self.endpoints_map.keys():\n            logging.info(f\"{endpoint} does not exist\")\n            return None\n        else:\n            logging.info(f\"Found {endpoint}\")\n            return self.endpoints[self.endpoints_map[endpoint]]['payload']\n\n    def add_endpoint(self, endpoint : str, payload : str, args = None, comment = None):\n        \"\"\"\n            Add endpoint to Json file\n        \"\"\"\n        if endpoint in self.endpoints_map.keys():\n            logging.info(\"endpoint already exists\")\n            return \n\n        skel = { \n                \"API\": \"\", \n                \"args\": \"\",\n                \"payload\" : \"\",\n                \"__comments__\" : \"\",\n                }\n\n        skel[\"API\"] = endpoint\n        skel[\"args\"] = args\n        skel[\"payload\"] = payload\n        skel[\"__comments__\"] = comment\n\n        self.data[\"endpoints\"].append(skel)\n\n        f = open(self.file_name, \"w\")\n        f.write(json.dumps(self.data, indent=4))\n        f.close()\n\n        self.reload_endpoints()\n</code></pre>"},{"location":"JsonFileHandler.html#dod.JsonFileHandler.JsonFileHandler.add_endpoint","title":"<code>add_endpoint(endpoint, payload, args=None, comment=None)</code>","text":"<p>Add endpoint to Json file</p> Source code in <code>dod/JsonFileHandler.py</code> <pre><code>def add_endpoint(self, endpoint : str, payload : str, args = None, comment = None):\n    \"\"\"\n        Add endpoint to Json file\n    \"\"\"\n    if endpoint in self.endpoints_map.keys():\n        logging.info(\"endpoint already exists\")\n        return \n\n    skel = { \n            \"API\": \"\", \n            \"args\": \"\",\n            \"payload\" : \"\",\n            \"__comments__\" : \"\",\n            }\n\n    skel[\"API\"] = endpoint\n    skel[\"args\"] = args\n    skel[\"payload\"] = payload\n    skel[\"__comments__\"] = comment\n\n    self.data[\"endpoints\"].append(skel)\n\n    f = open(self.file_name, \"w\")\n    f.write(json.dumps(self.data, indent=4))\n    f.close()\n\n    self.reload_endpoints()\n</code></pre>"},{"location":"JsonFileHandler.html#dod.JsonFileHandler.JsonFileHandler.create_new_supported_file","title":"<code>create_new_supported_file()</code>","text":"<p>Create New supported enpoints file, will not create if file already exists</p> Source code in <code>dod/JsonFileHandler.py</code> <pre><code>def create_new_supported_file(self):\n    \"\"\"\n        Create New supported enpoints file, will not create if file already\n        exists\n    \"\"\"\n    f = None\n    try:\n        f = open(self.file_name, \"x\")\n    except:\n        logging.info(f\"{self.file_name} already exists\")\n\n    if f != None:\n        self.data = {\n                \"header\": {\n                    \"Time\": \"\",\n                    \"Status\": {\n                        \"Status\": \"\",\n                        \"StatusCode\": 200\n                        },\n                    \"LastID\": 1,\n                    \"ErrorCode\": 0,\n                    \"ErrorMessage\": \"NA\",\n                    \"Result\": {}\n                    },\n                \"endpoints\": []\n                }\n\n        f.write(json.dumps(self.data, indent=4))\n        f.close()\n</code></pre>"},{"location":"Operators_Guide.html","title":"Operators Guide","text":"<p>Last Revised: June 2024 Author: Pamela Schleissner IN CASE OF EMERGENCY PRESS F12 --&gt; Enables attenuator 11: att(1e<sup>-16</sup>)</p>"},{"location":"Operators_Guide.html#novice-user","title":"Novice User","text":"<ol> <li> <p>Starting and using the DAQ (data acquisition system):</p> <p>a.  restartdaq -- Launches daq, restartdaq -w launches DAQ     with the windows in their previous position</p> <p>b.  startami -- restarts ami, use if daq is working but ami is     frozen</p> <ul> <li>Load the window configuration</li> </ul> <p>c.  It is good practice to let the DAQ run freely to get updated     detector and AMI plots in between scans without recording     (daq.disconnect() and then \"begin run\" from dropdown menu in     DAQ window, with unchecked \"Record Run\"). Pulse picker needs to     be in 'open' or 'flip flop' mode for observations</p> </li> <li> <p>MFX Home page:</p> <p>a.  mfxhome -- Launches MFX home</p> <p>b.  Checking for faults you may have to clear if the beam goes down:     LCLS \u2192 LFE Home \u2192 General tab \u2192 PMPS Diagnostics \u2192 clear faults</p> </li> <li> <p>MFX Python:</p> <p>a.  From a seperate terminal mfx3 starts a python session</p> <p>b.  If python freezes: exit() then mfx3 to restart</p> </li> <li> <p>Open camViewer and eloggrabber from a terminal</p> </li> <li> <p>X-ray attenuation: att(1e-16) max. att(1) min attenuation \u2192     100% transmission</p> </li> <li> <p>Moving the Rayonix detector:</p> </li> </ol> <p> </p> <p>a.  Use small step sizes! If you move the detector in one step, you     will crash the detector into the spectrometer, because it overshoots     in the end!</p> <p>b.  Pull out the flight tube out (slowly) before moving the detector in</p> <p>c.  Remember to put the flight tube in against the kapton before data     collection</p> <ol> <li> <p>Pedestals:</p> <p>a.  For epix100 and epix10k2M:</p> <pre><code>i.  From a terminal: **takepeds** (will take control of daq,\n    need to disconnect DAQ if not done before), confirm X-rays\n    are blocked (**stopper S4.5 is inserted**) and it will start\n    taking pedestals\n\nii. Once takepeds is done, run **makepeds** following the prompt\n    (eg. **makepeds -u \\&lt;userid\\&gt; -q milano -r 28** )\n</code></pre> <p>b.  For the Rayonix detector:</p> <pre><code>i.  From a terminal:\\\n    \\&gt;\\&gt; **ssh -X hsuser@con-ics-mfx-rayonix**\\\n    \\&gt;\\&gt; **killall procServ**\\\n    \\&gt;\\&gt; **capxure**\\\n    \\\n    A new window will appear. Change the \"single trigger\" option\n    to \"none\". Change \"exposure\" to \"dark\". Click \"collect new\n    background\". Change \"exposure\" to \"normal\". Click \"collect\n    new background\". Change \"single trigger\" back to frame. Exit\n    this window, file \u2192 quit\\\n    \\\n    In the previous terminal: \\&gt;\\&gt;\n    **./startDaqInterface_newcradyl**\n</code></pre> <p>c.  After collecting and deploying a pedestal, allocate to the     DAQ. In the DAQ window: Shutdown \u2192 Allocate \u2192 Begin Running</p> </li> <li> <p>Running Scans:</p> <p>a.  autorun(sample = '', run_length = 300,     record=True, runs = 5, inspire=False, daq_delay=5,     picker='flip') <pre><code>i.  &lt;Sample tag&gt;: user defined\n\nii. run_length=300: in seconds\n\niii. record=True: records data in DAQ\n\niv. runs = 5: number of runs\n\nv.  inspire=False: set to True if you need some inspiration to\n    keep hope alive\n\nvi. daq_delay=5: delay time between runs. Increase is the DAQ is\n    being slow\n\nvii. picker='flip': If 'open' pulse picker opens before the run\n     starts. If 'flip' it flip-flops before run starts\n</code></pre>"},{"location":"Operators_Guide.html#troubleshooting","title":"Troubleshooting \ud83d\ude35\u200d","text":"<p>Don't see X-rays?</p> <ol> <li> <p>Did you remove the stopper 4.5?</p> </li> <li> <p>Is the pulse picker in \"flip-flop\"?</p> </li> <li> <p>Are you attenuated?</p> </li> <li> <p>Check \"are we ready?\" In a terminal type awr mfx</p> </li> </ol> <p>Are the plots frozen (AMI)?</p> <ol> <li> <p>Try shutting down the daq: In DAQ window Shutdown \u2192 Allocate     \u2192Begin Running</p> </li> <li> <p>Try restarting AMI: in a terminal that is not running python     startami</p> </li> <li> <p>Try restarting the DAQ: in a terminal window that is not running     python restartdaq -w</p> </li> <li> <p>Call beamline technical support</p> </li> </ol> <p>Is the DAQ frozen?</p> <ol> <li> <p>Try restarting the DAQ: in a terminal window that is not running     python restartdaq -w</p> </li> <li> <p>Call beamline technical support</p> </li> </ol> <p>Did the pulse picker lose its position?</p> <ol> <li> <p>On MFX home, open the pulse picker tab</p> </li> <li> <p>Click \"home motor\". It will go in \"home motor mode\"</p> </li> <li> <p>Click \"home motor\" (again). The motor will begin moving</p> </li> <li> <p>Wait until it's done moving</p> </li> <li> <p>Then hit \"Reset Mode\"</p> </li> </ol> <p> </p>"},{"location":"Operators_Guide.html#experienced-users","title":"Experienced Users","text":"<ol> <li> <p>Plotting AMI</p> </li> <li> <p>Running CCTBX</p> <p>a.  Edit cctbx.xfel file by changing the experiments name (e.g.     xcsl######)</p> <p>b.  In a terminal that is running python: source     \\&lt;path&gt;/cctbx.xfel</p> <p>c.  A new window will appear with the cctbx.XFEL login. Click OK.</p> <p>d.  Change the trial number in the options page. Click on \"Auto plot     last five runs\"</p> <p>e.  Click \"Hide Options\" to see plots. Optional \"Large text\" for big     screens.</p> </li> <li> <p>Running OM</p> </li> </ol>"},{"location":"Quick_Start.html","title":"Quick Start MFX","text":"<p>Text here</p>"},{"location":"ServerResponse.html","title":"ServerResponse","text":""},{"location":"ServerResponse.html#dod.ServerResponse.ServerResponse","title":"<code>ServerResponse</code>","text":"<p>Object for parsing incomming HTTPResponse from Robot</p> Source code in <code>dod/ServerResponse.py</code> <pre><code>class ServerResponse:\n    \"\"\"\n        Object for parsing incomming HTTPResponse from Robot\n    \"\"\"\n    def __init__(self, httObj: HTTPResponse):\n        try:\n            dat = httObj.read().decode('utf-8')\n            response = json.loads(dat)\n        except ValueError:\n            raise Exception(f\"Server did not respond in JSON; Something is wrong\\n, {dat}\")\n\n        self.TIME = response[\"Time\"]\n        self.STATUS = response[\"Status\"]\n        self.LAST_ID = response[\"LastID\"]\n        self.ERROR_CODE = response[\"ErrorCode\"]\n        self.ERROR_MESSAGE = response[\"ErrorMessage\"]\n        self.RESULTS = response[\"Result\"]\n\n    def __str__(self):\n        return f\" TIME: {self.TIME}\\n STATUS: {self.STATUS}\\n LAST_ID: {self.LAST_ID}\\n ERROR_CODE: {self.ERROR_CODE}\\n ERROR_MESSAGE: {self.ERROR_MESSAGE}\\n RESULTS: {self.RESULTS}\\n\"\n</code></pre>"},{"location":"SupporEndsHandler.html","title":"SupporEndsHandler","text":""},{"location":"SupporEndsHandler.html#dod.SupporEndsHandler.SupportedEndsHandler","title":"<code>SupportedEndsHandler</code>","text":"<p>Class meant to handle supported endpoints Json file.     Reloads endpoints, keeps track of API args, and possible 'do' actions</p> <pre><code>TODO: Write updates to JSON file?\n</code></pre> Source code in <code>dod/SupporEndsHandler.py</code> <pre><code>class SupportedEndsHandler:\n    \"\"\"\n        Class meant to handle supported endpoints Json file.\n            Reloads endpoints, keeps track of API args, and possible 'do' actions\n\n            TODO: Write updates to JSON file?\n    \"\"\"\n    def __init__(self, file : str, conn : HTTPConnection):\n        self.file = file\n        self.__queue__ = Queue()\n        self.__queue_ready__ = Semaphore(value=0)\n        self.__conn__ = conn\n        self.supported_ends = {\n          'get' : [],\n          'do' : {},\n          'conn' : []\n        }\n        self.transceiver = HTTPTransceiver(self.__conn__, self.__queue__, self.__queue_ready__)\n\n    def get_endpoints(self):\n        return self.supported_ends\n\n    def reload_endpoint(self, endpoint : str):\n        \"\"\"\n            Reloads endpoints by asking server\n        \"\"\"\n        if endpoint in self.supported_ends['do'].keys():\n          # check this do endpoint takes an argument\n          if '?' in endpoint:\n            # Any float is acceptable for pure moves\n            if 'MoveX' in endpoint or 'MoveY' in endpoint or \"MoveZ\" in endpoint:\n              return\n            cursed = f\"/DoD/get/{endpoint.split('?')[1].split('=')[0]}s\"\n            self.transceiver.send(cursed)\n            self.supported_ends['do'][endpoint] = self.transceiver.get_response().RESULTS\n\n    def reload_all(self):\n        \"\"\"\n            Reloads ALL endpoints by asking server\n        \"\"\"\n        try:\n          f = open(self.file)\n        except FileNotFoundError:\n          logger.error(\"File supported.json not found\")\n\n        with f:\n          json_data = json.load(f)[\"endpoints\"]\n          self.supported_ends['get'] = [x['API'] for x in json_data if x['API'][5:8] == 'get']\n          self.supported_ends['do'] = {x['API'] : None for x in json_data if x['API'][5:7] == 'do'}\n          self.supported_ends['conn'] = [x['API'] for x in json_data if 'connect' in x['API'][5:].lower()]\n\n        for ent in self.supported_ends['do'].keys():\n          self.reload_endpoint(ent)\n</code></pre>"},{"location":"SupporEndsHandler.html#dod.SupporEndsHandler.SupportedEndsHandler.reload_all","title":"<code>reload_all()</code>","text":"<p>Reloads ALL endpoints by asking server</p> Source code in <code>dod/SupporEndsHandler.py</code> <pre><code>def reload_all(self):\n    \"\"\"\n        Reloads ALL endpoints by asking server\n    \"\"\"\n    try:\n      f = open(self.file)\n    except FileNotFoundError:\n      logger.error(\"File supported.json not found\")\n\n    with f:\n      json_data = json.load(f)[\"endpoints\"]\n      self.supported_ends['get'] = [x['API'] for x in json_data if x['API'][5:8] == 'get']\n      self.supported_ends['do'] = {x['API'] : None for x in json_data if x['API'][5:7] == 'do'}\n      self.supported_ends['conn'] = [x['API'] for x in json_data if 'connect' in x['API'][5:].lower()]\n\n    for ent in self.supported_ends['do'].keys():\n      self.reload_endpoint(ent)\n</code></pre>"},{"location":"SupporEndsHandler.html#dod.SupporEndsHandler.SupportedEndsHandler.reload_endpoint","title":"<code>reload_endpoint(endpoint)</code>","text":"<p>Reloads endpoints by asking server</p> Source code in <code>dod/SupporEndsHandler.py</code> <pre><code>def reload_endpoint(self, endpoint : str):\n    \"\"\"\n        Reloads endpoints by asking server\n    \"\"\"\n    if endpoint in self.supported_ends['do'].keys():\n      # check this do endpoint takes an argument\n      if '?' in endpoint:\n        # Any float is acceptable for pure moves\n        if 'MoveX' in endpoint or 'MoveY' in endpoint or \"MoveZ\" in endpoint:\n          return\n        cursed = f\"/DoD/get/{endpoint.split('?')[1].split('=')[0]}s\"\n        self.transceiver.send(cursed)\n        self.supported_ends['do'][endpoint] = self.transceiver.get_response().RESULTS\n</code></pre>"},{"location":"TestJsonFileHandler.html","title":"TestJsonFileHandler","text":""},{"location":"TestJsonFileHandler.html#dod.TestJsonFileHandler.TestJsonFileHandler","title":"<code>TestJsonFileHandler</code>","text":"<p>TODO: Very basic test case, build out as we find file parsing edge casess TODO: can create test document subfolder within the testing directory</p> Source code in <code>dod/TestJsonFileHandler.py</code> <pre><code>class TestJsonFileHandler:\n    '''\n    TODO: Very basic test case, build out as we find file parsing edge casess\n    TODO: can create test document subfolder within the testing directory\n    '''\n\n    def test_file_load(self, capsys):\n        # create config parser handler\n        json_handler = JsonFileHandler(supported_json)\n        # load configs and launch web server \n        json_handler.reload_endpoints()\n        expected_resp = {\"Position\": {\n                            \"X\": 0,\n                            \"Y\": 0,\n                            \"Z\": 500\n                        },\n                        \"LastProbe\": \"\",\n                        \"Humidity\": 10,\n                        \"Temperature\": 228,\n                        \"BathTemp\": -99\n                        }\n\n        assert json_handler.get_endpoint_data(\"/DoD/get/Status\") == expected_resp\n\n    def test_file_add_endpoint(self, capsys):\n        new_file = \"tests/blank_supported.json\"\n\n        json_handler = JsonFileHandler(new_file)\n        json_handler.create_new_supported_file()\n\n        assert json_handler.get_endpoint_data(\"/DoD/get/Status\") == None\n        json_handler.reload_endpoints()\n\n        expected_resp = {\"Position\": {\n                            \"X\": 0,\n                            \"Y\": 0,\n                            \"Z\": 500\n                        },\n                        \"LastProbe\": \"\",\n                        \"Humidity\": 10,\n                        \"Temperature\": 228,\n                        \"BathTemp\": -99\n                        }\n\n        json_handler.add_endpoint(\"/DoD/get/Status\", expected_resp)\n\n        assert json_handler.get_endpoint_data(\"/DoD/get/Status\") == expected_resp\n        os.remove(new_file)\n</code></pre>"},{"location":"TestResponse.html","title":"TestResponse","text":""},{"location":"attenuator_scan.html","title":"Attenuator scan","text":""},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_separate_runs","title":"<code>attenuator_scan_separate_runs(duration=None, record=False, transmissions=[0.01, 0.02, 0.03], use_daq=True, **kwargs)</code>","text":"<p>Runs through attenuator conditions and records each as an individual run</p>"},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_separate_runs--parameters","title":"Parameters","text":"<p>duration: int, optional     When using the DAQ this corresponds to the number of events. If not     using the DAQ, it corresponds to the number of seconds to wait at ech     attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).</p> bool, optional <p>set True to record</p> list of floats, optional <p>list of transmissions to run through. default [0.01,0.02,0.03]</p> bool, optional <p>Whether to include the DAQ or not. Default: True. If False can run the scans while using the DAQ elsewhere.</p> <p>**kwargs - Additional optional keyword arguments     events: int         Provided for backwards compatibility. When using the DAQ, if this         keyword argument is passed, and <code>duration</code> is not, it will be used         as the number of events.</p>"},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_separate_runs--operations","title":"Operations","text":"Source code in <code>mfx/attenuator_scan.py</code> <pre><code>def attenuator_scan_separate_runs(\n    duration: int = None,\n    record: bool = False,\n    transmissions: list = [0.01, 0.02, 0.03],\n    use_daq: bool = True,\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Runs through attenuator conditions and records each as an individual run\n\n    Parameters\n    ----------\n    duration: int, optional\n        When using the DAQ this corresponds to the number of events. If not\n        using the DAQ, it corresponds to the number of seconds to wait at ech\n        attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).\n\n    record: bool, optional\n        set True to record\n\n    transmissions: list of floats, optional\n        list of transmissions to run through. default [0.01,0.02,0.03]\n\n    use_daq: bool, optional\n        Whether to include the DAQ or not. Default: True. If False can run the\n        scans while using the DAQ elsewhere.\n\n    **kwargs - Additional optional keyword arguments\n        events: int\n            Provided for backwards compatibility. When using the DAQ, if this\n            keyword argument is passed, and `duration` is not, it will be used\n            as the number of events.\n\n    Operations\n    ----------\n\n    \"\"\"\n    from time import sleep\n    from mfx.db import att, pp\n\n    if use_daq:\n        from mfx.db import daq\n\n    evts = kwargs.get(\"events\")\n    if duration is None:\n        if use_daq:\n            duration = evts if evts else 240\n        else:\n            duration = 3\n            if evts is not None:\n                print(\"`events` parameter ignored when not using DAQ! Use `duration`!\")\n\n    pp.open()\n    for i in transmissions:\n        att(i)\n        if use_daq:\n            sleep(3)\n            daq.begin(events=duration, record=record, wait=True, use_l3t=False)\n            daq.end_run()\n        else:\n            sleep(duration)\n    pp.close()\n    if use_daq:\n        daq.disconnect()\n</code></pre>"},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_single_run","title":"<code>attenuator_scan_single_run(duration=None, record=False, transmissions=[0.01, 0.02, 0.03], use_daq=True, **kwargs)</code>","text":"<p>Runs through attenuator conditions and records them all as one continuous run</p>"},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_single_run--parameters","title":"Parameters","text":"<p>duration: int, optional     When using the DAQ this corresponds to the number of events. If not     using the DAQ, it corresponds to the number of seconds to wait at ech     attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).</p> bool, optional <p>set True to record</p> list of floats, optional <p>list of transmissions to run through. default [0.01,0.02,0.03]</p> bool, optional <p>Whether to include the DAQ or not. Default: True. If False can run the scans while using the DAQ elsewhere.</p> <p>**kwargs - Additional optional keyword arguments     events: int         Provided for backwards compatibility. When using the DAQ, if this         keyword argument is passed, and <code>duration</code> is not, it will be used         as the number of events. It is ignored when not using the DAQ.</p>"},{"location":"attenuator_scan.html#mfx.attenuator_scan.attenuator_scan_single_run--operations","title":"Operations","text":"Source code in <code>mfx/attenuator_scan.py</code> <pre><code>def attenuator_scan_single_run(\n    duration: int = None,\n    record: bool = False,\n    transmissions: list = [0.01, 0.02, 0.03],\n    use_daq: bool = True,\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Runs through attenuator conditions and records them all as one continuous run\n\n    Parameters\n    ----------\n    duration: int, optional\n        When using the DAQ this corresponds to the number of events. If not\n        using the DAQ, it corresponds to the number of seconds to wait at ech\n        attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).\n\n    record: bool, optional\n        set True to record\n\n    transmissions: list of floats, optional\n        list of transmissions to run through. default [0.01,0.02,0.03]\n\n    use_daq: bool, optional\n        Whether to include the DAQ or not. Default: True. If False can run the\n        scans while using the DAQ elsewhere.\n\n    **kwargs - Additional optional keyword arguments\n        events: int\n            Provided for backwards compatibility. When using the DAQ, if this\n            keyword argument is passed, and `duration` is not, it will be used\n            as the number of events. It is ignored when not using the DAQ.\n\n    Operations\n    ----------\n\n    \"\"\"\n    from time import sleep\n    from mfx.db import att, pp\n\n    if use_daq:\n        from mfx.db import daq\n\n        #daq.end_run()\n        #daq.disconnect()\n\n    evts = kwargs.get(\"events\")\n    if duration is None:\n        if use_daq:\n            duration = evts if evts else 240\n        else:\n            duration = 3\n            if evts is not None:\n                print(\"`events` parameter ignored when not using DAQ! Use `duration`!\")\n\n    try:\n        pp.open()\n        if use_daq:\n            daq.configure(record=record)\n            sleep(3)\n        for i in transmissions:\n            att(i, wait=True)\n            if use_daq:\n                sleep(3)\n                daq.begin(events=duration, record=record, wait=True, use_l3t=False)\n            else:\n                sleep(duration)\n    finally:\n        if use_daq:\n            daq.end_run()\n            daq.disconnect()\n        pp.close()\n</code></pre>"},{"location":"autorun.html","title":"Autorun","text":""},{"location":"autorun.html#mfx.autorun.autorun","title":"<code>autorun(sample='?', tag=None, run_length=300, record=True, runs=5, inspire=False, daq_delay=5, picker=None, cam=None)</code>","text":"<p>Automate runs.... With optional quotes</p>"},{"location":"autorun.html#mfx.autorun.autorun--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> str, optional <p>Run group tag</p> int, optional <p>number of seconds for run 300 is default</p> bool, optional <p>set True to record</p> int, optional <p>number of runs 5 is default</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> int, optional <p>delay time between runs. Default is 5 second but increase is the DAQ is being slow.</p> str, optional <p>If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts</p>"},{"location":"autorun.html#mfx.autorun.autorun--operations","title":"Operations","text":"Source code in <code>mfx/autorun.py</code> <pre><code>def autorun(sample='?', tag=None, run_length=300, record=True,\n            runs=5, inspire=False, daq_delay=5, picker=None, cam=None):\n    \"\"\"\n    Automate runs.... With optional quotes\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    tag: str, optional\n        Run group tag\n\n    run_length: int, optional\n        number of seconds for run 300 is default\n\n    record: bool, optional\n        set True to record\n\n    runs: int, optional\n        number of runs 5 is default\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    daq_delay: int, optional\n        delay time between runs. Default is 5 second but increase is the DAQ is being slow.\n\n    picker: str, optional\n        If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    from time import sleep\n    from mfx.db import daq, pp\n    logger = logging.getLogger(__name__)\n\n    if sample.lower()=='water' or sample.lower()=='h2o':\n        inspire=True\n    if picker=='open':\n        pp.open()\n    if picker=='flip':\n        pp.flipflop()\n\n    if tag is None:\n        tag = sample\n\n    for i in range(runs):\n        logger.info(f\"Run Number {daq.run_number() + 1} Running {sample}......{quote()['quote']}\")\n        run_number = daq.run_number() + 1\n        status = begin(duration = run_length, record = record, wait = True, end_run = True)\n        if cam is not None:\n            ioc_cam_recorder(cam, run_length, tag)\n        if status is False:\n            pp.close()\n            post(sample, run_number, record, inspire, 'Run ended prematurely. Probably sample delivery problem')\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.stop()\n            daq.disconnect()\n            logger.warning('Run ended prematurely. Probably sample delivery problem')\n            break\n\n        post(sample, tag, run_number, record, inspire)\n        try:\n            sleep(daq_delay)\n        except KeyboardInterrupt:\n            pp.close()\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.disconnect()\n            status = False\n            if status is False:\n                logger.warning('Run ended prematurely. Probably sample delivery problem')\n                break\n    if status:\n        pp.close()\n        daq.end_run()\n        daq.disconnect()\n        logger.warning('Finished with all runs thank you for choosing the MFX beamline!\\n')\n</code></pre>"},{"location":"autorun.html#mfx.autorun.begin","title":"<code>begin(events=None, duration=300, record=False, use_l3t=None, controls=None, wait=False, end_run=False)</code>","text":"<p>Start the daq and block until the daq has begun acquiring data.</p> <p>Optionally block with <code>wait=True</code> until the daq has finished aquiring data. If blocking, a <code>ctrl+c</code> will end the run and clean up.</p> <p>If omitted, any argument that is shared with <code>configure</code> will fall back to the configured value.</p> <p>Internally, this calls <code>kickoff</code> and manages its <code>Status</code> object.</p>"},{"location":"autorun.html#mfx.autorun.begin--parameters","title":"Parameters","text":"<p>events: <code>int</code>, optional     Number events to take in the daq.</p> <code>int</code>, optional <p>Time to run the daq in seconds, if <code>events</code> was not provided.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll configure the daq to record data before this run.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll run with the level 3 trigger. This means that if we specified a number of events, we will wait for that many \"good\" events as determined by the daq.</p> <code>dict{name: device}</code> or <code>list[device...]</code>, optional <p>If provided, values from these will make it into the DAQ data stream as variables. We will check <code>device.position</code> and <code>device.value</code> for quantities to use and we will update these values each time begin is called. To provide a list, all devices must have a <code>name</code> attribute.</p> <code>bool</code>, optional <p>If <code>True</code>, wait for the daq to finish aquiring data. A <code>KeyboardInterrupt</code> (<code>ctrl+c</code>) during this wait will end the run and clean up.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll end the run after the daq has stopped.</p> Source code in <code>mfx/autorun.py</code> <pre><code>def begin(events=None, duration=300,\n          record=False, use_l3t=None, controls=None,\n          wait=False, end_run=False):\n    \"\"\"\n    Start the daq and block until the daq has begun acquiring data.\n\n    Optionally block with ``wait=True`` until the daq has finished aquiring\n    data. If blocking, a ``ctrl+c`` will end the run and clean up.\n\n    If omitted, any argument that is shared with `configure`\n    will fall back to the configured value.\n\n    Internally, this calls `kickoff` and manages its ``Status`` object.\n\n    Parameters\n    ----------\n    events: ``int``, optional\n        Number events to take in the daq.\n\n    duration: ``int``, optional\n        Time to run the daq in seconds, if ``events`` was not provided.\n\n    record: ``bool``, optional\n        If ``True``, we'll configure the daq to record data before this\n        run.\n\n    use_l3t: ``bool``, optional\n        If ``True``, we'll run with the level 3 trigger. This means that\n        if we specified a number of events, we will wait for that many\n        \"good\" events as determined by the daq.\n\n    controls: ``dict{name: device}`` or ``list[device...]``, optional\n        If provided, values from these will make it into the DAQ data\n        stream as variables. We will check ``device.position`` and\n        ``device.value`` for quantities to use and we will update these\n        values each time begin is called. To provide a list, all devices\n        must have a ``name`` attribute.\n\n    wait: ``bool``, optional\n        If ``True``, wait for the daq to finish aquiring data. A\n        ``KeyboardInterrupt`` (``ctrl+c``) during this wait will end the\n        run and clean up.\n\n    end_run: ``bool``, optional\n        If ``True``, we'll end the run after the daq has stopped.\n    \"\"\"\n    import logging\n    from time import sleep\n    from mfx.db import daq\n    from ophyd.utils import StatusTimeoutError, WaitTimeoutError\n    logger = logging.getLogger(__name__)\n\n    logger.debug(('Daq.begin(events=%s, duration=%s, record=%s, '\n                    'use_l3t=%s, controls=%s, wait=%s)'),\n                    events, duration, record, use_l3t, controls, wait)\n    status = True\n    try:\n        if record is not None and record != daq.record:\n            old_record = daq.record\n            daq.preconfig(record=record, show_queued_cfg=False)\n        begin_status = daq.kickoff(events=events, duration=duration,\n                                    use_l3t=use_l3t, controls=controls)\n        try:\n            begin_status.wait(timeout=daq._begin_timeout)\n        except (StatusTimeoutError, WaitTimeoutError) as e:\n            msg = (f'Timeout after {daq._begin_timeout} seconds waiting '\n                    'for daq to begin. Exception: {type(e).__name__}')\n            logger.info(msg)\n            #raise DaqTimeoutError(msg) from None\n\n        # In some daq configurations the begin status returns very early,\n        # so we allow the user to configure an emperically derived extra\n        # sleep.\n        sleep(daq.config['begin_sleep'])\n        if wait:\n            daq.wait()\n            if end_run:\n                daq.end_run()\n        if end_run and not wait:\n            threading.Thread(target=daq._ender_thread, args=()).start()\n        return status\n    except KeyboardInterrupt:\n            status = False\n            return status\n</code></pre>"},{"location":"autorun.html#mfx.autorun.ioc_cam_recorder","title":"<code>ioc_cam_recorder(cam='camera name', run_length=10, tag='?')</code>","text":"<p>Record IOC Cameras</p>"},{"location":"autorun.html#mfx.autorun.ioc_cam_recorder--parameters","title":"Parameters","text":"<p>cam: str, required     Select camera PV you'd like to record</p> int, required <p>number of seconds for recording. 10 is default</p> str, required <p>Run group tag</p>"},{"location":"autorun.html#mfx.autorun.ioc_cam_recorder--operations","title":"Operations","text":"Source code in <code>mfx/autorun.py</code> <pre><code>def ioc_cam_recorder(cam='camera name', run_length=10, tag='?'):\n    \"\"\"\n    Record IOC Cameras\n\n    Parameters\n    ----------\n    cam: str, required\n        Select camera PV you'd like to record\n\n    run_length: int, required\n        number of seconds for recording. 10 is default\n\n    tag: str, required\n        Run group tag\n\n    Operations\n    ----------\n\n    \"\"\"\n    import subprocess\n    from epics import caget\n    import logging\n    from mfx.bash_utilities import bs\n    bs = bs()\n    camera_names = bs.camera_list_out()\n    if cam not in [pv[1] for pv in camera_names]:\n            logging.info(\"Desired Camera not in List. Please choose from the above list:.\")\n    else:\n        rate = caget(f'{cam}:ArrayRate_RBV')\n        n_images = int(run_length * rate)\n        logging.info(f\"Recording Camera {cam} for {run_length} sec\")\n        logging.info(\n            f\"/reg/g/pcds/engineering_tools/latest-released/scripts/image_saver -c {cam} -n {n_images} -f {tag} -p /cds/data/iocData\")\n\n        subprocess.Popen(\n            [f\"source /cds/group/pcds/pyps/conda/pcds_conda; /reg/g/pcds/engineering_tools/latest-released/scripts/image_saver -c {cam} -n {n_images} -f {tag} -p /cds/data/iocData\"],\n            shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"autorun.html#mfx.autorun.post","title":"<code>post(sample='?', tag=None, run_number=None, post=False, inspire=False, add_note='')</code>","text":"<p>Posts a message to the elog</p>"},{"location":"autorun.html#mfx.autorun.post--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> int, optional <p>Run Number. By default this is read off of the DAQ</p> bool, optional <p>set True to record/post message to elog</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> string, optional <p>adds additional note to elog message</p> Source code in <code>mfx/autorun.py</code> <pre><code>def post(sample='?', tag=None, run_number=None, post=False, inspire=False, add_note=''):\n    \"\"\"\n    Posts a message to the elog\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    run_number: int, optional\n        Run Number. By default this is read off of the DAQ\n\n    post: bool, optional\n        set True to record/post message to elog\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    add_note: string, optional\n        adds additional note to elog message \n    \"\"\"\n    from mfx.db import daq, elog\n    if add_note!='':\n        add_note = '\\n' + add_note\n    if tag is None:\n        tag = sample\n    if inspire:\n        comment = f\"Running {sample}\\n{quote()['quote']}{add_note}\"\n    else:\n        comment = f\"Running {sample}{add_note}\"\n    if run_number is None:\n        run_number = daq.run_number()\n    info = [run_number, comment]\n    post_msg = post_template.format(*info)\n    print('\\n' + post_msg + '\\n')\n    if post:\n        elog.post(msg=post_msg, tags=tag, run=(run_number))\n    return post_msg\n</code></pre>"},{"location":"bash_utilities.html","title":"Bash utilities","text":""},{"location":"beamline.html","title":"Beamline","text":""},{"location":"beamline.html#mfx.beamline.CoDI","title":"<code>CoDI</code>","text":"Source code in <code>dod/codi.py</code> <pre><code>class CoDI: \n    def __init__(self, reload_presets = False):\n        \"\"\"\n        Class definition of the DoD codi injector \n        Parameters\n        reload_presets : Boolean\n            force resetting the presets (overwriting existing hutch presets)\n        ----------\n        \"\"\"\n\n        from pcdsdevices.device import ObjectComponent as OCpt\n        from pcdsdevices.epics_motor import SmarAct, Motor\n        import time\n\n        # CoDI motor PVs loading \n        self.CoDI_rot_left = SmarAct('MFX:MCS2:01:m3', name='CoDI_rot_left')\n        self.CoDI_rot_right = SmarAct('MFX:MCS2:01:m1', name='CoDI_rot_right')\n        self.CoDI_rot_base = SmarAct('MFX:MCS2:01:m2', name='CoDI_rot_base')\n        self.CoDI_trans_z = SmarAct('MFX:MCS2:01:m4', name='CoDI_trans_z')\n\n        #Predefined positions CoDI\n        self.CoDI_pos_predefined = dict()\n\n        if reload_presets == True: \n            # self.CoDI_pos_predefined['aspiration'] = (0.0,0.0,0.0,0.0) \n            # self.CoDI_pos_predefined['angled_vert'] = (0.0,45.0,45.0,0.0)\n            # self.CoDI_pos_predefined['angled_hor'] = (90.0,45.0,45.0,0.0)\n\n            self.set_CoDI_predefined('aspiration',0.0,0.0,0.0,0.0)\n            self.set_CoDI_predefined('angled_vert',0.0,45.0,45.0,0.0)\n            self.set_CoDI_predefined('angled_hor',90.0,45.0,45.0,0.0)\n        else: \n            all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n            for preset, preset_value in all_presets.items(): \n                try: \n                    # get preset position\n                    exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n                    exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n                    exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n                    exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n                    exec(exec_base)\n                    exec(exec_rot_left)\n                    exec(exec_rot_right)\n                    exec(exec_trans_z)\n\n                    # Save to local database\n                    print(preset)\n                    self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n                except: \n                    print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n\n        # # create config parser handler\n        # json_handler = JsonFileHandler(supported_json)\n        # # load configs and launch web server\n        # json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n\n\n    def get_CoDI_predefined(self):\n\n\n        return self.CoDI_pos_predefined\n\n\n    def update_CoDI_predefined(self): \n        'reloads all the hutch python presets for motors and overwrites local position preset dict'\n\n        #Predefined positions CoDI\n        self.CoDI_pos_predefined = dict()\n\n        all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n        for preset in all_presets.keys(): \n            # try: \n            # get preset position\n            self.exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n            self.exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n            self.exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n            self.exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n            print(self.exec_base)\n            exec(self.exec_base)\n\n            exec(self.exec_rot_left)\n            print(self.exec_rot_left)\n\n            exec(self.exec_rot_right)\n            print(self.exec_rot_left)\n\n            exec(self.exec_trans_z)\n            print(self.exec_trans_z)\n            print(preset_trans_z)\n\n            # Save to local database\n            print(preset)\n            self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n            # except: \n            #     print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n    def set_CoDI_predefined(self, name, base, left, right, z):\n        \"\"\"\n        defines or updates a predefined combination for CoDI\n\n        Parameters\n        name : str\n            name of the pre-definition\n        base : float\n            rotation of base\n        left : float\n            rotation of left injector\n        right : float\n            rotation of right injector\n        z : float\n            translation of right injector\n        ----------\n\n        \"\"\"\n        self.CoDI_pos_predefined.update({name: (base,left, right, z)})\n\n        # Presets using MFX presets functionalities \n        self.CoDI_rot_left.presets.add_hutch(name, value = left)\n        self.CoDI_rot_right.presets.add_hutch(name, value = right)\n        self.CoDI_rot_base.presets.add_hutch(name, value = base)\n        self.CoDI_trans_z.presets.add_hutch(name, value = z)\n\n\n\n    def get_CoDI_pos(self, precision_digits = 1): \n        \"\"\"\n        gets the colliding droplet injector motor positions as tuple\n\n        Parameters\n        precision_digits : int\n            precision with which the pre-defined positions are checked \n\n        ----------\n        Return : (tuple, 5)\n            motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)\n        \"\"\"\n        pos_rot_base  = self.CoDI_rot_base.wm()\n        pos_rot_left  = self.CoDI_rot_left.wm()\n        pos_rot_right = self.CoDI_rot_right.wm()\n        pos_trans_z   = self.CoDI_trans_z.wm()\n\n        # # for testing purposes\n        # pos_rot_base  = 0\n        # pos_rot_left  = 45\n        # pos_rot_right = 45\n        # pos_trans_z   = 0\n\n        pos_tuple = (pos_rot_base,pos_rot_left, pos_rot_right,pos_trans_z)\n\n        pos_rounded = tuple([float(round(each_pos,1)) for each_pos in pos_tuple])\n\n        # Test if this is one of the preset positions: \n        pos_name = 'undefined'\n        for preset in self.CoDI_pos_predefined:\n            preset_rounded = tuple([float(round(each_pos,1)) for each_pos in self.CoDI_pos_predefined[preset]])\n            if preset_rounded[:-1] == pos_rounded[:-1]: \n                pos_name = preset\n\n        return pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z\n\n\n    def set_CoDI_pos(self, pos_name, wait = True): \n        \"\"\"\n        Moves the colliding droplet injector into a pre-defined position. \n\n        Parameters\n        pos_name : string\n            name of the pre-defined position\n        wait : boolean\n            if the robot waits before continuing further steps\n\n        ----------\n        Return : \n\n        \"\"\"\n        # pos_rot_base  = CoDI_base.wm()\n        # pos_rot_left  = CoDI_left.wm()\n        # pos_rot_right = CoDI_right.wm()\n        # pos_trans_z   = CoDI_z.wm()\n        import time\n\n        # get target positions\n        pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[pos_name]\n\n        # Move motors\n\n        # Old wayy \n        # self.CoDI_rot_base.mv(pos_rot_base, wait=False)\n        # self.CoDI_rot_left.mv(pos_rot_left,  wait=False)\n        # self.CoDI_rot_right.mv(pos_rot_right, wait=False)\n        # self.CoDI_trans_z.mv(pos_trans_z, wait=False)\n\n        # Move using hutch python presets\n        exec_base = \"self.CoDI_rot_base.mv_\" + pos_name + '()'\n        exec(exec_base)\n        exec_left = \"self.CoDI_rot_left.mv_\" + pos_name + '()'\n        exec(exec_left)\n        exec_right = \"self.CoDI_rot_right.mv_\" + pos_name + '()'\n        exec(exec_right)\n        exec_z = \"self.CoDI_trans_z.mv_\" + pos_name + '()'\n        exec(exec_z)\n\n        if wait == True: \n            test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n            i = 0\n            while pos_name != test_name: \n                time.sleep(1)\n                print('\\r waiting for motion to end: %i s' %i, end=\"\\r\")\n                i = i+1\n                test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n            print('Motion ended')\n\n\n    def set_CoDI_current_pos(self, name):\n        \"\"\"\n        defines or updates the current motor combination for CoDI\n\n        Parameters\n        name : str\n            name of the pre-definition\n        ----------\n\n        \"\"\"\n        pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.get_CoDI_pos()\n        self.set_CoDI_predefined(name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z)\n\n\n    def set_CoDI_current_z(self, verbose = True):\n        \"\"\"\n        sets the current z position to all preloaded positions\n        Useful for global change of z after aligning\n\n        Parameters\n        verbose : Boolean\n            prints the new positions as a sanity check if True\n        ----------\n\n        \"\"\"\n        # get current z position:\n        pos_trans_z_new  = self.CoDI_trans_z.wm()\n\n        # get all keys from the positions\n        position_keys = self.CoDI_pos_predefined.keys\n\n        #go through all positions and change the z-value to the current z value\n        for key in position_keys: \n            pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[key]\n            self.set_CoDI_predefined(pos_name,pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z_new)\n\n        #Print the new predefined positions as a sanity check\n        if verbose == True:\n            print(self.get_CoDI_predefined)\n\n\n    def remove_CoDI_pos(self, name):\n        \"\"\"\n        removes the defined motor combination for CoDI from local database\n\n        Parameters\n        name : str\n            name of the pre-definition to be deleted\n        ----------\n\n        \"\"\"\n        del self.CoDI_pos_predefined[name]\n\n\n    def move_z_rel(self, z_rel):\n        \"\"\"\n        moves the z position relative to the current position \n\n        Parameters\n        z_rel : float\n            relative motion in mm\n        ----------\n\n        \"\"\"\n        # get current z position:\n        pos_trans_z  = self.CoDI_trans_z.wm()\n\n        # set new position\n        self.CoDI_trans_z.umvr(z_rel)\n\n    def move_rot_left_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the left nozzle relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_left  = self.CoDI_rot_left.wm()\n\n        # set new position: \n        self.CoDI_rot_left.umvr(rot_rel)\n\n\n    def move_rot_right_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the right nozzle relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_right  = self.CoDI_rot_right.wm()\n\n        # set new position: \n        self.CoDI_rot_right.umvr(rot_rel)\n\n\n    def move_rot_base_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the base relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_base  = self.CoDI_rot_base.wm()\n\n        # set new position: \n        self.CoDI_rot_base.umvr(rot_rel)\n\n\n    def move_z_abs(self, z_abs):\n        \"\"\"\n        moves the z position to the absolute position in mm\n\n        Parameters\n        z_abs : float\n            absolute motion in mm\n        ----------\n\n        \"\"\"\n        # move z position:\n        self.CoDI_trans_z.umv(z_abs)\n\n\n    def move_rot_left_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the left nozzle to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_left.umv(rot_abs)\n\n\n    def move_rot_right_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the right nozzle to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_right.umv(rot_abs)\n\n\n    def move_rot_base_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the base to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_base.umv(rot_abs)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.__init__","title":"<code>__init__(reload_presets=False)</code>","text":"<p>Class definition of the DoD codi injector  Parameters reload_presets : Boolean     force resetting the presets (overwriting existing hutch presets)</p> Source code in <code>dod/codi.py</code> <pre><code>def __init__(self, reload_presets = False):\n    \"\"\"\n    Class definition of the DoD codi injector \n    Parameters\n    reload_presets : Boolean\n        force resetting the presets (overwriting existing hutch presets)\n    ----------\n    \"\"\"\n\n    from pcdsdevices.device import ObjectComponent as OCpt\n    from pcdsdevices.epics_motor import SmarAct, Motor\n    import time\n\n    # CoDI motor PVs loading \n    self.CoDI_rot_left = SmarAct('MFX:MCS2:01:m3', name='CoDI_rot_left')\n    self.CoDI_rot_right = SmarAct('MFX:MCS2:01:m1', name='CoDI_rot_right')\n    self.CoDI_rot_base = SmarAct('MFX:MCS2:01:m2', name='CoDI_rot_base')\n    self.CoDI_trans_z = SmarAct('MFX:MCS2:01:m4', name='CoDI_trans_z')\n\n    #Predefined positions CoDI\n    self.CoDI_pos_predefined = dict()\n\n    if reload_presets == True: \n        # self.CoDI_pos_predefined['aspiration'] = (0.0,0.0,0.0,0.0) \n        # self.CoDI_pos_predefined['angled_vert'] = (0.0,45.0,45.0,0.0)\n        # self.CoDI_pos_predefined['angled_hor'] = (90.0,45.0,45.0,0.0)\n\n        self.set_CoDI_predefined('aspiration',0.0,0.0,0.0,0.0)\n        self.set_CoDI_predefined('angled_vert',0.0,45.0,45.0,0.0)\n        self.set_CoDI_predefined('angled_hor',90.0,45.0,45.0,0.0)\n    else: \n        all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n        for preset, preset_value in all_presets.items(): \n            try: \n                # get preset position\n                exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n                exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n                exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n                exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n                exec(exec_base)\n                exec(exec_rot_left)\n                exec(exec_rot_right)\n                exec(exec_trans_z)\n\n                # Save to local database\n                print(preset)\n                self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n            except: \n                print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n\n    # # create config parser handler\n    # json_handler = JsonFileHandler(supported_json)\n    # # load configs and launch web server\n    # json_handler.reload_endpoints()\n\n    # Flag that can be used later on for safety aborts during task execution\n    self.safety_abort = False\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.get_CoDI_pos","title":"<code>get_CoDI_pos(precision_digits=1)</code>","text":"<p>gets the colliding droplet injector motor positions as tuple</p> <p>Parameters precision_digits : int     precision with which the pre-defined positions are checked </p> <p>Return : (tuple, 5)     motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)</p> Source code in <code>dod/codi.py</code> <pre><code>def get_CoDI_pos(self, precision_digits = 1): \n    \"\"\"\n    gets the colliding droplet injector motor positions as tuple\n\n    Parameters\n    precision_digits : int\n        precision with which the pre-defined positions are checked \n\n    ----------\n    Return : (tuple, 5)\n        motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)\n    \"\"\"\n    pos_rot_base  = self.CoDI_rot_base.wm()\n    pos_rot_left  = self.CoDI_rot_left.wm()\n    pos_rot_right = self.CoDI_rot_right.wm()\n    pos_trans_z   = self.CoDI_trans_z.wm()\n\n    # # for testing purposes\n    # pos_rot_base  = 0\n    # pos_rot_left  = 45\n    # pos_rot_right = 45\n    # pos_trans_z   = 0\n\n    pos_tuple = (pos_rot_base,pos_rot_left, pos_rot_right,pos_trans_z)\n\n    pos_rounded = tuple([float(round(each_pos,1)) for each_pos in pos_tuple])\n\n    # Test if this is one of the preset positions: \n    pos_name = 'undefined'\n    for preset in self.CoDI_pos_predefined:\n        preset_rounded = tuple([float(round(each_pos,1)) for each_pos in self.CoDI_pos_predefined[preset]])\n        if preset_rounded[:-1] == pos_rounded[:-1]: \n            pos_name = preset\n\n    return pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_base_abs","title":"<code>move_rot_base_abs(rot_abs)</code>","text":"<p>moves the rotation of the base to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_base_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the base to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_base.umv(rot_abs)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_base_rel","title":"<code>move_rot_base_rel(rot_rel)</code>","text":"<p>moves the rotation of the base relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_base_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the base relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_base  = self.CoDI_rot_base.wm()\n\n    # set new position: \n    self.CoDI_rot_base.umvr(rot_rel)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_left_abs","title":"<code>move_rot_left_abs(rot_abs)</code>","text":"<p>moves the rotation of the left nozzle to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_left_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the left nozzle to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_left.umv(rot_abs)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_left_rel","title":"<code>move_rot_left_rel(rot_rel)</code>","text":"<p>moves the rotation of the left nozzle relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_left_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the left nozzle relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_left  = self.CoDI_rot_left.wm()\n\n    # set new position: \n    self.CoDI_rot_left.umvr(rot_rel)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_right_abs","title":"<code>move_rot_right_abs(rot_abs)</code>","text":"<p>moves the rotation of the right nozzle to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_right_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the right nozzle to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_right.umv(rot_abs)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_rot_right_rel","title":"<code>move_rot_right_rel(rot_rel)</code>","text":"<p>moves the rotation of the right nozzle relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_right_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the right nozzle relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_right  = self.CoDI_rot_right.wm()\n\n    # set new position: \n    self.CoDI_rot_right.umvr(rot_rel)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_z_abs","title":"<code>move_z_abs(z_abs)</code>","text":"<p>moves the z position to the absolute position in mm</p> <p>Parameters z_abs : float     absolute motion in mm</p> Source code in <code>dod/codi.py</code> <pre><code>def move_z_abs(self, z_abs):\n    \"\"\"\n    moves the z position to the absolute position in mm\n\n    Parameters\n    z_abs : float\n        absolute motion in mm\n    ----------\n\n    \"\"\"\n    # move z position:\n    self.CoDI_trans_z.umv(z_abs)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.move_z_rel","title":"<code>move_z_rel(z_rel)</code>","text":"<p>moves the z position relative to the current position </p> <p>Parameters z_rel : float     relative motion in mm</p> Source code in <code>dod/codi.py</code> <pre><code>def move_z_rel(self, z_rel):\n    \"\"\"\n    moves the z position relative to the current position \n\n    Parameters\n    z_rel : float\n        relative motion in mm\n    ----------\n\n    \"\"\"\n    # get current z position:\n    pos_trans_z  = self.CoDI_trans_z.wm()\n\n    # set new position\n    self.CoDI_trans_z.umvr(z_rel)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.remove_CoDI_pos","title":"<code>remove_CoDI_pos(name)</code>","text":"<p>removes the defined motor combination for CoDI from local database</p> <p>Parameters name : str     name of the pre-definition to be deleted</p> Source code in <code>dod/codi.py</code> <pre><code>def remove_CoDI_pos(self, name):\n    \"\"\"\n    removes the defined motor combination for CoDI from local database\n\n    Parameters\n    name : str\n        name of the pre-definition to be deleted\n    ----------\n\n    \"\"\"\n    del self.CoDI_pos_predefined[name]\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.set_CoDI_current_pos","title":"<code>set_CoDI_current_pos(name)</code>","text":"<p>defines or updates the current motor combination for CoDI</p> <p>Parameters name : str     name of the pre-definition</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_current_pos(self, name):\n    \"\"\"\n    defines or updates the current motor combination for CoDI\n\n    Parameters\n    name : str\n        name of the pre-definition\n    ----------\n\n    \"\"\"\n    pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.get_CoDI_pos()\n    self.set_CoDI_predefined(name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.set_CoDI_current_z","title":"<code>set_CoDI_current_z(verbose=True)</code>","text":"<p>sets the current z position to all preloaded positions Useful for global change of z after aligning</p> <p>Parameters verbose : Boolean     prints the new positions as a sanity check if True</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_current_z(self, verbose = True):\n    \"\"\"\n    sets the current z position to all preloaded positions\n    Useful for global change of z after aligning\n\n    Parameters\n    verbose : Boolean\n        prints the new positions as a sanity check if True\n    ----------\n\n    \"\"\"\n    # get current z position:\n    pos_trans_z_new  = self.CoDI_trans_z.wm()\n\n    # get all keys from the positions\n    position_keys = self.CoDI_pos_predefined.keys\n\n    #go through all positions and change the z-value to the current z value\n    for key in position_keys: \n        pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[key]\n        self.set_CoDI_predefined(pos_name,pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z_new)\n\n    #Print the new predefined positions as a sanity check\n    if verbose == True:\n        print(self.get_CoDI_predefined)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.set_CoDI_pos","title":"<code>set_CoDI_pos(pos_name, wait=True)</code>","text":"<p>Moves the colliding droplet injector into a pre-defined position. </p> <p>Parameters pos_name : string     name of the pre-defined position wait : boolean     if the robot waits before continuing further steps</p> <p>Return :</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_pos(self, pos_name, wait = True): \n    \"\"\"\n    Moves the colliding droplet injector into a pre-defined position. \n\n    Parameters\n    pos_name : string\n        name of the pre-defined position\n    wait : boolean\n        if the robot waits before continuing further steps\n\n    ----------\n    Return : \n\n    \"\"\"\n    # pos_rot_base  = CoDI_base.wm()\n    # pos_rot_left  = CoDI_left.wm()\n    # pos_rot_right = CoDI_right.wm()\n    # pos_trans_z   = CoDI_z.wm()\n    import time\n\n    # get target positions\n    pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[pos_name]\n\n    # Move motors\n\n    # Old wayy \n    # self.CoDI_rot_base.mv(pos_rot_base, wait=False)\n    # self.CoDI_rot_left.mv(pos_rot_left,  wait=False)\n    # self.CoDI_rot_right.mv(pos_rot_right, wait=False)\n    # self.CoDI_trans_z.mv(pos_trans_z, wait=False)\n\n    # Move using hutch python presets\n    exec_base = \"self.CoDI_rot_base.mv_\" + pos_name + '()'\n    exec(exec_base)\n    exec_left = \"self.CoDI_rot_left.mv_\" + pos_name + '()'\n    exec(exec_left)\n    exec_right = \"self.CoDI_rot_right.mv_\" + pos_name + '()'\n    exec(exec_right)\n    exec_z = \"self.CoDI_trans_z.mv_\" + pos_name + '()'\n    exec(exec_z)\n\n    if wait == True: \n        test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n        i = 0\n        while pos_name != test_name: \n            time.sleep(1)\n            print('\\r waiting for motion to end: %i s' %i, end=\"\\r\")\n            i = i+1\n            test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n        print('Motion ended')\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.set_CoDI_predefined","title":"<code>set_CoDI_predefined(name, base, left, right, z)</code>","text":"<p>defines or updates a predefined combination for CoDI</p> <p>Parameters name : str     name of the pre-definition base : float     rotation of base left : float     rotation of left injector right : float     rotation of right injector z : float     translation of right injector</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_predefined(self, name, base, left, right, z):\n    \"\"\"\n    defines or updates a predefined combination for CoDI\n\n    Parameters\n    name : str\n        name of the pre-definition\n    base : float\n        rotation of base\n    left : float\n        rotation of left injector\n    right : float\n        rotation of right injector\n    z : float\n        translation of right injector\n    ----------\n\n    \"\"\"\n    self.CoDI_pos_predefined.update({name: (base,left, right, z)})\n\n    # Presets using MFX presets functionalities \n    self.CoDI_rot_left.presets.add_hutch(name, value = left)\n    self.CoDI_rot_right.presets.add_hutch(name, value = right)\n    self.CoDI_rot_base.presets.add_hutch(name, value = base)\n    self.CoDI_trans_z.presets.add_hutch(name, value = z)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.CoDI.update_CoDI_predefined","title":"<code>update_CoDI_predefined()</code>","text":"<p>reloads all the hutch python presets for motors and overwrites local position preset dict</p> Source code in <code>dod/codi.py</code> <pre><code>def update_CoDI_predefined(self): \n    'reloads all the hutch python presets for motors and overwrites local position preset dict'\n\n    #Predefined positions CoDI\n    self.CoDI_pos_predefined = dict()\n\n    all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n    for preset in all_presets.keys(): \n        # try: \n        # get preset position\n        self.exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n        self.exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n        self.exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n        self.exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n        print(self.exec_base)\n        exec(self.exec_base)\n\n        exec(self.exec_rot_left)\n        print(self.exec_rot_left)\n\n        exec(self.exec_rot_right)\n        print(self.exec_rot_left)\n\n        exec(self.exec_trans_z)\n        print(self.exec_trans_z)\n        print(preset_trans_z)\n\n        # Save to local database\n        print(preset)\n        self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug","title":"<code>Debug</code>","text":"Source code in <code>mfx/debug.py</code> <pre><code>class Debug:\n    def __init__(self):\n        import os\n        full_ioc_serverlist = os.popen(f\"netconfig search ioc-mfx* --brief\").read().splitlines()\n        full_daq_serverlist = os.popen(f\"netconfig search daq-mfx* --brief\").read().splitlines()\n        self.ioc_serverlist = [ioc for ioc in full_ioc_serverlist if not ioc.endswith(\n            \"-ipmi\") and not ioc.endswith(\"-fez\") and not ioc.endswith(\"-ics\")]\n        self.daq_serverlist = [ioc for ioc in full_daq_serverlist if not ioc.endswith(\n            \"-ipmi\") and not ioc.endswith(\"-fez\") and not ioc.endswith(\"-ana\")]\n\n\n    def awr(self, hutch='mfx'):\n        \"\"\"\n        Checks if the beamline is ready to take beam\n\n        Parameters\n        ----------\n        hutch: str, optional\n            Specify the hutch you want to check. Default is MFX because it is the best\n        \"\"\"\n        import os\n        import logging\n        logging.info(f\"{hutch} Beamline Check\")\n        os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/awr {hutch}\")\n\n\n    def motor_check(self):\n        import os\n        import logging\n        logging.info(f\"Powering up all available motors\")\n        os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/mfxpowerup.sh\")\n\n\n    def check_server(self, server):\n        \"\"\"\n        Checks the status of an individual server\n\n        Parameters\n        ----------\n        server: str, required\n            Specify the server name to check. Use debug.server_list('all') to see all servers\n        \"\"\"\n        import os\n        import logging\n        status = None\n        if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n            logging.info(f\"Checking the status of: {server}\")\n            status = os.popen(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} status\").read().splitlines()\n        else:\n            logging.info(f\"The server you are looking for does not exist please select one of the following\")\n            self.server_list('ioc')\n            self.server_list('daq')\n        return status\n\n\n    def cycle_server(self, server):\n        \"\"\"\n        Cycles an individual server\n\n        Parameters\n        ----------\n        server: str, required\n            Specify the server name to cycle. Use debug.server_list('all') to see all servers\n        \"\"\"\n        import os\n        import logging\n        if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n            logging.info(f\"Power cycling: {server}\")\n            os.system(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} cycle\")\n        else:\n            logging.info(f\"The server you are looking for does not exist please select one of the following\")\n            self.server_list('ioc')\n            self.server_list('daq')\n\n\n    def check_all_servers(self, server_type):\n        \"\"\"\n        Checks the status of all servers local to MFX\n\n        Parameters\n        ----------\n        server_type: str, required\n            Specify the server type input either 'all', 'ioc', or 'daq\n        \"\"\"\n        import logging\n        self.error_servers = []\n        if str(server_type) == 'all':\n            logging.info(f\"You've decided to check all {len(self.ioc_serverlist) + len(self.daq_serverlist)} servers.\")\n            for server in self.ioc_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    logging.error(status)\n                    self.error_servers.append(server)\n\n            for server in self.daq_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    logging.error(status)\n                    self.error_servers.append(server)\n\n        elif str(server_type) == 'ioc':\n            logging.info(f\"You've decided to check all {len(self.ioc_serverlist)} ioc servers.\")\n            for server in self.ioc_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    self.error_servers.append(server)\n\n        elif str(server_type) == 'daq':\n            logging.info(f\"You've decided to check all {len(self.daq_serverlist)} daq servers.\")\n            for server in self.daq_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    self.error_servers.append(server)\n        else:\n            logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq or all.\")\n\n        if len(self.error_servers) != 0:\n            logging.warning(f\"There is something wrong with the following servers.\")\n            for server in self.error_servers:\n                print(f'{server}')\n            cycle = input(\"\\nWould you like to power cycle all error servers? (y/n)? \")\n\n            if cycle.lower() == \"y\":\n                logging.info(f\"You've decided to cycle all {len(self.error_servers)} broken servers.\")\n                for server in self.error_servers:\n                    self.cycle_server(str(server))\n            else:\n                logging.info(f\"You've decided not to cycle {len(self.error_servers)} broken servers.\")\n        else:\n            logging.info(f\"All {len(self.error_servers)} servers are ready to rock.\")\n\n        return self.error_servers\n\n\n    def server_list(self, server_type):\n        \"\"\"\n        Lists servers local to MFX\n\n        Parameters\n        ----------\n        server_type: str, required\n            Specify the server type input either 'all', 'ioc', or 'daq\n        \"\"\"\n        import logging\n        if str(server_type) == 'all':\n            print('IOC SERVERS\\n#########################')\n            for server in self.ioc_serverlist:\n                print(f'{server}')\n            print('\\nDAQ SERVERS\\n#########################')\n            for server in self.daq_serverlist:\n                print(f'{server}')\n        elif str(server_type) == 'ioc':\n            print('IOC SERVERS\\n#########################')\n            for server in self.ioc_serverlist:\n                print(f'{server}')\n        elif str(server_type) == 'daq':\n            print('DAQ SERVERS\\n#########################')\n            for server in self.daq_serverlist:\n                print(f'{server}')\n        else:\n            logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq.\")\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug.awr","title":"<code>awr(hutch='mfx')</code>","text":"<p>Checks if the beamline is ready to take beam</p>"},{"location":"beamline.html#mfx.beamline.Debug.awr--parameters","title":"Parameters","text":"<p>hutch: str, optional     Specify the hutch you want to check. Default is MFX because it is the best</p> Source code in <code>mfx/debug.py</code> <pre><code>def awr(self, hutch='mfx'):\n    \"\"\"\n    Checks if the beamline is ready to take beam\n\n    Parameters\n    ----------\n    hutch: str, optional\n        Specify the hutch you want to check. Default is MFX because it is the best\n    \"\"\"\n    import os\n    import logging\n    logging.info(f\"{hutch} Beamline Check\")\n    os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/awr {hutch}\")\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug.check_all_servers","title":"<code>check_all_servers(server_type)</code>","text":"<p>Checks the status of all servers local to MFX</p>"},{"location":"beamline.html#mfx.beamline.Debug.check_all_servers--parameters","title":"Parameters","text":"<p>server_type: str, required     Specify the server type input either 'all', 'ioc', or 'daq</p> Source code in <code>mfx/debug.py</code> <pre><code>def check_all_servers(self, server_type):\n    \"\"\"\n    Checks the status of all servers local to MFX\n\n    Parameters\n    ----------\n    server_type: str, required\n        Specify the server type input either 'all', 'ioc', or 'daq\n    \"\"\"\n    import logging\n    self.error_servers = []\n    if str(server_type) == 'all':\n        logging.info(f\"You've decided to check all {len(self.ioc_serverlist) + len(self.daq_serverlist)} servers.\")\n        for server in self.ioc_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                logging.error(status)\n                self.error_servers.append(server)\n\n        for server in self.daq_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                logging.error(status)\n                self.error_servers.append(server)\n\n    elif str(server_type) == 'ioc':\n        logging.info(f\"You've decided to check all {len(self.ioc_serverlist)} ioc servers.\")\n        for server in self.ioc_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                self.error_servers.append(server)\n\n    elif str(server_type) == 'daq':\n        logging.info(f\"You've decided to check all {len(self.daq_serverlist)} daq servers.\")\n        for server in self.daq_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                self.error_servers.append(server)\n    else:\n        logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq or all.\")\n\n    if len(self.error_servers) != 0:\n        logging.warning(f\"There is something wrong with the following servers.\")\n        for server in self.error_servers:\n            print(f'{server}')\n        cycle = input(\"\\nWould you like to power cycle all error servers? (y/n)? \")\n\n        if cycle.lower() == \"y\":\n            logging.info(f\"You've decided to cycle all {len(self.error_servers)} broken servers.\")\n            for server in self.error_servers:\n                self.cycle_server(str(server))\n        else:\n            logging.info(f\"You've decided not to cycle {len(self.error_servers)} broken servers.\")\n    else:\n        logging.info(f\"All {len(self.error_servers)} servers are ready to rock.\")\n\n    return self.error_servers\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug.check_server","title":"<code>check_server(server)</code>","text":"<p>Checks the status of an individual server</p>"},{"location":"beamline.html#mfx.beamline.Debug.check_server--parameters","title":"Parameters","text":"<p>server: str, required     Specify the server name to check. Use debug.server_list('all') to see all servers</p> Source code in <code>mfx/debug.py</code> <pre><code>def check_server(self, server):\n    \"\"\"\n    Checks the status of an individual server\n\n    Parameters\n    ----------\n    server: str, required\n        Specify the server name to check. Use debug.server_list('all') to see all servers\n    \"\"\"\n    import os\n    import logging\n    status = None\n    if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n        logging.info(f\"Checking the status of: {server}\")\n        status = os.popen(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} status\").read().splitlines()\n    else:\n        logging.info(f\"The server you are looking for does not exist please select one of the following\")\n        self.server_list('ioc')\n        self.server_list('daq')\n    return status\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug.cycle_server","title":"<code>cycle_server(server)</code>","text":"<p>Cycles an individual server</p>"},{"location":"beamline.html#mfx.beamline.Debug.cycle_server--parameters","title":"Parameters","text":"<p>server: str, required     Specify the server name to cycle. Use debug.server_list('all') to see all servers</p> Source code in <code>mfx/debug.py</code> <pre><code>def cycle_server(self, server):\n    \"\"\"\n    Cycles an individual server\n\n    Parameters\n    ----------\n    server: str, required\n        Specify the server name to cycle. Use debug.server_list('all') to see all servers\n    \"\"\"\n    import os\n    import logging\n    if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n        logging.info(f\"Power cycling: {server}\")\n        os.system(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} cycle\")\n    else:\n        logging.info(f\"The server you are looking for does not exist please select one of the following\")\n        self.server_list('ioc')\n        self.server_list('daq')\n</code></pre>"},{"location":"beamline.html#mfx.beamline.Debug.server_list","title":"<code>server_list(server_type)</code>","text":"<p>Lists servers local to MFX</p>"},{"location":"beamline.html#mfx.beamline.Debug.server_list--parameters","title":"Parameters","text":"<p>server_type: str, required     Specify the server type input either 'all', 'ioc', or 'daq</p> Source code in <code>mfx/debug.py</code> <pre><code>def server_list(self, server_type):\n    \"\"\"\n    Lists servers local to MFX\n\n    Parameters\n    ----------\n    server_type: str, required\n        Specify the server type input either 'all', 'ioc', or 'daq\n    \"\"\"\n    import logging\n    if str(server_type) == 'all':\n        print('IOC SERVERS\\n#########################')\n        for server in self.ioc_serverlist:\n            print(f'{server}')\n        print('\\nDAQ SERVERS\\n#########################')\n        for server in self.daq_serverlist:\n            print(f'{server}')\n    elif str(server_type) == 'ioc':\n        print('IOC SERVERS\\n#########################')\n        for server in self.ioc_serverlist:\n            print(f'{server}')\n    elif str(server_type) == 'daq':\n        print('DAQ SERVERS\\n#########################')\n        for server in self.daq_serverlist:\n            print(f'{server}')\n    else:\n        logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq.\")\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD","title":"<code>DoD</code>","text":"Source code in <code>dod/dod.py</code> <pre><code>class DoD: \n    def __init__(self, modules = 'None', ip = \"172.21.72.187\", port = 9999, supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n):\n        \"\"\"\n        Class definition of the DoD robot\n        Parameters\n        ----------\n        modules : string\n            Defines the optional modules of the robot. \n            Options: 'None', 'codi', , \n        ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"            \n        \"\"\"\n        from dod.DropsDriver import myClient\n        from dod.JsonFileHandler import JsonFileHandler\n        from dod.ServerResponse import ServerResponse\n\n        import time\n\n        # Create object \n        # pytest encourages this pattern, apologies.\n        # ip = \"172.21.72.187\" #\"172.21.148.101\"\n        # port = 9999\n        # supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n\n        # User input parameters: \n        # Safety parameters in hutch coordinate system. \n        # Note: hutch (x,y,z) = robot (x,-z, y) \n        # \n        self.y_min     = 10000 # minimum value in y.\n        self.y_safety  = 50000 # value in y, above which the robot can only be in vertical configuration\n        self.y_max     = 50000 # maximum value in y\n\n        #Initialize safety regions for horizontal and vertical rotation: \n        self.forbidden_regions_horizontal = []\n        self.forbidden_regions_vertical = []\n        #minimum region: \n        self.set_forbidden_region(0, 300000, 0, self.y_min,rotation_state='both')\n        #maximum region: \n        self.set_forbidden_region(0, 300000, self.y_max, 500000,rotation_state='both')\n        #region where horizontal rotation is forbidden: \n        self.set_forbidden_region(0, 300000,  self.y_safety, self.y_max,rotation_state='horizontal')\n\n        # Initializing the robot client that is used for communication\n        self.client = myClient(ip=ip, port=port, supported_json=supported_json, reload=False)\n\n        # create config parser handler\n        json_handler = JsonFileHandler(supported_json)\n        # load configs and launch web server\n        json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n        if modules == 'codi': \n            from dod.codi import CoDI\n            self.codi = CoDI()\n\n        # Timing section\n        from pcdsdevices.evr import Trigger\n        self.delay = None\n\n        # Trigger objects\n        self.trigger_Xray = Trigger('MFX:LAS:EVR:01:TRIG7', name='trigger_X-ray_simulator')\n        self.trigger_nozzle_1 = Trigger('MFX:LAS:EVR:01:TRIG2', name='trigger_nozzle_1')\n        self.trigger_nozzle_2 = Trigger('MFX:LAS:EVR:01:TRIG3', name='trigger_nozzle_2')\n        self.trigger_LED = Trigger('MFX:LAS:EVR:01:TRIG1', name='trigger_LED_array')\n\n        # Timing parameter\n        self.timing_Xray = self.trigger_Xray.ns_delay.get()\n        self.timing_nozzle_1 = self.trigger_nozzle_1.ns_delay.get()\n        self.timing_nozzle_2 = self.trigger_nozzle_2.ns_delay.get()\n        self.timing_LED = self.trigger_LED.ns_delay.get()\n        self.timing_delay_sciPulse = 60600\n        self.timing_delay_LED = 1000 #delay of LED relative to X-ray timing\n        self.timing_delay_reaction = 0\n        self.timing_delay_nozzle_1 = self.timing_Xray - self.timing_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        self.timing_delay_nozzle_2 = self.timing_Xray - self.timing_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n\n\n    def stop_task(self, verbose = True):\n        \"\"\"\n        Stop task while running\n        ** ISSUES **\n        -  When stop task  is called, the Robot stays in \"BUSY\" Status.\n        Parameters\n        ----------\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        Returns: \n        r : \n            status readback when aborted\n        \"\"\"\n        r = self.client.connect(\"Test\")\n        self.safety_abort = False\n        r = self.client.stop_task()\n        r = self.client.disconnect()\n        if verbose == True: \n            return r\n\n\n    def clear_abort(self, verbose = True):\n        \"\"\"\n        clear abort flag\n        Parameters\n        verbose : boolean\n           Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            status readback after error cleared\n        '''\n        \"\"\"\n        r = self.client.connect(\"Test\")\n        r = self.client.get_status()\n        self.safety_abort = False\n        rr = self.client.disconnect()\n\n        if verbose == True: \n            return r\n\n\n    # def clear_popup_window(self, verbose = True):\n    #     \"\"\"\n    #     clears a popup window that might pop up on the robot gui\n    #     Parameters\n    #     verbose : boolean\n    #        Defines whether the function returns the full output, or only the results\n    #     ----------\n    #     Returns: \n    #     r : \n    #         status readback after error cleared\n    #     '''\n    #     \"\"\"\n    #     r = self.client.connect(\"Test\")\n    #     r = self.client.get_status()\n\n    #     self.client.close_dialog(reference, selection)\n\n    #     if verbose == True: \n    #         return r\n\n\n    def get_status(self, verbose = False):\n        \"\"\"\n        returns the robot state\n\n        Parameters\n        verbose : boolean\n           Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : dict\n            different states of the robot\n        \"\"\"\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_status()\n        # expected_keys = [\n        #     'Position',\n        #     'RunningTask',\n        #     'Dialog',\n        #     'LastProbe',\n        #     'Humidity',\n        #     'Temperature',\n        #     'BathTemp',\n        #     ]\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def busy_wait(self, timeout):\n        '''\n            Busy wait untill timeout value is reached,\n            timeout : sec\n            returns true if timeout occured\n        '''\n        import time\n        start = time.time()\n        r = self.client.get_status()\n        delta = 0\n\n        while(r.STATUS['Status'] == \"Busy\"):\n            if delta &gt; timeout:\n                return True\n\n            time.sleep(0.1) #Wait a ms to stop spamming robot\n            r = self.client.get_status()\n            delta = time.time() - start    \n        return False\n\n\n    # def __del__(self):\n    #     # close network connection\n    #     self.client.conn.close()\n\n\n    def get_task_details(self, task_name, verbose = False):\n        \"\"\"\n            This gets the details of a task from the robot to see the scripted routines\n            Parameters\n            task_name : string\n                Name of the task that we want to get\n            verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n            Returns: \n            r : \n                returns the robot tasks\n        \"\"\"\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_task_details(task_name)\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_task_names(self, verbose = False):\n        \"\"\"\n            This gets the names of available tasks from the robot\n            Parameters\n            task_name : string\n                Name of the task that we want to get\n            verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n            Returns: \n            r : dict\n                returns the robot tasks\n        \"\"\"\n        # Check if reponse is not an empty array or any errors occured\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_task_names()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_current_position(self, verbose = False):\n        '''\n        Returns current robot position\n        name and properties of the last selected position, together with the real current position coordinates\n        Parameters\n\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : \n            returns the current position.         \n        # expected_keys = [\n        #         'CurrentPosition',\n        #         'Position',\n        #         'PositionReal',\n        #         ]\n        '''\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_nozzle_status(self, verbose = False):\n        '''\n        Returns current nozzle parameters position\n        Parameters\n\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            returns the current nozzle parameters.         \n        #         expected_keys = [\n                \"Activated Nozzles\",\n                \"Selected Nozzles\",\n                \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n                \"Dispensing\",\n                ]\n        '''\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_nozzle_status()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def set_nozzle_dispensing(self, mode = \"Off\", verbose = False):\n        '''\n        Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\"\n        Parameters\n        mode : string \n            either \"free\", \"triggered\", or \"off\"\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n        '''\n        rr = self.client.connect(\"Test\")\n        if mode == 'Free': \n            r = self.client.dispensing('Free')\n        elif mode == 'Triggered':\n            r = self.client.dispensing('Triggered')\n        else: \n            #turns active nozzles off. Safer if all nozzles would be turned off\n            r = self.client.dispensing('Off')\n            for i in [1,2,3,4]: \n                r = self.client.select_nozzle(i)\n                r = self.client.dispensing('Off')\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def do_move(self, position, safety_test = False, verbose = False):\n        '''\n            Moves robot to new position\n\n        Parameters\n        position : string\n            Position name to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n\n        if safety_test == False:  \n            r = self.client.move(position)\n        else: \n            print('safety test of move has yet to be implemented')\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(15)\n\n        r = self.client.get_current_positions()\n        new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_x_abs(self, position_x, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute x position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_x(position_x)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(position_x, y_current): \n                r = self.client.move_x(position_x)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_y_abs(self, position_y, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute x position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_y(position_y)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(x_current, position_y): \n                r = self.client.move_y(position_y)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_z_abs(self, position_z, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute Z position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_z(position_z)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(x_current, y_current): \n                r = self.client.move_z(position_z)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def do_task(self, task_name, safety_check = False, verbose = False):\n        '''\n        Executes a task of the robot\n\n        Parameters\n        task_name : string\n            task name which robot is supposed to perform\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : \n        '''\n        import time\n\n        rr = self.client.connect(\"Test\")\n        if safety_check == False: \n            r = self.client.execute_task(task_name)\n        else: \n            print('safety check needs to be implemented')\n\n        ## Wait for task to be done\n        while(r.STATUS['Status'] == \"Busy\"):\n            #Possible if loop is not enterd?\n            time.sleep(0.5)\n            r = self.client.get_status()\n            if self.safety_abort == True: \n                r = self.client.stop_task()\n                print('User aborted task execution')\n                return r\n\n        r = self.client.get_status()\n\n        #Check if any error occured\n        if r.ERROR_CODE == 0:\n            print('no error')\n        else: \n            print('error while performing task!')\n\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_forbidden_region(self, rotation_state = 'both'): \n        \"\"\"\n        returns forbidden regions in the robot coordinate x y plane for end-point testing \n        defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n        returns the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n        Parameters\n        rotation_state: string\n            options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n        ----------\n\n        \"\"\"\n\n        #combine the lists depending on the rotation \n        if rotation_state == \"vertical\": \n            test_list_safety = self.forbidden_regions_vertical\n        elif rotation_state == \"horizontal\": \n            test_list_safety = self.forbidden_regions_horizontal\n        else:\n            test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n        return test_list_safety\n\n\n    def set_forbidden_region(self, x_start, x_stop, y_start, y_stop, rotation_state = 'both'): \n        \"\"\"\n        set a forbidden region in the robot coordinate x y plane for end-point testing \n        defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n        set the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n        Parameters\n        x_start : float\n            x-position start \n        x_stop : float\n            x-position stop\n        y_start : float\n            y-position start \n        y_stop : float\n            y-position stop\n        rotation_state: string\n            options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n        ----------\n\n        \"\"\"\n        region_tuple = (min(x_start,x_stop), max(x_start,x_stop), min(y_start,y_stop), max(y_start,y_stop))\n        if rotation_state == \"horizontal\": \n            self.forbidden_regions_horizontal.append(region_tuple)\n        elif rotation_state == \"vertical\": \n            self.forbidden_regions_vertical.append(region_tuple)\n        elif rotation_state == \"both\": \n            self.forbidden_regions_vertical.append(region_tuple)\n            self.forbidden_regions_horizontal.append(region_tuple)\n        else:\n            print('invalid input of rotation state')\n\n\n    def test_forbidden_region(self, x_test, y_test): \n        \"\"\"\n        tests if the end point of a motion is inside a forbidden region\n        No testing of the path of a motion included!\n\n        Parameters\n        x_test : float\n            x-position to test \n        y_test : float \n            y-position to test \n\n        ----------\n        Returns: \n        safe_motion : bool\n            boolean flag if endpoint of motion is safe or not\n        \"\"\"\n        from dod.codi import CoDI_base\n        # Get current rotation state\n        pos_rot_base  = round(CoDI_base.wm(),0)\n\n        #Initialize safe flag (True = safe)\n        flag_safe_endpoint = True\n\n        #combine the lists depending on the rotation \n        if pos_rot_base == 90: \n            test_list_safety = self.forbidden_regions_vertical\n        elif pos_rot_base == 0:\n            test_list_safety = self.forbidden_regions_horizontal\n        else:\n            test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n        #Test for all regions if the end point is in the forbidden region\n        for tuple_current in test_list_safety: \n            x_start, x_stop, y_start, y_stop = tuple_current\n            if ((x_start &lt; x_test) and (x_stop &gt; x_test) and (y_start &lt; y_test) and (y_stop &gt; y_test)): \n                flag_safe_endpoint = flag_safe_endpoint and False\n            else:\n                flag_safe_endpoint = flag_safe_endpoint and True\n\n        return flag_safe_endpoint\n\n\n    def set_timing_update(self): \n        \"\"\"\n        updating the timing triggers according to the set relative and absolute timing values\n\n        Parameters\n               ----------\n        Returns: \n        \"\"\"\n        # Nozzle 1\n        self.timing_nozzle_1 = self.timing_Xray - self.timing_delay_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        if self.timing_nozzle_1 &lt; 0: \n            self.timing_nozzle_1 = self.timing_nozzle_1 + 1/120*1000000000\n        self.trigger_nozzle_1.ns_delay.put(self.timing_nozzle_1)\n\n        # Nozzle 2\n        self.timing_nozzle_2 = self.timing_Xray - self.timing_delay_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        if self.timing_nozzle_2 &lt; 0: \n            self.timing_nozzle_2 = self.timing_nozzle_2 + 1/120*1000000000\n        self.trigger_nozzle_2.ns_delay.put(self.timing_nozzle_2)\n\n        # LED\n        self.timing_LED = self.timing_Xray + self.timing_delay_LED\n        self.trigger_LED.ns_delay.put(self.timing_LED)\n\n\n    def set_timing_zero_nozzle(self, nozzle, timing_rel): \n        \"\"\"\n        Setting the time zero for the nozzles from the LED alignment in robot\n\n        Parameters\n        nozle : int\n            nozzle number\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        if nozzle == 1: \n            self.timing_delay_nozzle_1 = timing_rel\n        elif nozzle == 2: \n            self.timing_delay_nozzle_2 = timing_rel\n        else: \n            print('no valid nozzle selected.')\n            return\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_rel_LED(self, timing_rel): \n        \"\"\"\n        Setting the relative timing of the LED relative to the X-rays\n\n        Parameters\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_delay_LED = timing_rel #delay of LED relative to X-ray timing\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_rel_reaction(self, timing_rel): \n        \"\"\"\n        Setting the relative timing of the reaction relative to the X-rays\n\n        Parameters\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_delay_reaction = timing_rel #delay of LED relative to X-ray timing\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_abs_Xray(self, timing_abs): \n        \"\"\"\n        Setting the absolute timing of the X-rays for claculation purposes\n\n        Parameters\n        timing_abs : float\n            abs timing in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_Xray = timing_abs #delay of LED relative to X-ray timing\n        #self.trigger_Xray.ns_delay.put(self.timing_Xray)\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_relative_nozzle(self, nozzle, timing_rel): \n        \"\"\"\n        Changing the timing of the selected nozzle by a relative amount \n\n        Parameters\n        nozle : int\n            nozzle number\n        timing_rel : float\n            relative change in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        if nozzle == 1: \n            current_timing = self.timing_delay_nozzle_1\n            self.timing_delay_nozzle_1 = self.timing_delay_nozzle_1 + timing_rel\n        elif nozzle == 2: \n            current_timing = self.timing_delay_nozzle_2\n            self.timing_delay_nozzle_2 = self.timing_delay_nozzle_2 + timing_rel\n        else: \n            print('no valid nozzle selected.')\n            return\n\n        # update timings\n        self.set_timing_update()\n\n\n    def logging_string(self):\n        \"\"\"\n        Creating the string to post to the e-log. \n\n        Parameters\n        ----------\n        Returns: \n        post : string\n            String with useful logging information for posting into the e-log \n        \"\"\"\n        post_str = ''\n\n        # Info to be posted: \n\n        # Nozzle angles: \n        position = self.codi.get_CoDI_pos()\n        position_str = 'Codi Information: \\n CoDI data: name: ' + str(position[0]) + '\\n rot_base: '+ str(position[1])+ '\\n rot_left: '+ str(position[2]) + '\\n rot_right: '+ str(position[3])+ '\\n z-transl: '+ str(position[4]) \n        post_str = post_str + position_str +' \\n '\n\n        #Timings:\n        post_str = post_str + 'Timing:' + ' \\n '\n        post_str = post_str + 'timing_Xray:' + str(self.timing_Xray) +' \\n '\n        post_str = post_str + 'timing_nozzle_1:' + str(self.timing_nozzle_1) +' \\n '\n        post_str = post_str + 'timing_nozzle_2:' + str(self.timing_nozzle_2) +' \\n '\n        post_str = post_str + 'timing_LED:' + str(self.timing_LED) +' \\n '\n        post_str = post_str + 'timing_delay_LED:' + str(self.timing_delay_LED) +' \\n '\n        post_str = post_str + 'timing_delay_reaction:' + str(self.timing_delay_reaction) +' \\n '        \n        post_str = post_str + 'timing_delay_nozzle_1:' + str(self.timing_delay_nozzle_1) +' \\n '   \n        post_str = post_str + 'timing_delay_nozzle_2:' + str(self.timing_delay_nozzle_2) +' \\n '   \n\n        return post_str\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.__init__","title":"<code>__init__(modules='None', ip='172.21.72.187', port=9999, supported_json='/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json')</code>","text":"<p>Class definition of the DoD robot Parameters</p> <p>modules : string     Defines the optional modules of the robot.      Options: 'None', 'codi', ,  ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"</p> Source code in <code>dod/dod.py</code> <pre><code>    def __init__(self, modules = 'None', ip = \"172.21.72.187\", port = 9999, supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n):\n        \"\"\"\n        Class definition of the DoD robot\n        Parameters\n        ----------\n        modules : string\n            Defines the optional modules of the robot. \n            Options: 'None', 'codi', , \n        ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"            \n        \"\"\"\n        from dod.DropsDriver import myClient\n        from dod.JsonFileHandler import JsonFileHandler\n        from dod.ServerResponse import ServerResponse\n\n        import time\n\n        # Create object \n        # pytest encourages this pattern, apologies.\n        # ip = \"172.21.72.187\" #\"172.21.148.101\"\n        # port = 9999\n        # supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n\n        # User input parameters: \n        # Safety parameters in hutch coordinate system. \n        # Note: hutch (x,y,z) = robot (x,-z, y) \n        # \n        self.y_min     = 10000 # minimum value in y.\n        self.y_safety  = 50000 # value in y, above which the robot can only be in vertical configuration\n        self.y_max     = 50000 # maximum value in y\n\n        #Initialize safety regions for horizontal and vertical rotation: \n        self.forbidden_regions_horizontal = []\n        self.forbidden_regions_vertical = []\n        #minimum region: \n        self.set_forbidden_region(0, 300000, 0, self.y_min,rotation_state='both')\n        #maximum region: \n        self.set_forbidden_region(0, 300000, self.y_max, 500000,rotation_state='both')\n        #region where horizontal rotation is forbidden: \n        self.set_forbidden_region(0, 300000,  self.y_safety, self.y_max,rotation_state='horizontal')\n\n        # Initializing the robot client that is used for communication\n        self.client = myClient(ip=ip, port=port, supported_json=supported_json, reload=False)\n\n        # create config parser handler\n        json_handler = JsonFileHandler(supported_json)\n        # load configs and launch web server\n        json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n        if modules == 'codi': \n            from dod.codi import CoDI\n            self.codi = CoDI()\n\n        # Timing section\n        from pcdsdevices.evr import Trigger\n        self.delay = None\n\n        # Trigger objects\n        self.trigger_Xray = Trigger('MFX:LAS:EVR:01:TRIG7', name='trigger_X-ray_simulator')\n        self.trigger_nozzle_1 = Trigger('MFX:LAS:EVR:01:TRIG2', name='trigger_nozzle_1')\n        self.trigger_nozzle_2 = Trigger('MFX:LAS:EVR:01:TRIG3', name='trigger_nozzle_2')\n        self.trigger_LED = Trigger('MFX:LAS:EVR:01:TRIG1', name='trigger_LED_array')\n\n        # Timing parameter\n        self.timing_Xray = self.trigger_Xray.ns_delay.get()\n        self.timing_nozzle_1 = self.trigger_nozzle_1.ns_delay.get()\n        self.timing_nozzle_2 = self.trigger_nozzle_2.ns_delay.get()\n        self.timing_LED = self.trigger_LED.ns_delay.get()\n        self.timing_delay_sciPulse = 60600\n        self.timing_delay_LED = 1000 #delay of LED relative to X-ray timing\n        self.timing_delay_reaction = 0\n        self.timing_delay_nozzle_1 = self.timing_Xray - self.timing_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        self.timing_delay_nozzle_2 = self.timing_Xray - self.timing_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.busy_wait","title":"<code>busy_wait(timeout)</code>","text":"<p>Busy wait untill timeout value is reached, timeout : sec returns true if timeout occured</p> Source code in <code>dod/dod.py</code> <pre><code>def busy_wait(self, timeout):\n    '''\n        Busy wait untill timeout value is reached,\n        timeout : sec\n        returns true if timeout occured\n    '''\n    import time\n    start = time.time()\n    r = self.client.get_status()\n    delta = 0\n\n    while(r.STATUS['Status'] == \"Busy\"):\n        if delta &gt; timeout:\n            return True\n\n        time.sleep(0.1) #Wait a ms to stop spamming robot\n        r = self.client.get_status()\n        delta = time.time() - start    \n    return False\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.clear_abort","title":"<code>clear_abort(verbose=True)</code>","text":"<p>clear abort flag Parameters verbose : boolean    Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      status readback after error cleared '''</p> Source code in <code>dod/dod.py</code> <pre><code>def clear_abort(self, verbose = True):\n    \"\"\"\n    clear abort flag\n    Parameters\n    verbose : boolean\n       Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n        status readback after error cleared\n    '''\n    \"\"\"\n    r = self.client.connect(\"Test\")\n    r = self.client.get_status()\n    self.safety_abort = False\n    rr = self.client.disconnect()\n\n    if verbose == True: \n        return r\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.do_move","title":"<code>do_move(position, safety_test=False, verbose=False)</code>","text":"<pre><code>Moves robot to new position\n</code></pre> <p>Parameters position : string     Position name to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def do_move(self, position, safety_test = False, verbose = False):\n    '''\n        Moves robot to new position\n\n    Parameters\n    position : string\n        Position name to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n\n    if safety_test == False:  \n        r = self.client.move(position)\n    else: \n        print('safety test of move has yet to be implemented')\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(15)\n\n    r = self.client.get_current_positions()\n    new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.do_task","title":"<code>do_task(task_name, safety_check=False, verbose=False)</code>","text":"<p>Executes a task of the robot</p> <p>Parameters task_name : string     task name which robot is supposed to perform safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r :</p> Source code in <code>dod/dod.py</code> <pre><code>def do_task(self, task_name, safety_check = False, verbose = False):\n    '''\n    Executes a task of the robot\n\n    Parameters\n    task_name : string\n        task name which robot is supposed to perform\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : \n    '''\n    import time\n\n    rr = self.client.connect(\"Test\")\n    if safety_check == False: \n        r = self.client.execute_task(task_name)\n    else: \n        print('safety check needs to be implemented')\n\n    ## Wait for task to be done\n    while(r.STATUS['Status'] == \"Busy\"):\n        #Possible if loop is not enterd?\n        time.sleep(0.5)\n        r = self.client.get_status()\n        if self.safety_abort == True: \n            r = self.client.stop_task()\n            print('User aborted task execution')\n            return r\n\n    r = self.client.get_status()\n\n    #Check if any error occured\n    if r.ERROR_CODE == 0:\n        print('no error')\n    else: \n        print('error while performing task!')\n\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_current_position","title":"<code>get_current_position(verbose=False)</code>","text":"<p>Returns current robot position name and properties of the last selected position, together with the real current position coordinates Parameters</p> boolean <p>Defines whether the function returns the full output, or only the results</p> <pre><code>----------\n</code></pre> <p>Returns:  r :      returns the current position.         </p>"},{"location":"beamline.html#mfx.beamline.DoD.get_current_position--expected_keys","title":"expected_keys = [","text":""},{"location":"beamline.html#mfx.beamline.DoD.get_current_position--currentposition","title":"'CurrentPosition',","text":""},{"location":"beamline.html#mfx.beamline.DoD.get_current_position--position","title":"'Position',","text":""},{"location":"beamline.html#mfx.beamline.DoD.get_current_position--positionreal","title":"'PositionReal',","text":""},{"location":"beamline.html#mfx.beamline.DoD.get_current_position--_1","title":"]","text":"Source code in <code>dod/dod.py</code> <pre><code>def get_current_position(self, verbose = False):\n    '''\n    Returns current robot position\n    name and properties of the last selected position, together with the real current position coordinates\n    Parameters\n\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : \n        returns the current position.         \n    # expected_keys = [\n    #         'CurrentPosition',\n    #         'Position',\n    #         'PositionReal',\n    #         ]\n    '''\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_forbidden_region","title":"<code>get_forbidden_region(rotation_state='both')</code>","text":"<p>returns forbidden regions in the robot coordinate x y plane for end-point testing  defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop returns the region depending on the rotation state, as some regions are forbidden only in one configuration</p> <p>Parameters rotation_state: string     options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"</p> Source code in <code>dod/dod.py</code> <pre><code>def get_forbidden_region(self, rotation_state = 'both'): \n    \"\"\"\n    returns forbidden regions in the robot coordinate x y plane for end-point testing \n    defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n    returns the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n    Parameters\n    rotation_state: string\n        options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n    ----------\n\n    \"\"\"\n\n    #combine the lists depending on the rotation \n    if rotation_state == \"vertical\": \n        test_list_safety = self.forbidden_regions_vertical\n    elif rotation_state == \"horizontal\": \n        test_list_safety = self.forbidden_regions_horizontal\n    else:\n        test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n    return test_list_safety\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_nozzle_status","title":"<code>get_nozzle_status(verbose=False)</code>","text":"<p>Returns current nozzle parameters position Parameters</p> boolean <p>Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      returns the current nozzle parameters.         </p>"},{"location":"beamline.html#mfx.beamline.DoD.get_nozzle_status--expected_keys","title":"expected_keys = [","text":"<pre><code>    \"Activated Nozzles\",\n    \"Selected Nozzles\",\n    \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n    \"Dispensing\",\n    ]\n</code></pre> Source code in <code>dod/dod.py</code> <pre><code>def get_nozzle_status(self, verbose = False):\n    '''\n    Returns current nozzle parameters position\n    Parameters\n\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n        returns the current nozzle parameters.         \n    #         expected_keys = [\n            \"Activated Nozzles\",\n            \"Selected Nozzles\",\n            \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n            \"Dispensing\",\n            ]\n    '''\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_nozzle_status()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_status","title":"<code>get_status(verbose=False)</code>","text":"<p>returns the robot state</p> <p>Parameters verbose : boolean    Defines whether the function returns the full output, or only the results</p> <p>Returns:  r : dict     different states of the robot</p> Source code in <code>dod/dod.py</code> <pre><code>def get_status(self, verbose = False):\n    \"\"\"\n    returns the robot state\n\n    Parameters\n    verbose : boolean\n       Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : dict\n        different states of the robot\n    \"\"\"\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_status()\n    # expected_keys = [\n    #     'Position',\n    #     'RunningTask',\n    #     'Dialog',\n    #     'LastProbe',\n    #     'Humidity',\n    #     'Temperature',\n    #     'BathTemp',\n    #     ]\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_task_details","title":"<code>get_task_details(task_name, verbose=False)</code>","text":"<p>This gets the details of a task from the robot to see the scripted routines Parameters task_name : string     Name of the task that we want to get verbose : boolean     Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      returns the robot tasks</p> Source code in <code>dod/dod.py</code> <pre><code>def get_task_details(self, task_name, verbose = False):\n    \"\"\"\n        This gets the details of a task from the robot to see the scripted routines\n        Parameters\n        task_name : string\n            Name of the task that we want to get\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            returns the robot tasks\n    \"\"\"\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_task_details(task_name)\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.get_task_names","title":"<code>get_task_names(verbose=False)</code>","text":"<p>This gets the names of available tasks from the robot Parameters task_name : string     Name of the task that we want to get verbose : boolean     Defines whether the function returns the full output, or only the results</p> <p>Returns:  r : dict     returns the robot tasks</p> Source code in <code>dod/dod.py</code> <pre><code>def get_task_names(self, verbose = False):\n    \"\"\"\n        This gets the names of available tasks from the robot\n        Parameters\n        task_name : string\n            Name of the task that we want to get\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : dict\n            returns the robot tasks\n    \"\"\"\n    # Check if reponse is not an empty array or any errors occured\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_task_names()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.logging_string","title":"<code>logging_string()</code>","text":"<p>Creating the string to post to the e-log. </p>"},{"location":"beamline.html#mfx.beamline.DoD.logging_string--parameters","title":"Parameters","text":"<p>Returns:  post : string     String with useful logging information for posting into the e-log</p> Source code in <code>dod/dod.py</code> <pre><code>def logging_string(self):\n    \"\"\"\n    Creating the string to post to the e-log. \n\n    Parameters\n    ----------\n    Returns: \n    post : string\n        String with useful logging information for posting into the e-log \n    \"\"\"\n    post_str = ''\n\n    # Info to be posted: \n\n    # Nozzle angles: \n    position = self.codi.get_CoDI_pos()\n    position_str = 'Codi Information: \\n CoDI data: name: ' + str(position[0]) + '\\n rot_base: '+ str(position[1])+ '\\n rot_left: '+ str(position[2]) + '\\n rot_right: '+ str(position[3])+ '\\n z-transl: '+ str(position[4]) \n    post_str = post_str + position_str +' \\n '\n\n    #Timings:\n    post_str = post_str + 'Timing:' + ' \\n '\n    post_str = post_str + 'timing_Xray:' + str(self.timing_Xray) +' \\n '\n    post_str = post_str + 'timing_nozzle_1:' + str(self.timing_nozzle_1) +' \\n '\n    post_str = post_str + 'timing_nozzle_2:' + str(self.timing_nozzle_2) +' \\n '\n    post_str = post_str + 'timing_LED:' + str(self.timing_LED) +' \\n '\n    post_str = post_str + 'timing_delay_LED:' + str(self.timing_delay_LED) +' \\n '\n    post_str = post_str + 'timing_delay_reaction:' + str(self.timing_delay_reaction) +' \\n '        \n    post_str = post_str + 'timing_delay_nozzle_1:' + str(self.timing_delay_nozzle_1) +' \\n '   \n    post_str = post_str + 'timing_delay_nozzle_2:' + str(self.timing_delay_nozzle_2) +' \\n '   \n\n    return post_str\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.move_x_abs","title":"<code>move_x_abs(position_x, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute x position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_x_abs(self, position_x, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute x position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_x(position_x)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(position_x, y_current): \n            r = self.client.move_x(position_x)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.move_y_abs","title":"<code>move_y_abs(position_y, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute x position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_y_abs(self, position_y, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute x position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_y(position_y)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(x_current, position_y): \n            r = self.client.move_y(position_y)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.move_z_abs","title":"<code>move_z_abs(position_z, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute Z position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_z_abs(self, position_z, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute Z position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_z(position_z)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(x_current, y_current): \n            r = self.client.move_z(position_z)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_forbidden_region","title":"<code>set_forbidden_region(x_start, x_stop, y_start, y_stop, rotation_state='both')</code>","text":"<p>set a forbidden region in the robot coordinate x y plane for end-point testing  defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop set the region depending on the rotation state, as some regions are forbidden only in one configuration</p> <p>Parameters x_start : float     x-position start  x_stop : float     x-position stop y_start : float     y-position start  y_stop : float     y-position stop rotation_state: string     options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"</p> Source code in <code>dod/dod.py</code> <pre><code>def set_forbidden_region(self, x_start, x_stop, y_start, y_stop, rotation_state = 'both'): \n    \"\"\"\n    set a forbidden region in the robot coordinate x y plane for end-point testing \n    defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n    set the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n    Parameters\n    x_start : float\n        x-position start \n    x_stop : float\n        x-position stop\n    y_start : float\n        y-position start \n    y_stop : float\n        y-position stop\n    rotation_state: string\n        options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n    ----------\n\n    \"\"\"\n    region_tuple = (min(x_start,x_stop), max(x_start,x_stop), min(y_start,y_stop), max(y_start,y_stop))\n    if rotation_state == \"horizontal\": \n        self.forbidden_regions_horizontal.append(region_tuple)\n    elif rotation_state == \"vertical\": \n        self.forbidden_regions_vertical.append(region_tuple)\n    elif rotation_state == \"both\": \n        self.forbidden_regions_vertical.append(region_tuple)\n        self.forbidden_regions_horizontal.append(region_tuple)\n    else:\n        print('invalid input of rotation state')\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_nozzle_dispensing","title":"<code>set_nozzle_dispensing(mode='Off', verbose=False)</code>","text":"<p>Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\" Parameters mode : string      either \"free\", \"triggered\", or \"off\" verbose : boolean         Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :</p> Source code in <code>dod/dod.py</code> <pre><code>def set_nozzle_dispensing(self, mode = \"Off\", verbose = False):\n    '''\n    Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\"\n    Parameters\n    mode : string \n        either \"free\", \"triggered\", or \"off\"\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n    '''\n    rr = self.client.connect(\"Test\")\n    if mode == 'Free': \n        r = self.client.dispensing('Free')\n    elif mode == 'Triggered':\n        r = self.client.dispensing('Triggered')\n    else: \n        #turns active nozzles off. Safer if all nozzles would be turned off\n        r = self.client.dispensing('Off')\n        for i in [1,2,3,4]: \n            r = self.client.select_nozzle(i)\n            r = self.client.dispensing('Off')\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_abs_Xray","title":"<code>set_timing_abs_Xray(timing_abs)</code>","text":"<p>Setting the absolute timing of the X-rays for claculation purposes</p> <p>Parameters timing_abs : float     abs timing in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_abs_Xray(self, timing_abs): \n    \"\"\"\n    Setting the absolute timing of the X-rays for claculation purposes\n\n    Parameters\n    timing_abs : float\n        abs timing in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_Xray = timing_abs #delay of LED relative to X-ray timing\n    #self.trigger_Xray.ns_delay.put(self.timing_Xray)\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_rel_LED","title":"<code>set_timing_rel_LED(timing_rel)</code>","text":"<p>Setting the relative timing of the LED relative to the X-rays</p> <p>Parameters timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_rel_LED(self, timing_rel): \n    \"\"\"\n    Setting the relative timing of the LED relative to the X-rays\n\n    Parameters\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_delay_LED = timing_rel #delay of LED relative to X-ray timing\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_rel_reaction","title":"<code>set_timing_rel_reaction(timing_rel)</code>","text":"<p>Setting the relative timing of the reaction relative to the X-rays</p> <p>Parameters timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_rel_reaction(self, timing_rel): \n    \"\"\"\n    Setting the relative timing of the reaction relative to the X-rays\n\n    Parameters\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_delay_reaction = timing_rel #delay of LED relative to X-ray timing\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_relative_nozzle","title":"<code>set_timing_relative_nozzle(nozzle, timing_rel)</code>","text":"<p>Changing the timing of the selected nozzle by a relative amount </p> <p>Parameters nozle : int     nozzle number timing_rel : float     relative change in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_relative_nozzle(self, nozzle, timing_rel): \n    \"\"\"\n    Changing the timing of the selected nozzle by a relative amount \n\n    Parameters\n    nozle : int\n        nozzle number\n    timing_rel : float\n        relative change in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    if nozzle == 1: \n        current_timing = self.timing_delay_nozzle_1\n        self.timing_delay_nozzle_1 = self.timing_delay_nozzle_1 + timing_rel\n    elif nozzle == 2: \n        current_timing = self.timing_delay_nozzle_2\n        self.timing_delay_nozzle_2 = self.timing_delay_nozzle_2 + timing_rel\n    else: \n        print('no valid nozzle selected.')\n        return\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_update","title":"<code>set_timing_update()</code>","text":"<p>updating the timing triggers according to the set relative and absolute timing values</p> <p>Parameters        ---------- Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_update(self): \n    \"\"\"\n    updating the timing triggers according to the set relative and absolute timing values\n\n    Parameters\n           ----------\n    Returns: \n    \"\"\"\n    # Nozzle 1\n    self.timing_nozzle_1 = self.timing_Xray - self.timing_delay_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n    if self.timing_nozzle_1 &lt; 0: \n        self.timing_nozzle_1 = self.timing_nozzle_1 + 1/120*1000000000\n    self.trigger_nozzle_1.ns_delay.put(self.timing_nozzle_1)\n\n    # Nozzle 2\n    self.timing_nozzle_2 = self.timing_Xray - self.timing_delay_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n    if self.timing_nozzle_2 &lt; 0: \n        self.timing_nozzle_2 = self.timing_nozzle_2 + 1/120*1000000000\n    self.trigger_nozzle_2.ns_delay.put(self.timing_nozzle_2)\n\n    # LED\n    self.timing_LED = self.timing_Xray + self.timing_delay_LED\n    self.trigger_LED.ns_delay.put(self.timing_LED)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.set_timing_zero_nozzle","title":"<code>set_timing_zero_nozzle(nozzle, timing_rel)</code>","text":"<p>Setting the time zero for the nozzles from the LED alignment in robot</p> <p>Parameters nozle : int     nozzle number timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_zero_nozzle(self, nozzle, timing_rel): \n    \"\"\"\n    Setting the time zero for the nozzles from the LED alignment in robot\n\n    Parameters\n    nozle : int\n        nozzle number\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    if nozzle == 1: \n        self.timing_delay_nozzle_1 = timing_rel\n    elif nozzle == 2: \n        self.timing_delay_nozzle_2 = timing_rel\n    else: \n        print('no valid nozzle selected.')\n        return\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.stop_task","title":"<code>stop_task(verbose=True)</code>","text":"<p>Stop task while running ** ISSUES ** -  When stop task  is called, the Robot stays in \"BUSY\" Status. Parameters</p> <p>verbose : boolean     Defines whether the function returns the full output, or only the results Returns:  r :      status readback when aborted</p> Source code in <code>dod/dod.py</code> <pre><code>def stop_task(self, verbose = True):\n    \"\"\"\n    Stop task while running\n    ** ISSUES **\n    -  When stop task  is called, the Robot stays in \"BUSY\" Status.\n    Parameters\n    ----------\n    verbose : boolean\n        Defines whether the function returns the full output, or only the results\n    Returns: \n    r : \n        status readback when aborted\n    \"\"\"\n    r = self.client.connect(\"Test\")\n    self.safety_abort = False\n    r = self.client.stop_task()\n    r = self.client.disconnect()\n    if verbose == True: \n        return r\n</code></pre>"},{"location":"beamline.html#mfx.beamline.DoD.test_forbidden_region","title":"<code>test_forbidden_region(x_test, y_test)</code>","text":"<p>tests if the end point of a motion is inside a forbidden region No testing of the path of a motion included!</p> <p>Parameters x_test : float     x-position to test  y_test : float      y-position to test </p> <p>Returns:  safe_motion : bool     boolean flag if endpoint of motion is safe or not</p> Source code in <code>dod/dod.py</code> <pre><code>def test_forbidden_region(self, x_test, y_test): \n    \"\"\"\n    tests if the end point of a motion is inside a forbidden region\n    No testing of the path of a motion included!\n\n    Parameters\n    x_test : float\n        x-position to test \n    y_test : float \n        y-position to test \n\n    ----------\n    Returns: \n    safe_motion : bool\n        boolean flag if endpoint of motion is safe or not\n    \"\"\"\n    from dod.codi import CoDI_base\n    # Get current rotation state\n    pos_rot_base  = round(CoDI_base.wm(),0)\n\n    #Initialize safe flag (True = safe)\n    flag_safe_endpoint = True\n\n    #combine the lists depending on the rotation \n    if pos_rot_base == 90: \n        test_list_safety = self.forbidden_regions_vertical\n    elif pos_rot_base == 0:\n        test_list_safety = self.forbidden_regions_horizontal\n    else:\n        test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n    #Test for all regions if the end point is in the forbidden region\n    for tuple_current in test_list_safety: \n        x_start, x_stop, y_start, y_stop = tuple_current\n        if ((x_start &lt; x_test) and (x_stop &gt; x_test) and (y_start &lt; y_test) and (y_stop &gt; y_test)): \n            flag_safe_endpoint = flag_safe_endpoint and False\n        else:\n            flag_safe_endpoint = flag_safe_endpoint and True\n\n    return flag_safe_endpoint\n</code></pre>"},{"location":"beamline.html#mfx.beamline.MFX_Timing","title":"<code>MFX_Timing</code>","text":"Source code in <code>mfx/mfx_timing.py</code> <pre><code>class MFX_Timing:\n    def __init__(self,sequencer=None):\n        from pcdsdevices.sequencer import EventSequencer\n        self.seq1 = EventSequencer('ECS:SYS0:7', name='mfx_sequencer')\n        self.seq2 = EventSequencer('ECS:SYS0:12', name='mfx_sequencer_spare')\n\n        self.evt_code = {\n            'wait':0,\n            'pp_trig':197,\n            'daq_readout':198,\n            'laser_on':203,\n            'laser_off':204,\n            'ray_readout':210,\n            'ray1':211,\n            'ray2':212,\n            'ray3':213,\n        }\n        self.sync_markers = {0.5:0, 1:1, 5:2, 10:3, 30:4, 60:5, 120:6, 360:7}\n        self.sequence = []\n\n\n    def _seq_step(self, evt_code_name=None, delta_beam=0):\n        try:\n            return [self.evt_code[evt_code_name], delta_beam, 0, 0]\n        except:\n            print('Error: event sequencer step not recognized.')\n\n\n    def _seq_init(self, sync_mark=30):\n        from time import sleep\n        self.seq.sync_marker.put(self.sync_markers[sync_mark])\n        self.sequence = []\n        sequence = []\n        for ii in range(15):\n            sequence.append(self._seq_step('wait', 0))\n        self.seq.sequence.put_seq(sequence)\n        sleep(1)\n\n\n    def _seq_put(self, steps):\n        for step in steps:\n            self.sequence.append(self._seq_step(step[0], step[1]))\n        self.seq.sequence.put_seq(self.sequence)\n\n\n    def _seq_120hz(self):\n        steps = [['ray_readout', 1],\n                 ['daq_readout',0],\n                 ['ray1',1],\n                 ['daq_readout',0],\n                 ['ray2',1],\n                 ['daq_readout',0],\n                 ['ray3',1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_120hz_trucated(self):\n        steps = [['ray_readout', 1],\n                 ['daq_readout',0]]\n        return steps\n\n\n    def _seq_60hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['daq_readout', 0],\n                 ['ray2', 1],\n                 ['pp_trig', 0],\n                 ['ray3', 1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_60hz_trucated(self):\n        steps = [['ray_readout', 1],\n                 ['ray1', 0],\n                 ['ray2', 1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_30hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['ray2', 1],\n                 ['daq_readout', 0],\n                 ['ray3', 1]]\n        return steps\n\n\n    def _seq_20hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['ray2', 1],\n                 ['daq_readout', 0],\n                 ['ray3', 1],\n                 ['ray3', 1],\n                 ['ray3', 1]]\n        return steps\n\n\n    def set_seq(self, rep=None, sequencer=None, laser=None):\n        \"\"\"\n    Set your event sequencer\n\n    Parameters\n    ----------\n    rep: int, optional\n        Set repitition rate only 120, 60, 30, and 20 Hz are currently available\n\n    sequencer: str, optional\n        default is event sequencer 7 and use 'spare' to run sequencer 12\n\n    laser: list, optional\n        sets laser sequence list in format [['laser_on',0],['laser_off',0],...]\n\n    Operations\n    ----------\n\n        \"\"\"\n        self.seq1.stop()\n        self.seq2.stop()\n        if str(sequencer).lower() == 'spare':\n            self.seq = self.seq2\n        else:\n            self.seq = self.seq1\n        if laser:\n            if rep is None or rep == 120:\n                self._seq_init(sync_mark=120)\n                for laser_evt in laser:\n                    sequence = self._seq_120hz_trucated()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 60:\n                self._seq_init(sync_mark=120)\n                for laser_evt in laser:\n                    sequence = self._seq_60hz_trucated()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 30:\n                self._seq_init(sync_mark=30)\n                for laser_evt in laser:\n                    sequence = self._seq_30hz()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 20:\n                self._seq_init(sync_mark=60)\n                for laser_evt in laser:\n                    sequence = self._seq_20hz()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n        else:\n            if rep is None or rep == 120:\n                self._seq_init(sync_mark=120)\n                self._seq_put(self._seq_120hz())\n            elif rep == 60:\n                self._seq_init(sync_mark=60)\n                self._seq_put(self._seq_60hz())\n            elif rep == 30:\n                self._seq_init(sync_mark=30)\n                self._seq_put(self._seq_30hz())\n            elif rep == 20:\n                self._seq_init(sync_mark=20)\n                self._seq_put(self._seq_20hz())\n\n        self.seq.start()\n        return self.sequence\n\n    def check_seq(self):\n        for line in self.sequence:\n            print(line)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.MFX_Timing.set_seq","title":"<code>set_seq(rep=None, sequencer=None, laser=None)</code>","text":"<p>Set your event sequencer</p>"},{"location":"beamline.html#mfx.beamline.MFX_Timing.set_seq--parameters","title":"Parameters","text":"<p>rep: int, optional     Set repitition rate only 120, 60, 30, and 20 Hz are currently available</p> str, optional <p>default is event sequencer 7 and use 'spare' to run sequencer 12</p> list, optional <p>sets laser sequence list in format [['laser_on',0],['laser_off',0],...]</p>"},{"location":"beamline.html#mfx.beamline.MFX_Timing.set_seq--operations","title":"Operations","text":"Source code in <code>mfx/mfx_timing.py</code> <pre><code>def set_seq(self, rep=None, sequencer=None, laser=None):\n    \"\"\"\nSet your event sequencer\n\nParameters\n----------\nrep: int, optional\n    Set repitition rate only 120, 60, 30, and 20 Hz are currently available\n\nsequencer: str, optional\n    default is event sequencer 7 and use 'spare' to run sequencer 12\n\nlaser: list, optional\n    sets laser sequence list in format [['laser_on',0],['laser_off',0],...]\n\nOperations\n----------\n\n    \"\"\"\n    self.seq1.stop()\n    self.seq2.stop()\n    if str(sequencer).lower() == 'spare':\n        self.seq = self.seq2\n    else:\n        self.seq = self.seq1\n    if laser:\n        if rep is None or rep == 120:\n            self._seq_init(sync_mark=120)\n            for laser_evt in laser:\n                sequence = self._seq_120hz_trucated()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 60:\n            self._seq_init(sync_mark=120)\n            for laser_evt in laser:\n                sequence = self._seq_60hz_trucated()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 30:\n            self._seq_init(sync_mark=30)\n            for laser_evt in laser:\n                sequence = self._seq_30hz()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 20:\n            self._seq_init(sync_mark=60)\n            for laser_evt in laser:\n                sequence = self._seq_20hz()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n    else:\n        if rep is None or rep == 120:\n            self._seq_init(sync_mark=120)\n            self._seq_put(self._seq_120hz())\n        elif rep == 60:\n            self._seq_init(sync_mark=60)\n            self._seq_put(self._seq_60hz())\n        elif rep == 30:\n            self._seq_init(sync_mark=30)\n            self._seq_put(self._seq_30hz())\n        elif rep == 20:\n            self._seq_init(sync_mark=20)\n            self._seq_put(self._seq_20hz())\n\n    self.seq.start()\n    return self.sequence\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM","title":"<code>OM</code>","text":"Source code in <code>mfx/om.py</code> <pre><code>class OM:\n    def __init__(self):\n        from mfx.macros import get_exp\n        self.experiment = str(get_exp())\n        self.cwd = f'/cds/home/opr/mfxopr/OM-GUI'\n        self.pwd = f'{self.cwd}/{self.experiment}'\n\n\n    def fix_run_om(self, path: str):\n        \"\"\"\n        Fixes the run_om.sh file to have current experiment number\n\n        Parameters:\n            path (str): run_om.sh file path.\n\n        Operations:\n\n        \"\"\"\n        from subprocess import check_output\n        import logging\n        logging.info(f\"Updating run_om.sh file: {path}\")\n        wherepsana = check_output(\"wherepsana\",shell=True).decode().strip('\\n')\n\n        with open(path, \"r\") as file:\n            lines = file.readlines()\n            for ind, line in enumerate(lines):\n                if '--host' in lines[ind]:\n                    newline = f'     --host {wherepsana} $(pwd)/monitor_wrapper.sh\\n'\n                    logging.info(f'Changing line {ind} to {newline}')\n                    lines[ind] = newline\n\n        with open(path, 'w') as file:\n            file.writelines(lines)\n\n\n    def fix_yaml(self, yaml: str, mask='', geom=''):\n        \"\"\"\n        Fixes the yaml file to have current experiment number\n\n        Parameters:\n            yaml (str): monitor.yaml file path.\n\n            mask (str): mask file path.\n\n            geom (str): geom file path.\n\n        Operations:\n\n        \"\"\"\n        import logging\n        logging.info(f\"Updating yaml file: {yaml}\")\n        with open(yaml, \"r\") as file:\n            lines = file.readlines()\n            for ind, line in enumerate(lines):\n                if 'psana_calibration_directory' in lines[ind]:\n                    newline = f'  psana_calibration_directory: /sdf/data/lcls/ds/mfx/{self.experiment}/calib\\n'\n                    logging.info(f'Changing line {ind} to {newline}')\n                    lines[ind] = newline\n            if mask != '':\n                for ind, line in enumerate(lines):\n                    if 'bad_pixel_map_filename' in lines[ind]:\n                        newline = f'  bad_pixel_map_filename: {mask}\\n'\n                        logging.info(f'Changing line {ind} to {newline}')\n                        lines[ind] = newline\n\n            if geom != '':\n                for ind, line in enumerate(lines):\n                    if 'geometry_file' in lines[ind]:\n                        newline = f'  geometry_file: {geom}\\n'\n                        logging.info(f'Changing line {ind} to {newline}')\n                        lines[ind] = newline\n\n        with open(yaml, 'w') as file:\n            file.writelines(lines)\n\n\n    def check_settings(self):\n        \"\"\"\n        Checks OM's file system and sets it up if needed\n\n        Parameters\n        ----------\n\n        Operations\n        ----------\n        \"\"\"\n        import os\n        import sys\n        import logging\n        from shutil import copy2\n        logging.info(\"Checking OM Files\")\n        if not os.path.exists(self.pwd) or len(os.listdir(self.pwd)) == 0:\n            logging.warning(f\"No Directory Exists for Experiment: {self.experiment}. Would you like to create it?\")\n            mkdir = input(\"(y/n)? \")\n\n            if mkdir.lower() == \"y\":\n                logging.info(f\"Creating Directory for Experiment: {self.experiment}.\")\n                pre_pwd = max(\n                    [os.path.join(self.cwd, d) for d in os.listdir(\n                        self.cwd) if os.path.isdir(os.path.join(self.cwd, d))], key=os.path.getmtime)\n\n                os.makedirs(self.pwd)\n                det_dirs=[f'{self.pwd}/om_workspace', f'{self.pwd}/om_workspace_rayonix', f'{self.pwd}/om_workspace_xes']\n                logging.info(f\"Creating Directories for Epix10k2M.\")\n                os.makedirs(det_dirs[0])\n                logging.info(f\"Creating Directories for Rayonix.\")\n                os.makedirs(det_dirs[1])\n                logging.info(f\"Creating Directories for XES.\")\n                os.makedirs(det_dirs[2])\n\n                pre_det_dirs=[f'{pre_pwd}/om_workspace', f'{pre_pwd}/om_workspace_rayonix', f'{pre_pwd}/om_workspace_xes']\n\n                logging.info(f\"Copying Key Files from Previous Experiment: {pre_pwd}\")\n\n                for ind, det in enumerate(det_dirs):\n                    logging.info(f\"Copying Key Files for: {pre_det_dirs[ind]}\")\n                    shell_list = [os.path.join(pre_det_dirs[ind], file) for file in os.listdir(\n                        pre_det_dirs[ind]) if file.endswith(\".sh\")]\n                    if len(shell_list) != 0:\n                        for sh in shell_list:\n                            copy2(sh, det_dirs[ind])\n                    else:\n                        logging.error(f'No shell scripts found in: {det}')\n\n                    if os.path.isfile(os.path.join(det, 'run_om.sh')):\n                        self.fix_run_om(os.path.join(det, 'run_om.sh'))\n\n                    geom_list = [os.path.join(\n                        pre_det_dirs[ind], file) for file in os.listdir(\n                            pre_det_dirs[ind]) if file.endswith(\".geom\")]\n                    if len(geom_list) != 0:\n                        geom = max(geom_list, key=os.path.getmtime)\n                        copy2(geom, det_dirs[ind])\n                    else:\n                        logging.error(f'No geom found in: {det}')\n\n                    mask_list = [os.path.join(\n                        pre_det_dirs[ind], file) for file in os.listdir(\n                            pre_det_dirs[ind]) if 'mask' in file]\n                    if len(mask_list) != 0:\n                        mask = max(mask_list, key=os.path.getmtime)\n                        copy2(mask, det_dirs[ind])\n                    else:\n                        logging.error(f'No mask found in: {det}')\n\n                    yaml_list = [os.path.join(\n                        pre_det_dirs[ind], file) for file in os.listdir(\n                            pre_det_dirs[ind]) if file.endswith(\".yaml\")]\n                    if len(yaml_list) != 0:\n                        yaml = max(yaml_list, key=os.path.getmtime)\n                        copy2(yaml, det_dirs[ind])\n                        self.fix_yaml(\n                            os.path.join(\n                                det_dirs[ind], os.path.basename(yaml)), mask=os.path.basename(mask), geom=os.path.basename(geom))\n                    else:\n                        logging.error(f'No yaml found in: {det}')\n\n                logging.info(f\"Copying om_reset_plots.py\")\n                copy2(os.path.join(pre_pwd, 'om_reset_plots.py'), self.pwd)\n            else:\n                logging.info(f\"You've decided not to continue. Program will exit\")\n                sys.exit()\n\n\n    def gui(\n        self,\n        user: str,\n        facility: str = \"S3DF\",\n        debug: bool = False,\n    ):\n        \"\"\"Launch OM GUI.\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            facility (str): Default: \"S3DF\". Options: \"S3DF, NERSC\".\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n        import subprocess\n\n        proc = [\n            f\"ssh -YAC {user}@s3dflogin \"\n            f\"/sdf/group/lcls/ds/tools/mfx/scripts/unknown \"\n            f\"{user} {self.experiment} {facility} 1 {str(debug)}\"\n            ]\n\n        logging.info(proc)\n\n        if debug:\n            os.system(proc[0])\n        else:\n            subprocess.Popen(\n                proc, shell=True,\n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n\n    def kill(self):\n        import logging\n        import subprocess\n\n        proc = [\n            \"ssh -YAC mfx-monitor \"\n            \"kill -9  `ps ux | grep monitor_wrapper.sh | grep -v grep | awk '{ print $2 }'`\"\n            ]\n\n        logging.info(proc)\n\n        subprocess.Popen(\n            proc, shell=True,\n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n\n    def om(self, det=None, start='all', calibdir=None, debug: bool = False):\n        \"\"\"\n        Launches OM\n\n        Parameters\n        ----------\n        det: str, optional\n            Detector name. Example 'Rayonix', 'Epix10k2M', or 'XES' for spectroscopy\n\n        start: str, optional\n            Which process to start. All by default\n\n        calibdir: str, optional\n            path to calib directory\n\n        debug (bool): Default: False.\n\n        Operations\n        ----------\n\n        \"\"\"\n        import logging\n        import subprocess\n        import os\n        self.check_settings()\n        monitor_wrapper = ''\n        monitor_wrapper = subprocess.check_output(\n            \"ssh -YAC mfx-monitor ps aux | grep monitor_wrapper.sh | grep -v grep | awk '{ print $2 }'\",shell=True).decode()\n\n        det_dir = None\n\n        if str(det).lower() == 'rayonix':\n                det_dir = f'{self.pwd}/om_workspace_rayonix'\n        elif str(det).lower() == 'epix10k2m':\n                det_dir = f'{self.pwd}/om_workspace'\n        elif str(det).lower() == 'xes':\n                det_dir = f'{self.pwd}/om_workspace_xes'\n        else:\n            logging.error(\n                \"No proper detector seclected. Please use either\"\n                \"'Rayonix', 'Epix10k2M', or 'XES' for spectroscopy\")\n\n        if monitor_wrapper == '':\n            proc = [\n                f'{det_dir}/run_gui.sh',\n                f'{det_dir}/run_frame_viewer.sh',\n                f'ssh -YAC mfx-monitor \"cd {det_dir}; ./run_om.sh\"'\n                ]\n        else:\n            proc = [\n                f'{det_dir}/run_gui.sh',\n                f'{det_dir}/run_frame_viewer.sh'\n                ]\n\n        logging.info(proc)\n\n        if debug:\n            subprocess.Popen(\n                proc[0], shell=True, \n                    stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n            subprocess.Popen(\n                proc[1], shell=True, \n                    stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n            os.system(proc[-1])\n        else:\n            for cmd in proc:\n                subprocess.Popen(\n                    cmd, shell=True, \n                    stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    def reset(self):\n        \"\"\"\n        Resets OM\n\n        Parameters\n        ----------\n\n        Operations\n        ----------\n\n        \"\"\"\n        import logging\n        import subprocess\n\n        proc = [\n            f'ssh -YAC mfx-monitor \"source /reg/g/pcds/engineering_tools/mfx/scripts/pcds_conda; '\n            f'conda deactivate; source /cds/sw/ds/ana/conda1/manage/bin/psconda.sh; '\n            f'python {self.pwd}/om_reset_plots.py daq-mfx-mon10\"',\n            ]\n\n        logging.info(proc)\n\n        subprocess.Popen(\n            proc, shell=True, \n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.check_settings","title":"<code>check_settings()</code>","text":"<p>Checks OM's file system and sets it up if needed</p>"},{"location":"beamline.html#mfx.beamline.OM.check_settings--parameters","title":"Parameters","text":""},{"location":"beamline.html#mfx.beamline.OM.check_settings--operations","title":"Operations","text":"Source code in <code>mfx/om.py</code> <pre><code>def check_settings(self):\n    \"\"\"\n    Checks OM's file system and sets it up if needed\n\n    Parameters\n    ----------\n\n    Operations\n    ----------\n    \"\"\"\n    import os\n    import sys\n    import logging\n    from shutil import copy2\n    logging.info(\"Checking OM Files\")\n    if not os.path.exists(self.pwd) or len(os.listdir(self.pwd)) == 0:\n        logging.warning(f\"No Directory Exists for Experiment: {self.experiment}. Would you like to create it?\")\n        mkdir = input(\"(y/n)? \")\n\n        if mkdir.lower() == \"y\":\n            logging.info(f\"Creating Directory for Experiment: {self.experiment}.\")\n            pre_pwd = max(\n                [os.path.join(self.cwd, d) for d in os.listdir(\n                    self.cwd) if os.path.isdir(os.path.join(self.cwd, d))], key=os.path.getmtime)\n\n            os.makedirs(self.pwd)\n            det_dirs=[f'{self.pwd}/om_workspace', f'{self.pwd}/om_workspace_rayonix', f'{self.pwd}/om_workspace_xes']\n            logging.info(f\"Creating Directories for Epix10k2M.\")\n            os.makedirs(det_dirs[0])\n            logging.info(f\"Creating Directories for Rayonix.\")\n            os.makedirs(det_dirs[1])\n            logging.info(f\"Creating Directories for XES.\")\n            os.makedirs(det_dirs[2])\n\n            pre_det_dirs=[f'{pre_pwd}/om_workspace', f'{pre_pwd}/om_workspace_rayonix', f'{pre_pwd}/om_workspace_xes']\n\n            logging.info(f\"Copying Key Files from Previous Experiment: {pre_pwd}\")\n\n            for ind, det in enumerate(det_dirs):\n                logging.info(f\"Copying Key Files for: {pre_det_dirs[ind]}\")\n                shell_list = [os.path.join(pre_det_dirs[ind], file) for file in os.listdir(\n                    pre_det_dirs[ind]) if file.endswith(\".sh\")]\n                if len(shell_list) != 0:\n                    for sh in shell_list:\n                        copy2(sh, det_dirs[ind])\n                else:\n                    logging.error(f'No shell scripts found in: {det}')\n\n                if os.path.isfile(os.path.join(det, 'run_om.sh')):\n                    self.fix_run_om(os.path.join(det, 'run_om.sh'))\n\n                geom_list = [os.path.join(\n                    pre_det_dirs[ind], file) for file in os.listdir(\n                        pre_det_dirs[ind]) if file.endswith(\".geom\")]\n                if len(geom_list) != 0:\n                    geom = max(geom_list, key=os.path.getmtime)\n                    copy2(geom, det_dirs[ind])\n                else:\n                    logging.error(f'No geom found in: {det}')\n\n                mask_list = [os.path.join(\n                    pre_det_dirs[ind], file) for file in os.listdir(\n                        pre_det_dirs[ind]) if 'mask' in file]\n                if len(mask_list) != 0:\n                    mask = max(mask_list, key=os.path.getmtime)\n                    copy2(mask, det_dirs[ind])\n                else:\n                    logging.error(f'No mask found in: {det}')\n\n                yaml_list = [os.path.join(\n                    pre_det_dirs[ind], file) for file in os.listdir(\n                        pre_det_dirs[ind]) if file.endswith(\".yaml\")]\n                if len(yaml_list) != 0:\n                    yaml = max(yaml_list, key=os.path.getmtime)\n                    copy2(yaml, det_dirs[ind])\n                    self.fix_yaml(\n                        os.path.join(\n                            det_dirs[ind], os.path.basename(yaml)), mask=os.path.basename(mask), geom=os.path.basename(geom))\n                else:\n                    logging.error(f'No yaml found in: {det}')\n\n            logging.info(f\"Copying om_reset_plots.py\")\n            copy2(os.path.join(pre_pwd, 'om_reset_plots.py'), self.pwd)\n        else:\n            logging.info(f\"You've decided not to continue. Program will exit\")\n            sys.exit()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.fix_run_om","title":"<code>fix_run_om(path)</code>","text":"<p>Fixes the run_om.sh file to have current experiment number</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>run_om.sh file path.</p> required <p>Operations:</p> Source code in <code>mfx/om.py</code> <pre><code>def fix_run_om(self, path: str):\n    \"\"\"\n    Fixes the run_om.sh file to have current experiment number\n\n    Parameters:\n        path (str): run_om.sh file path.\n\n    Operations:\n\n    \"\"\"\n    from subprocess import check_output\n    import logging\n    logging.info(f\"Updating run_om.sh file: {path}\")\n    wherepsana = check_output(\"wherepsana\",shell=True).decode().strip('\\n')\n\n    with open(path, \"r\") as file:\n        lines = file.readlines()\n        for ind, line in enumerate(lines):\n            if '--host' in lines[ind]:\n                newline = f'     --host {wherepsana} $(pwd)/monitor_wrapper.sh\\n'\n                logging.info(f'Changing line {ind} to {newline}')\n                lines[ind] = newline\n\n    with open(path, 'w') as file:\n        file.writelines(lines)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.fix_yaml","title":"<code>fix_yaml(yaml, mask='', geom='')</code>","text":"<p>Fixes the yaml file to have current experiment number</p> <p>Parameters:</p> Name Type Description Default <code>yaml</code> <code>str</code> <p>monitor.yaml file path.</p> required <code>mask</code> <code>str</code> <p>mask file path.</p> <code>''</code> <code>geom</code> <code>str</code> <p>geom file path.</p> <code>''</code> <p>Operations:</p> Source code in <code>mfx/om.py</code> <pre><code>def fix_yaml(self, yaml: str, mask='', geom=''):\n    \"\"\"\n    Fixes the yaml file to have current experiment number\n\n    Parameters:\n        yaml (str): monitor.yaml file path.\n\n        mask (str): mask file path.\n\n        geom (str): geom file path.\n\n    Operations:\n\n    \"\"\"\n    import logging\n    logging.info(f\"Updating yaml file: {yaml}\")\n    with open(yaml, \"r\") as file:\n        lines = file.readlines()\n        for ind, line in enumerate(lines):\n            if 'psana_calibration_directory' in lines[ind]:\n                newline = f'  psana_calibration_directory: /sdf/data/lcls/ds/mfx/{self.experiment}/calib\\n'\n                logging.info(f'Changing line {ind} to {newline}')\n                lines[ind] = newline\n        if mask != '':\n            for ind, line in enumerate(lines):\n                if 'bad_pixel_map_filename' in lines[ind]:\n                    newline = f'  bad_pixel_map_filename: {mask}\\n'\n                    logging.info(f'Changing line {ind} to {newline}')\n                    lines[ind] = newline\n\n        if geom != '':\n            for ind, line in enumerate(lines):\n                if 'geometry_file' in lines[ind]:\n                    newline = f'  geometry_file: {geom}\\n'\n                    logging.info(f'Changing line {ind} to {newline}')\n                    lines[ind] = newline\n\n    with open(yaml, 'w') as file:\n        file.writelines(lines)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.gui","title":"<code>gui(user, facility='S3DF', debug=False)</code>","text":"<p>Launch OM GUI.</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\nfacility (str): Default: \"S3DF\". Options: \"S3DF, NERSC\".\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/om.py</code> <pre><code>def gui(\n    self,\n    user: str,\n    facility: str = \"S3DF\",\n    debug: bool = False,\n):\n    \"\"\"Launch OM GUI.\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        facility (str): Default: \"S3DF\". Options: \"S3DF, NERSC\".\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n    import subprocess\n\n    proc = [\n        f\"ssh -YAC {user}@s3dflogin \"\n        f\"/sdf/group/lcls/ds/tools/mfx/scripts/unknown \"\n        f\"{user} {self.experiment} {facility} 1 {str(debug)}\"\n        ]\n\n    logging.info(proc)\n\n    if debug:\n        os.system(proc[0])\n    else:\n        subprocess.Popen(\n            proc, shell=True,\n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.om","title":"<code>om(det=None, start='all', calibdir=None, debug=False)</code>","text":"<p>Launches OM</p>"},{"location":"beamline.html#mfx.beamline.OM.om--parameters","title":"Parameters","text":"<p>det: str, optional     Detector name. Example 'Rayonix', 'Epix10k2M', or 'XES' for spectroscopy</p> str, optional <p>Which process to start. All by default</p> str, optional <p>path to calib directory</p> <p>debug (bool): Default: False.</p>"},{"location":"beamline.html#mfx.beamline.OM.om--operations","title":"Operations","text":"Source code in <code>mfx/om.py</code> <pre><code>def om(self, det=None, start='all', calibdir=None, debug: bool = False):\n    \"\"\"\n    Launches OM\n\n    Parameters\n    ----------\n    det: str, optional\n        Detector name. Example 'Rayonix', 'Epix10k2M', or 'XES' for spectroscopy\n\n    start: str, optional\n        Which process to start. All by default\n\n    calibdir: str, optional\n        path to calib directory\n\n    debug (bool): Default: False.\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n    import os\n    self.check_settings()\n    monitor_wrapper = ''\n    monitor_wrapper = subprocess.check_output(\n        \"ssh -YAC mfx-monitor ps aux | grep monitor_wrapper.sh | grep -v grep | awk '{ print $2 }'\",shell=True).decode()\n\n    det_dir = None\n\n    if str(det).lower() == 'rayonix':\n            det_dir = f'{self.pwd}/om_workspace_rayonix'\n    elif str(det).lower() == 'epix10k2m':\n            det_dir = f'{self.pwd}/om_workspace'\n    elif str(det).lower() == 'xes':\n            det_dir = f'{self.pwd}/om_workspace_xes'\n    else:\n        logging.error(\n            \"No proper detector seclected. Please use either\"\n            \"'Rayonix', 'Epix10k2M', or 'XES' for spectroscopy\")\n\n    if monitor_wrapper == '':\n        proc = [\n            f'{det_dir}/run_gui.sh',\n            f'{det_dir}/run_frame_viewer.sh',\n            f'ssh -YAC mfx-monitor \"cd {det_dir}; ./run_om.sh\"'\n            ]\n    else:\n        proc = [\n            f'{det_dir}/run_gui.sh',\n            f'{det_dir}/run_frame_viewer.sh'\n            ]\n\n    logging.info(proc)\n\n    if debug:\n        subprocess.Popen(\n            proc[0], shell=True, \n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n        subprocess.Popen(\n            proc[1], shell=True, \n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n        os.system(proc[-1])\n    else:\n        for cmd in proc:\n            subprocess.Popen(\n                cmd, shell=True, \n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.OM.reset","title":"<code>reset()</code>","text":"<p>Resets OM</p>"},{"location":"beamline.html#mfx.beamline.OM.reset--parameters","title":"Parameters","text":""},{"location":"beamline.html#mfx.beamline.OM.reset--operations","title":"Operations","text":"Source code in <code>mfx/om.py</code> <pre><code>def reset(self):\n    \"\"\"\n    Resets OM\n\n    Parameters\n    ----------\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n\n    proc = [\n        f'ssh -YAC mfx-monitor \"source /reg/g/pcds/engineering_tools/mfx/scripts/pcds_conda; '\n        f'conda deactivate; source /cds/sw/ds/ana/conda1/manage/bin/psconda.sh; '\n        f'python {self.pwd}/om_reset_plots.py daq-mfx-mon10\"',\n        ]\n\n    logging.info(proc)\n\n    subprocess.Popen(\n        proc, shell=True, \n        stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_separate_runs","title":"<code>attenuator_scan_separate_runs(duration=None, record=False, transmissions=[0.01, 0.02, 0.03], use_daq=True, **kwargs)</code>","text":"<p>Runs through attenuator conditions and records each as an individual run</p>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_separate_runs--parameters","title":"Parameters","text":"<p>duration: int, optional     When using the DAQ this corresponds to the number of events. If not     using the DAQ, it corresponds to the number of seconds to wait at ech     attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).</p> bool, optional <p>set True to record</p> list of floats, optional <p>list of transmissions to run through. default [0.01,0.02,0.03]</p> bool, optional <p>Whether to include the DAQ or not. Default: True. If False can run the scans while using the DAQ elsewhere.</p> <p>**kwargs - Additional optional keyword arguments     events: int         Provided for backwards compatibility. When using the DAQ, if this         keyword argument is passed, and <code>duration</code> is not, it will be used         as the number of events.</p>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_separate_runs--operations","title":"Operations","text":"Source code in <code>mfx/attenuator_scan.py</code> <pre><code>def attenuator_scan_separate_runs(\n    duration: int = None,\n    record: bool = False,\n    transmissions: list = [0.01, 0.02, 0.03],\n    use_daq: bool = True,\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Runs through attenuator conditions and records each as an individual run\n\n    Parameters\n    ----------\n    duration: int, optional\n        When using the DAQ this corresponds to the number of events. If not\n        using the DAQ, it corresponds to the number of seconds to wait at ech\n        attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).\n\n    record: bool, optional\n        set True to record\n\n    transmissions: list of floats, optional\n        list of transmissions to run through. default [0.01,0.02,0.03]\n\n    use_daq: bool, optional\n        Whether to include the DAQ or not. Default: True. If False can run the\n        scans while using the DAQ elsewhere.\n\n    **kwargs - Additional optional keyword arguments\n        events: int\n            Provided for backwards compatibility. When using the DAQ, if this\n            keyword argument is passed, and `duration` is not, it will be used\n            as the number of events.\n\n    Operations\n    ----------\n\n    \"\"\"\n    from time import sleep\n    from mfx.db import att, pp\n\n    if use_daq:\n        from mfx.db import daq\n\n    evts = kwargs.get(\"events\")\n    if duration is None:\n        if use_daq:\n            duration = evts if evts else 240\n        else:\n            duration = 3\n            if evts is not None:\n                print(\"`events` parameter ignored when not using DAQ! Use `duration`!\")\n\n    pp.open()\n    for i in transmissions:\n        att(i)\n        if use_daq:\n            sleep(3)\n            daq.begin(events=duration, record=record, wait=True, use_l3t=False)\n            daq.end_run()\n        else:\n            sleep(duration)\n    pp.close()\n    if use_daq:\n        daq.disconnect()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_single_run","title":"<code>attenuator_scan_single_run(duration=None, record=False, transmissions=[0.01, 0.02, 0.03], use_daq=True, **kwargs)</code>","text":"<p>Runs through attenuator conditions and records them all as one continuous run</p>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_single_run--parameters","title":"Parameters","text":"<p>duration: int, optional     When using the DAQ this corresponds to the number of events. If not     using the DAQ, it corresponds to the number of seconds to wait at ech     attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).</p> bool, optional <p>set True to record</p> list of floats, optional <p>list of transmissions to run through. default [0.01,0.02,0.03]</p> bool, optional <p>Whether to include the DAQ or not. Default: True. If False can run the scans while using the DAQ elsewhere.</p> <p>**kwargs - Additional optional keyword arguments     events: int         Provided for backwards compatibility. When using the DAQ, if this         keyword argument is passed, and <code>duration</code> is not, it will be used         as the number of events. It is ignored when not using the DAQ.</p>"},{"location":"beamline.html#mfx.beamline.attenuator_scan_single_run--operations","title":"Operations","text":"Source code in <code>mfx/attenuator_scan.py</code> <pre><code>def attenuator_scan_single_run(\n    duration: int = None,\n    record: bool = False,\n    transmissions: list = [0.01, 0.02, 0.03],\n    use_daq: bool = True,\n    **kwargs\n) -&gt; None:\n    \"\"\"\n    Runs through attenuator conditions and records them all as one continuous run\n\n    Parameters\n    ----------\n    duration: int, optional\n        When using the DAQ this corresponds to the number of events. If not\n        using the DAQ, it corresponds to the number of seconds to wait at ech\n        attenuator step. Default is 240 events (with DAQ), or 3 seconds (no DAQ).\n\n    record: bool, optional\n        set True to record\n\n    transmissions: list of floats, optional\n        list of transmissions to run through. default [0.01,0.02,0.03]\n\n    use_daq: bool, optional\n        Whether to include the DAQ or not. Default: True. If False can run the\n        scans while using the DAQ elsewhere.\n\n    **kwargs - Additional optional keyword arguments\n        events: int\n            Provided for backwards compatibility. When using the DAQ, if this\n            keyword argument is passed, and `duration` is not, it will be used\n            as the number of events. It is ignored when not using the DAQ.\n\n    Operations\n    ----------\n\n    \"\"\"\n    from time import sleep\n    from mfx.db import att, pp\n\n    if use_daq:\n        from mfx.db import daq\n\n        #daq.end_run()\n        #daq.disconnect()\n\n    evts = kwargs.get(\"events\")\n    if duration is None:\n        if use_daq:\n            duration = evts if evts else 240\n        else:\n            duration = 3\n            if evts is not None:\n                print(\"`events` parameter ignored when not using DAQ! Use `duration`!\")\n\n    try:\n        pp.open()\n        if use_daq:\n            daq.configure(record=record)\n            sleep(3)\n        for i in transmissions:\n            att(i, wait=True)\n            if use_daq:\n                sleep(3)\n                daq.begin(events=duration, record=record, wait=True, use_l3t=False)\n            else:\n                sleep(duration)\n    finally:\n        if use_daq:\n            daq.end_run()\n            daq.disconnect()\n        pp.close()\n</code></pre>"},{"location":"beamline.html#mfx.beamline.autorun","title":"<code>autorun(sample='?', tag=None, run_length=300, record=True, runs=5, inspire=False, daq_delay=5, picker=None, cam=None)</code>","text":"<p>Automate runs.... With optional quotes</p>"},{"location":"beamline.html#mfx.beamline.autorun--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> str, optional <p>Run group tag</p> int, optional <p>number of seconds for run 300 is default</p> bool, optional <p>set True to record</p> int, optional <p>number of runs 5 is default</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> int, optional <p>delay time between runs. Default is 5 second but increase is the DAQ is being slow.</p> str, optional <p>If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts</p>"},{"location":"beamline.html#mfx.beamline.autorun--operations","title":"Operations","text":"Source code in <code>mfx/autorun.py</code> <pre><code>def autorun(sample='?', tag=None, run_length=300, record=True,\n            runs=5, inspire=False, daq_delay=5, picker=None, cam=None):\n    \"\"\"\n    Automate runs.... With optional quotes\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    tag: str, optional\n        Run group tag\n\n    run_length: int, optional\n        number of seconds for run 300 is default\n\n    record: bool, optional\n        set True to record\n\n    runs: int, optional\n        number of runs 5 is default\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    daq_delay: int, optional\n        delay time between runs. Default is 5 second but increase is the DAQ is being slow.\n\n    picker: str, optional\n        If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    from time import sleep\n    from mfx.db import daq, pp\n    logger = logging.getLogger(__name__)\n\n    if sample.lower()=='water' or sample.lower()=='h2o':\n        inspire=True\n    if picker=='open':\n        pp.open()\n    if picker=='flip':\n        pp.flipflop()\n\n    if tag is None:\n        tag = sample\n\n    for i in range(runs):\n        logger.info(f\"Run Number {daq.run_number() + 1} Running {sample}......{quote()['quote']}\")\n        run_number = daq.run_number() + 1\n        status = begin(duration = run_length, record = record, wait = True, end_run = True)\n        if cam is not None:\n            ioc_cam_recorder(cam, run_length, tag)\n        if status is False:\n            pp.close()\n            post(sample, run_number, record, inspire, 'Run ended prematurely. Probably sample delivery problem')\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.stop()\n            daq.disconnect()\n            logger.warning('Run ended prematurely. Probably sample delivery problem')\n            break\n\n        post(sample, tag, run_number, record, inspire)\n        try:\n            sleep(daq_delay)\n        except KeyboardInterrupt:\n            pp.close()\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.disconnect()\n            status = False\n            if status is False:\n                logger.warning('Run ended prematurely. Probably sample delivery problem')\n                break\n    if status:\n        pp.close()\n        daq.end_run()\n        daq.disconnect()\n        logger.warning('Finished with all runs thank you for choosing the MFX beamline!\\n')\n</code></pre>"},{"location":"beamline.html#mfx.beamline.begin","title":"<code>begin(events=None, duration=300, record=False, use_l3t=None, controls=None, wait=False, end_run=False)</code>","text":"<p>Start the daq and block until the daq has begun acquiring data.</p> <p>Optionally block with <code>wait=True</code> until the daq has finished aquiring data. If blocking, a <code>ctrl+c</code> will end the run and clean up.</p> <p>If omitted, any argument that is shared with <code>configure</code> will fall back to the configured value.</p> <p>Internally, this calls <code>kickoff</code> and manages its <code>Status</code> object.</p>"},{"location":"beamline.html#mfx.beamline.begin--parameters","title":"Parameters","text":"<p>events: <code>int</code>, optional     Number events to take in the daq.</p> <code>int</code>, optional <p>Time to run the daq in seconds, if <code>events</code> was not provided.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll configure the daq to record data before this run.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll run with the level 3 trigger. This means that if we specified a number of events, we will wait for that many \"good\" events as determined by the daq.</p> <code>dict{name: device}</code> or <code>list[device...]</code>, optional <p>If provided, values from these will make it into the DAQ data stream as variables. We will check <code>device.position</code> and <code>device.value</code> for quantities to use and we will update these values each time begin is called. To provide a list, all devices must have a <code>name</code> attribute.</p> <code>bool</code>, optional <p>If <code>True</code>, wait for the daq to finish aquiring data. A <code>KeyboardInterrupt</code> (<code>ctrl+c</code>) during this wait will end the run and clean up.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll end the run after the daq has stopped.</p> Source code in <code>mfx/autorun.py</code> <pre><code>def begin(events=None, duration=300,\n          record=False, use_l3t=None, controls=None,\n          wait=False, end_run=False):\n    \"\"\"\n    Start the daq and block until the daq has begun acquiring data.\n\n    Optionally block with ``wait=True`` until the daq has finished aquiring\n    data. If blocking, a ``ctrl+c`` will end the run and clean up.\n\n    If omitted, any argument that is shared with `configure`\n    will fall back to the configured value.\n\n    Internally, this calls `kickoff` and manages its ``Status`` object.\n\n    Parameters\n    ----------\n    events: ``int``, optional\n        Number events to take in the daq.\n\n    duration: ``int``, optional\n        Time to run the daq in seconds, if ``events`` was not provided.\n\n    record: ``bool``, optional\n        If ``True``, we'll configure the daq to record data before this\n        run.\n\n    use_l3t: ``bool``, optional\n        If ``True``, we'll run with the level 3 trigger. This means that\n        if we specified a number of events, we will wait for that many\n        \"good\" events as determined by the daq.\n\n    controls: ``dict{name: device}`` or ``list[device...]``, optional\n        If provided, values from these will make it into the DAQ data\n        stream as variables. We will check ``device.position`` and\n        ``device.value`` for quantities to use and we will update these\n        values each time begin is called. To provide a list, all devices\n        must have a ``name`` attribute.\n\n    wait: ``bool``, optional\n        If ``True``, wait for the daq to finish aquiring data. A\n        ``KeyboardInterrupt`` (``ctrl+c``) during this wait will end the\n        run and clean up.\n\n    end_run: ``bool``, optional\n        If ``True``, we'll end the run after the daq has stopped.\n    \"\"\"\n    import logging\n    from time import sleep\n    from mfx.db import daq\n    from ophyd.utils import StatusTimeoutError, WaitTimeoutError\n    logger = logging.getLogger(__name__)\n\n    logger.debug(('Daq.begin(events=%s, duration=%s, record=%s, '\n                    'use_l3t=%s, controls=%s, wait=%s)'),\n                    events, duration, record, use_l3t, controls, wait)\n    status = True\n    try:\n        if record is not None and record != daq.record:\n            old_record = daq.record\n            daq.preconfig(record=record, show_queued_cfg=False)\n        begin_status = daq.kickoff(events=events, duration=duration,\n                                    use_l3t=use_l3t, controls=controls)\n        try:\n            begin_status.wait(timeout=daq._begin_timeout)\n        except (StatusTimeoutError, WaitTimeoutError) as e:\n            msg = (f'Timeout after {daq._begin_timeout} seconds waiting '\n                    'for daq to begin. Exception: {type(e).__name__}')\n            logger.info(msg)\n            #raise DaqTimeoutError(msg) from None\n\n        # In some daq configurations the begin status returns very early,\n        # so we allow the user to configure an emperically derived extra\n        # sleep.\n        sleep(daq.config['begin_sleep'])\n        if wait:\n            daq.wait()\n            if end_run:\n                daq.end_run()\n        if end_run and not wait:\n            threading.Thread(target=daq._ender_thread, args=()).start()\n        return status\n    except KeyboardInterrupt:\n            status = False\n            return status\n</code></pre>"},{"location":"beamline.html#mfx.beamline.correct_timing_drift","title":"<code>correct_timing_drift(amplitude_thresh=0.02, ipm_thresh=500.0, drift_adjustment_thresh=0.05, fwhm_threshs=(30, 130), num_events=61, will_log=True)</code>","text":"<p>Automate the correction of timing drift. Will adjust the stages to center the timetool edge on the camera and compensate the laser delay to maintain the desired nominal time point. Runs in an infinite loop.</p>"},{"location":"beamline.html#mfx.beamline.correct_timing_drift--parameters","title":"Parameters","text":"<p>amplitude_thresh : float, optional     The minimum amplitude of the fitted timetool peak to include the     data point in the rolling average used for drift correction.     Default: 0.02. ipm_thresh : float, optional     The minimum ipm DG2 value to perform drift correction. Setting a     reasonable value prevents attempts at drift correction when X-rays     are very weak or down. Default: 500. drift_adjustment_thresh : float, optional     The minimum drift value to correct for in picoseconds. E.g. a value     of 0.05 means any time the rolling average finds that the timetool     center is off by 50 fs in either direction it will compensate. Default:     0.05 ps. fwhm_threshs : Tuple[float, float], optional     Minimum and maximum FWHM from the processed timetool signal to consider     a measurement to be \"good.\" num_events : int, optional     The number of \"good\" timetool edge measurements to include in the     rolling average. Ideally a prime number to remove effects from     sytematic errors. Default 61 measurements. will_log : bool, optional     Log timing corrections to a file.</p> Source code in <code>mfx/timetool.py</code> <pre><code>def correct_timing_drift(\n    amplitude_thresh: float = 0.02,\n    ipm_thresh: float = 500.0,\n    drift_adjustment_thresh: float = 0.05,\n    fwhm_threshs: Tuple[float, float] = (30, 130),\n    num_events: int = 61,\n    will_log: bool = True,\n) -&gt; None:\n    \"\"\"\n    Automate the correction of timing drift. Will adjust the stages to\n    center the timetool edge on the camera and compensate the laser delay to\n    maintain the desired nominal time point. Runs in an infinite loop.\n\n    Parameters\n    ----------\n    amplitude_thresh : float, optional\n        The minimum amplitude of the fitted timetool peak to include the\n        data point in the rolling average used for drift correction.\n        Default: 0.02.\n    ipm_thresh : float, optional\n        The minimum ipm DG2 value to perform drift correction. Setting a\n        reasonable value prevents attempts at drift correction when X-rays\n        are very weak or down. Default: 500.\n    drift_adjustment_thresh : float, optional\n        The minimum drift value to correct for in picoseconds. E.g. a value\n        of 0.05 means any time the rolling average finds that the timetool\n        center is off by 50 fs in either direction it will compensate. Default:\n        0.05 ps.\n    fwhm_threshs : Tuple[float, float], optional\n        Minimum and maximum FWHM from the processed timetool signal to consider\n        a measurement to be \"good.\"\n    num_events : int, optional\n        The number of \"good\" timetool edge measurements to include in the\n        rolling average. Ideally a prime number to remove effects from\n        sytematic errors. Default 61 measurements.\n    will_log : bool, optional\n        Log timing corrections to a file.\n    \"\"\"\n    from mfx.db import lxt, txt\n\n    logfile: str = \"\"\n    if will_log:\n        logfile = input(\"Please enter a file to log correction info to: \")\n\n    timetool_edges: np.ndarray = np.zeros([num_events])\n\n    write_log(f\"Entering timetool drift correction loop\", logfile)\n    while True:\n        try:\n            num_curr_edges: int = 0\n            time_last_good_val: float = time.time()\n            while num_curr_edges &lt; num_events:\n                try:\n                    # EVENTBUILD PV contains 10 fields. TTALL makes up the last 8.\n                    # (indices 0-7), and IPM DG1 and DG2 makeup the first 2.\n                    # See `is_good_measurement` function for more accesses.\n                    timetool: EpicsSignal = EpicsSignal(\"MFX:TT:01:EVENTBUILD.VALA\")\n                    tt_data: np.ndarray = timetool.get()\n\n                    timetool_edge_ps: float = tt_data[3]\n\n                    if is_good_measurement(\n                        tt_data, amplitude_thresh, ipm_thresh, fwhm_threshs\n                    ):\n                        timetool_edges[num_curr_edges] = timetool_edge_ps\n                        num_curr_edges += 1\n                        time_last_good_val = time.time()\n                    elif time.time() - time_last_good_val &gt; 60:\n                        write_log(\n                            f\"No good measurement over one minute. Check thresholds?\",\n                            logfile,\n                        )\n                        time_last_good_val = time.time()\n\n                    time.sleep(0.01)\n                except KeyboardInterrupt as e:\n                    raise KeyboardInterrupt\n\n            tt_edge_average_ps: float = np.mean(timetool_edges)\n            write_log(f\"Current average: {tt_edge_average_ps}\", logfile)\n\n            if np.abs(tt_edge_average_ps) &gt; drift_adjustment_thresh:\n                tt_average_seconds: float = -(tt_edge_average_ps * 1e-12)\n                write_log(f\"Making adjustment to {tt_average_seconds}!\", logfile)\n                lxt.mvr(tt_average_seconds)\n                lxt.set_current_position(-float(txt.position))\n\n        except KeyboardInterrupt as e:\n            write_log(f\"Breaking out of timetool drift correction loop\", logfile)\n            break\n</code></pre>"},{"location":"beamline.html#mfx.beamline.delay_scan","title":"<code>delay_scan(daq, time_motor, time_points, sweep_time, duration=None, record=None, use_l3t=False, controls=None)</code>","text":"<p>Bluesky plan that sets up and executes the delay scan.</p>"},{"location":"beamline.html#mfx.beamline.delay_scan--parameters","title":"Parameters","text":"<p>daq: Daq     The daq</p> DelayNewport <p>The movable device in seconds</p> list of float <p>The times in second to move between</p> float <p>The duration we take to move from one end of the range to the other.</p> bool, optional <p>Whether or not to record in the daq</p> float, optional <p>If provided, the time to run in seconds. If omitted, we'll run forever.</p> bool, optional <p>If True, events argument will be interpreted to only count events that pass the level 3 trigger</p> dict or list of devices, optional <p>If provided, values will make it to DAQ data stream as variables</p> Source code in <code>mfx/delay_scan.py</code> <pre><code>def delay_scan(daq, time_motor, time_points, sweep_time, duration=None, \n               record=None, use_l3t=False, controls=None):\n    \"\"\"\n    Bluesky plan that sets up and executes the delay scan.\n\n    Parameters\n    ----------\n    daq: Daq\n        The daq\n\n    time_motor: DelayNewport\n        The movable device in seconds\n\n    time_points: list of float\n        The times in second to move between\n\n    sweep_time: float\n        The duration we take to move from one end of the range to the other.\n\n    record: bool, optional\n        Whether or not to record in the daq\n\n    duration: float, optional\n        If provided, the time to run in seconds. If omitted, we'll run forever.\n\n    use_l3t: bool, optional\n        If True, events argument will be interpreted to only count events that\n        pass the level 3 trigger\n\n    controls: dict or list of devices, optional\n        If provided, values will make it to DAQ data stream as variables\n    \"\"\"\n\n    spatial_pts = []\n    for time_pt in time_points:\n        pseudo_tuple = time_motor.PseudoPosition(delay=time_pt)\n        real_tuple = time_motor.forward(pseudo_tuple)\n        spatial_pts.append(real_tuple.motor)\n\n    space_delta = abs(spatial_pts[0] - spatial_pts[1])\n    velo = space_delta/sweep_time\n\n    yield from bps.abs_set(time_motor.motor.velocity, velo)\n\n    scan = infinite_scan([], time_motor, time_points, duration=duration)\n\n    if daq is not None:\n        yield from daq_during_wrapper(scan, record=record, use_l3t=use_l3t,\n                                      controls=controls)\n    else:\n        yield from scan\n</code></pre>"},{"location":"beamline.html#mfx.beamline.detector_image","title":"<code>detector_image(node=5, det='Rayonix', calibdir=None, ave=1)</code>","text":"<p>Launches detector monitor</p>"},{"location":"beamline.html#mfx.beamline.detector_image--parameters","title":"Parameters","text":"<p>node: int, optional     Node to run detector monitor 1-9 only</p> str, optional <p>Detector name. Example 'Rayonix'</p> str, optional <p>path to calib directory</p> int, optional <p>Average over this number of events</p>"},{"location":"beamline.html#mfx.beamline.detector_image--operations","title":"Operations","text":"Source code in <code>mfx/detector_image.py</code> <pre><code>def detector_image(node=5, det='Rayonix', calibdir=None, ave=1):\n    \"\"\"\n    Launches detector monitor\n\n    Parameters\n    ----------\n    node: int, optional\n        Node to run detector monitor 1-9 only\n\n    det: str, optional\n        Detector name. Example 'Rayonix'\n\n    calibdir: str, optional\n        path to calib directory\n\n    ave: int, optional\n        Average over this number of events\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n    from mfx.macros import get_exp\n\n    experiment = str(get_exp())\n\n    proc = [\n        f\"ssh -YAC mfxopr@daq-mfx-mon0{str(node)} \"\n        f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/\"\n        f\"detector_image.sh {experiment} {str(det)} {str(calibdir)} {str(ave)}\"\n        ]\n\n    logging.info(proc)\n\n    subprocess.Popen(\n        proc, shell=True, \n        stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.detector_image_kill","title":"<code>detector_image_kill(node=5)</code>","text":"<p>Kills all detector monitors made with this script</p>"},{"location":"beamline.html#mfx.beamline.detector_image_kill--parameters","title":"Parameters","text":"<p>node: int, optional     Node to run detector monitor 1-9 only</p> str, optional <p>Detector name. Example 'Rayonix'</p> str, optional <p>path to calib directory</p> int, optional <p>Average over this number of events</p>"},{"location":"beamline.html#mfx.beamline.detector_image_kill--operations","title":"Operations","text":"Source code in <code>mfx/detector_image.py</code> <pre><code>def detector_image_kill(node=5):\n    \"\"\"\n    Kills all detector monitors made with this script\n\n    Parameters\n    ----------\n    node: int, optional\n        Node to run detector monitor 1-9 only\n\n    det: str, optional\n        Detector name. Example 'Rayonix'\n\n    calibdir: str, optional\n        path to calib directory\n\n    ave: int, optional\n        Average over this number of events\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n\n    proc = [\n        f\"ssh -YAC mfxopr@daq-mfx-mon0{str(node)} \" +\n        f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/\"\n        f\"detector_image_kill.sh\"\n        ]\n\n    logging.info(proc)\n\n    subprocess.Popen(\n        proc, shell=True)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.focus_scan","title":"<code>focus_scan(camera, start=1, end=299, step=1)</code>","text":"<p>Runs through transfocator Z to find the best focus</p>"},{"location":"beamline.html#mfx.beamline.focus_scan--parameters","title":"Parameters","text":"<p>camera: str, required     camera where you want to focus</p> int, optional <p>step size of transfocator movements</p> int, optional <p>starting transfocator position</p> int, optional <p>final transfocator position</p> <p>Examples: mfx dg1 yag is MFX:DG1:P6740 mfx dg2 yag is MFX:DG2:P6740 mfx dg3 yag is MFX:GIGE:02:IMAGE1</p>"},{"location":"beamline.html#mfx.beamline.focus_scan--operations","title":"Operations","text":"Source code in <code>mfx/focus_scan.py</code> <pre><code>def focus_scan(camera, start=1, end=299, step=1):\n    \"\"\"\n    Runs through transfocator Z to find the best focus\n\n    Parameters\n    ----------\n    camera: str, required\n        camera where you want to focus\n\n    step: int, optional\n\tstep size of transfocator movements\n\n    start: int, optional\n\tstarting transfocator position\n\n    end: int, optional\n\tfinal transfocator position\n\n    Examples:\n    mfx dg1 yag is MFX:DG1:P6740\n    mfx dg2 yag is MFX:DG2:P6740\n    mfx dg3 yag is MFX:GIGE:02:IMAGE1\n\n    Operations\n    ----------\n\n    \"\"\"\n    # cd /reg/g/pcds/pyps/apps/hutch-python/mfx/mfx\n    # from mfx.transfocator_scan import *\n    from mfx.transfocator_scan import transfocator_aligner\n    import numpy as np\n    from mfx.db import tfs\n\n    trf_align = transfocator_aligner(camera)\n    trf_pos = np.arange(start, end, step)\n    trf_align.scan_transfocator(tfs.translation,trf_pos,1)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.infinite_scan","title":"<code>infinite_scan(detectors, motor, points, duration=None, per_step=None, md=None)</code>","text":"<p>Bluesky plan that moves a motor among points until interrupted.</p>"},{"location":"beamline.html#mfx.beamline.infinite_scan--parameters","title":"Parameters","text":"<p>detectors: list of readables     Objects to read into Python in the scan.</p> settable <p>Object to move in the scan.</p> list of floats <p>Positions to move between in the scan.</p> float <p>If provided, the time to run in seconds. If omitted, we'll run forever.</p> Source code in <code>mfx/delay_scan.py</code> <pre><code>def infinite_scan(detectors, motor, points, duration=None,\n                  per_step=None, md=None):\n    \"\"\"\n    Bluesky plan that moves a motor among points until interrupted.\n\n    Parameters\n    ----------\n    detectors: list of readables\n        Objects to read into Python in the scan.\n\n    motor: settable\n        Object to move in the scan.\n\n    points: list of floats\n        Positions to move between in the scan.\n\n    duration: float\n        If provided, the time to run in seconds. If omitted, we'll run forever.\n    \"\"\"\n    if per_step is None:\n        per_step = bps.one_nd_step\n\n    if md is None:\n        md = {}\n\n    md.update(motors=[motor.name])\n    start = time.time()\n\n    #@bpp.stage_decorator(list(detectors) + [motor])\n    @bpp.reset_positions_decorator()\n    @bpp.run_decorator(md=md)\n    def inner():\n        # Where last position is stored\n        pos_cache = defaultdict(lambda: None)\n        while duration is None or time.time() - start &lt; duration:\n            for pt in points:\n                step = {motor: pt}\n                yield from per_step(detectors, step, pos_cache)\n\n    return (yield from inner())\n</code></pre>"},{"location":"beamline.html#mfx.beamline.ioc_cam_recorder","title":"<code>ioc_cam_recorder(cam='camera name', run_length=10, tag='?')</code>","text":"<p>Record IOC Cameras</p>"},{"location":"beamline.html#mfx.beamline.ioc_cam_recorder--parameters","title":"Parameters","text":"<p>cam: str, required     Select camera PV you'd like to record</p> int, required <p>number of seconds for recording. 10 is default</p> str, required <p>Run group tag</p>"},{"location":"beamline.html#mfx.beamline.ioc_cam_recorder--operations","title":"Operations","text":"Source code in <code>mfx/autorun.py</code> <pre><code>def ioc_cam_recorder(cam='camera name', run_length=10, tag='?'):\n    \"\"\"\n    Record IOC Cameras\n\n    Parameters\n    ----------\n    cam: str, required\n        Select camera PV you'd like to record\n\n    run_length: int, required\n        number of seconds for recording. 10 is default\n\n    tag: str, required\n        Run group tag\n\n    Operations\n    ----------\n\n    \"\"\"\n    import subprocess\n    from epics import caget\n    import logging\n    from mfx.bash_utilities import bs\n    bs = bs()\n    camera_names = bs.camera_list_out()\n    if cam not in [pv[1] for pv in camera_names]:\n            logging.info(\"Desired Camera not in List. Please choose from the above list:.\")\n    else:\n        rate = caget(f'{cam}:ArrayRate_RBV')\n        n_images = int(run_length * rate)\n        logging.info(f\"Recording Camera {cam} for {run_length} sec\")\n        logging.info(\n            f\"/reg/g/pcds/engineering_tools/latest-released/scripts/image_saver -c {cam} -n {n_images} -f {tag} -p /cds/data/iocData\")\n\n        subprocess.Popen(\n            [f\"source /cds/group/pcds/pyps/conda/pcds_conda; /reg/g/pcds/engineering_tools/latest-released/scripts/image_saver -c {cam} -n {n_images} -f {tag} -p /cds/data/iocData\"],\n            shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.laser_in","title":"<code>laser_in(wait=False, timeout=10)</code>","text":"<p>Insert the Reference Laser and clear the beampath</p>"},{"location":"beamline.html#mfx.beamline.laser_in--parameters","title":"Parameters","text":"<p>wait: bool, optional     Wait and check that motion is properly completed</p> float, optional <p>Time to wait for motion completion if requested to do so</p>"},{"location":"beamline.html#mfx.beamline.laser_in--operations","title":"Operations","text":"<ul> <li>Insert the Reference Laser</li> <li>Set the Wave8 out (35 mm)</li> <li>Set the DG1 slits to 6 mm x 6 mm</li> <li>Set the DG2 upstream slits to 6 mm x 6 mm</li> <li>Set the DG2 midstream slits to 1 mm x 1 mm</li> <li>Set the DG2 downstream slits to 1 mm x 1 mm</li> </ul> Source code in <code>mfx/macros.py</code> <pre><code>def laser_in(wait=False, timeout=10):\n    \"\"\"\n    Insert the Reference Laser and clear the beampath\n\n    Parameters\n    ----------\n    wait: bool, optional\n        Wait and check that motion is properly completed\n\n    timeout: float, optional\n        Time to wait for motion completion if requested to do so\n\n    Operations\n    ----------\n    * Insert the Reference Laser\n    * Set the Wave8 out (35 mm)\n    * Set the DG1 slits to 6 mm x 6 mm\n    * Set the DG2 upstream slits to 6 mm x 6 mm\n    * Set the DG2 midstream slits to 1 mm x 1 mm\n    * Set the DG2 downstream slits to 1 mm x 1 mm\n    \"\"\"\n    # Command motion and collect status objects\n    ref = mfx_reflaser.insert(wait=False)\n    tfs = mfx_tfs.remove_all()\n    dg1_ipm=mfx_dg1_ipm.target.remove()\n    dg2_ipm=mfx_dg2_ipm.target.remove()\n    dg1 = mfx_dg1_slits.move(6., wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(6., wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(1., wait=False)\n#    dg2_ds = mfx_dg2_downstream_slits.move(1., wait=False)\n    # Combine status and wait for completion\n    if wait:\n        status_wait(ref &amp; dg1 &amp; dg2_us &amp; dg2_ms,\n                    timeout=timeout)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.laser_out","title":"<code>laser_out(wait=False, timeout=10)</code>","text":"<p>Remove the Reference Laser and configure the beamline</p>"},{"location":"beamline.html#mfx.beamline.laser_out--parameters","title":"Parameters","text":"<p>wait: bool, optional     Wait and check that motion is properly completed</p> float, optional <p>Time to wait for motion completion if requested to do so</p>"},{"location":"beamline.html#mfx.beamline.laser_out--operations","title":"Operations","text":"<ul> <li>Remove the Reference Laser</li> <li>Set the Wave8 Target 3 In (5.5 mm)</li> <li>Set the DG1 slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 upstream slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 midstream slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 downstream slits to 0.7 mm x 0.7 mm</li> </ul> Source code in <code>mfx/macros.py</code> <pre><code>def laser_out(wait=False, timeout=10):\n    \"\"\"\n    Remove the Reference Laser and configure the beamline\n\n    Parameters\n    ----------\n    wait: bool, optional\n        Wait and check that motion is properly completed\n\n    timeout: float, optional\n        Time to wait for motion completion if requested to do so\n\n    Operations\n    ----------\n    * Remove the Reference Laser\n    * Set the Wave8 Target 3 In (5.5 mm)\n    * Set the DG1 slits to 0.7 mm x 0.7 mm\n    * Set the DG2 upstream slits to 0.7 mm x 0.7 mm\n    * Set the DG2 midstream slits to 0.7 mm x 0.7 mm\n    * Set the DG2 downstream slits to 0.7 mm x 0.7 mm\n    \"\"\"\n    # Command motion and collect status objects\n    ref = mfx_reflaser.remove(wait=False)\n# Removing dg1 wave8 movement for now, until wave8 target positions have been fixed\n#    w8 = mfx_dg1_wave8_motor.move(5.5, wait=False)\n    dg1 = mfx_dg1_slits.move(0.7, wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(0.7, wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(0.7, wait=False)\n#    dg2_ds = mfx_dg2_downstream_slits.move(0.7, wait=False)\n    # Combine status and wait for completion\n    if wait:\n        status_wait(ref &amp; w8 &amp; dg1 &amp; dg2_us &amp; dg2_ms ,\n                    timeout=timeout)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.mfxslits","title":"<code>mfxslits(pos)</code>","text":"<p>Set all the slits to specific position</p> Source code in <code>mfx/macros.py</code> <pre><code>def mfxslits(pos):\n    \"\"\"Set all the slits to specific position\"\"\"\n    dg1 = mfx_dg1_slits.move(pos, wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(pos, wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(pos, wait=False)\n    dg2_ds = mfx_dg2_downstream_slits.move(pos, wait=False)\n</code></pre>"},{"location":"beamline.html#mfx.beamline.post","title":"<code>post(sample='?', tag=None, run_number=None, post=False, inspire=False, add_note='')</code>","text":"<p>Posts a message to the elog</p>"},{"location":"beamline.html#mfx.beamline.post--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> int, optional <p>Run Number. By default this is read off of the DAQ</p> bool, optional <p>set True to record/post message to elog</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> string, optional <p>adds additional note to elog message</p> Source code in <code>mfx/autorun.py</code> <pre><code>def post(sample='?', tag=None, run_number=None, post=False, inspire=False, add_note=''):\n    \"\"\"\n    Posts a message to the elog\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    run_number: int, optional\n        Run Number. By default this is read off of the DAQ\n\n    post: bool, optional\n        set True to record/post message to elog\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    add_note: string, optional\n        adds additional note to elog message \n    \"\"\"\n    from mfx.db import daq, elog\n    if add_note!='':\n        add_note = '\\n' + add_note\n    if tag is None:\n        tag = sample\n    if inspire:\n        comment = f\"Running {sample}\\n{quote()['quote']}{add_note}\"\n    else:\n        comment = f\"Running {sample}{add_note}\"\n    if run_number is None:\n        run_number = daq.run_number()\n    info = [run_number, comment]\n    post_msg = post_template.format(*info)\n    print('\\n' + post_msg + '\\n')\n    if post:\n        elog.post(msg=post_msg, tags=tag, run=(run_number))\n    return post_msg\n</code></pre>"},{"location":"beamline.html#mfx.beamline.xlj_fast_xyz","title":"<code>xlj_fast_xyz(orientation='horizontal', scale=0.1)</code>","text":""},{"location":"beamline.html#mfx.beamline.xlj_fast_xyz--parameters","title":"Parameters","text":"<p>orientation: str, optional     set orientation to change the x and y axis. horizontal by default     use only 'horizontal' of 'vertical'</p> float, optional <p>starting scale for the step size</p>"},{"location":"beamline.html#mfx.beamline.xlj_fast_xyz--operations","title":"Operations","text":"<p>Base function to control motors with the arrow keys.</p> <p>With three motors, you can use the right and left arrow keys to move right  and left, up and down arrow keys to move up and down, and Shift+up and  shift+down to move z in and out</p> <p>The scale for the tweak can be doubled by pressing + and halved by pressing -. Shift+right and shift+left can also be used, and the up and down keys will also adjust the scaling in one motor mode. The starting scale can be set with the keyword argument <code>scale</code>.</p> <p>Ctrl+c will stop an ongoing move during a tweak without exiting the tweak. Both q and ctrl+c will quit the tweak between moves.</p> Source code in <code>mfx/xlj_fast.py</code> <pre><code>def xlj_fast_xyz(orientation='horizontal', scale=0.1):\n    \"\"\"\n    Parameters\n    ----------\n    orientation: str, optional\n        set orientation to change the x and y axis. horizontal by default\n        use only 'horizontal' of 'vertical'\n\n    scale: float, optional\n        starting scale for the step size\n\n    Operations\n    ----------\n    Base function to control motors with the arrow keys.\n\n    With three motors, you can use the right and left arrow keys to move right \n    and left, up and down arrow keys to move up and down, and Shift+up and \n    shift+down to move z in and out\n\n    The scale for the tweak can be doubled by pressing + and halved by pressing\n    -. Shift+right and shift+left can also be used, and the up and down keys will\n    also adjust the scaling in one motor mode. The starting scale can be set\n    with the keyword argument `scale`.\n\n    Ctrl+c will stop an ongoing move during a tweak without exiting the tweak.\n    Both q and ctrl+c will quit the tweak between moves.\n    \"\"\"\n\n    if orientation == str('horizontal').lower():\n        xlj_fast_x = BypassPositionCheck(\"MFX:LJH:JET:X\", name=\"xlj_fast_x\")\n        xlj_fast_y = BypassPositionCheck(\"MFX:LJH:JET:Y\", name=\"xlj_fast_y\")\n\n    if orientation == str('vertical').lower():\n        xlj_fast_y = BypassPositionCheck(\"MFX:LJH:JET:X\", name=\"xlj_fast_x\")\n        xlj_fast_x = BypassPositionCheck(\"MFX:LJH:JET:Y\", name=\"xlj_fast_y\")\n\n    xlj_fast_z = BypassPositionCheck(\"MFX:LJH:JET:Z\", name=\"xlj_fast_z\")\n\n    xlj = BeckhoffJet('MFX:LJH', name='xlj')\n\n    up = \"\\x1b[A\"\n    down = \"\\x1b[B\"\n    right = \"\\x1b[C\"\n    left = \"\\x1b[D\"\n    shift_up = \"\\x1b[1;2A\"\n    shift_down = \"\\x1b[1;2B\"\n    shift_right = \"\\x1b[1;2C\"\n    shift_left = \"\\x1b[1;2D\"\n    alt_up = \"\\x1b[1;3A\"\n    alt_down = \"\\x1b[1;3B\"\n    alt_right = \"\\x1b[1;3C\"\n    alt_left = \"\\x1b[1;3D\"\n    ctrl_up = \"\\x1b[1;5A\"\n    ctrl_down = \"\\x1b[1;5B\"\n    ctrl_right = \"\\x1b[1;5C\"\n    ctrl_left = \"\\x1b[1;5D\"\n    plus = \"+\"\n    equal = \"=\"\n    minus = \"-\"\n    under = \"_\"\n\n    abs_status = '{}: {:.4f}'\n    exp_status = '{}: {:.4e}'\n\n    move_keys = (left, right, up, down, shift_up, shift_down)\n    scale_keys = (plus, minus, equal, under, shift_right, shift_left)\n    motors = [xlj_fast_x, xlj_fast_y, xlj_fast_z]\n\n\n    def show_status():\n        if scale &gt;= 0.0001:\n            template = abs_status\n        else:\n            template = exp_status\n        text = [template.format(mot.name, mot.wm()) for mot in motors]\n        text.append(f'scale: {scale}')\n        print('\\x1b[2K\\r' + ', '.join(text), end='')\n\n\n    def usage():\n        print()  # Newline\n        print(\" Left: move x motor left\")\n        print(\" Right: move x motor right\")\n        print(\" Down: move y motor down\")\n        print(\" Up: move y motor up\")\n        print(\" shift+up: Z upstream\")\n        print(\" shift+down: Z downstream\")\n        print(\" + or shift+right: scale*2\")\n        print(\" - or shift+left: scale/2\")\n        print(\" Press q to quit.\"\n              \" Press any other key to display this message.\")\n        print()  # Newline\n\n\n    def edit_scale(scale, direction):\n        \"\"\"Function used to change the scale.\"\"\"\n        if direction in (up, shift_right, plus, equal):\n            scale = scale*2\n        elif direction in (down, shift_left, minus, under):\n            scale = scale/2\n        return scale\n\n\n    def movement(scale, direction):\n        \"\"\"Function used to know when and the direction to move the motor.\"\"\"\n        try:\n            if direction == left:\n                if round(xlj.jet.x(), 2) != round(xlj_fast_x(), 2):\n                    logger.error(f'xlj.jet.x = {xlj.jet.x()}, xlj_fast_x = {xlj_fast_x()}')\n                    xlj_fast_x.umv(xlj.jet.x())\n                xlj_fast_x.umvr(-scale, log=False, newline=False)\n            elif direction == right:\n                if round(xlj.jet.x(), 2) != round(xlj_fast_x(), 2):\n                    logger.error(f'xlj.jet.x = {xlj.jet.x()}, xlj_fast_x = {xlj_fast_x()}')\n                    xlj_fast_x.umv(xlj.jet.x())\n                xlj_fast_x.umvr(scale, log=False, newline=False)\n            elif direction == up:\n                if round(xlj.jet.y(), 2) != round(xlj_fast_y(), 2):\n                    logger.error(f'xlj.jet.y = {xlj.jet.y()}, xlj_fast_y = {xlj_fast_y()}')\n                    xlj_fast_y.umv(xlj.jet.y())\n                xlj_fast_y.umvr(scale, log=False, newline=False)\n            elif direction == down:\n                if round(xlj.jet.y(), 2) != round(xlj_fast_y(), 2):\n                    logger.error(f'xlj.jet.y = {xlj.jet.y()}, xlj_fast_y = {xlj_fast_y()}')\n                    xlj_fast_y.umv(xlj.jet.y())\n                xlj_fast_y.umvr(-scale, log=False, newline=False)\n            elif direction == shift_up:\n                if round(xlj.jet.z(), 2) != round(xlj_fast_z(), 2):\n                    logger.error(f'xlj.jet.z = {xlj.jet.z()}, xlj_fast_z = {xlj_fast_z()}')\n                    xlj_fast_z.umv(xlj.jet.z())\n                xlj_fast_z.umvr(-scale, log=False, newline=False)\n            elif direction == shift_down:\n                if round(xlj.jet.z(), 2) != round(xlj_fast_z(), 2):\n                    logger.error(f'xlj.jet.z = {xlj.jet.z()}, xlj_fast_z = {xlj_fast_z()}')\n                    xlj_fast_z.umv(xlj.jet.z())\n                xlj_fast_z.umvr(scale, log=False, newline=False)\n        except Exception as exc:\n            logger.error('Error in tweak move: %s', exc)\n            logger.debug('', exc_info=True)\n\n    start_text = [f'{mot.name} at {mot.wm():.4f}' for mot in motors]\n    logger.info('Started tweak of ' + ', '.join(start_text))\n    usage()\n\n    # Loop takes in user key input and stops when 'q' is pressed\n    is_input = True\n    while is_input is True:\n        show_status()\n        inp = utils.get_input()\n        if inp in ('q'):\n            is_input = False\n        elif inp in move_keys:\n            movement(scale, inp)\n        elif inp in scale_keys:\n            scale = edit_scale(scale, inp)\n        elif inp in ('h'):\n            usage()\n        else:\n            logger.error('Not the way to use this. Press \"h\" to see how.')\n    print()\n    logger.info('Tweak complete')\n</code></pre>"},{"location":"cctbx.html","title":"Cctbx","text":""},{"location":"cctbx.html#mfx.cctbx.cctbx","title":"<code>cctbx</code>","text":"Source code in <code>mfx/cctbx.py</code> <pre><code>class cctbx:\n    def __init__(self):\n        from mfx.macros import get_exp\n        self.experiment = str(get_exp())\n\n\n    def geom_refine(\n        self,\n        user: str,\n        group: str,\n        level: int = None,\n        facility: str = \"NERSC\",\n        exp: str = ''):\n        \"\"\"Launch CCTBX XFEL GUI.\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            group (str): the trial and rungroup number in the format 000_rg005.\n            Default is newest trial_rungroup\n\n            level (int): the level of geometry refinement.\n            0 = whole detector and 1 = individual detector panels.\n            Default is to systematically do both.\n\n            facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n            exp (str): experiment number in format 'mfxp1047723'.\n                       If none selected default is the current experiment.\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n\n        if exp != '':\n            experiment = exp\n        else:\n            experiment = self.experiment\n\n        proc = [\n            f\"ssh -Yt {user}@s3dflogin \"\n            f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/geom_refine.py \"\n            f\"-e {experiment} -f {facility} -g {group} -l {level} \"\n            ]\n\n        logging.info(proc)\n\n        if facility == 'NERSC':\n            logging.warning(f\"Have you renewed your token with sshproxy today?\")\n            token = input(\"(y/n)? \")\n\n            if token.lower() == \"n\":\n                self.sshproxy(user)\n\n        os.system(proc[0])\n\n\n    def average(\n        self,\n        user: str,\n        run: int,\n        facility: str = \"NERSC\",\n        exp: str = '',\n        debug: bool = False):\n        \"\"\"Launch CCTBX XFEL GUI.\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            run (int): Enter -r for the run number\n\n            facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n            exp (str): experiment number in format 'mfxp1047723'.\n                       If none selected default is the current experiment.\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n        import subprocess\n\n        if exp != '':\n            experiment = exp\n        else:\n            experiment = self.experiment\n\n        proc = [\n            f\"ssh -Yt {user}@s3dflogin \"\n            f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/average.py \"\n            f\"-e {experiment} -f {facility} -d {str(debug)} -r {run}\"\n            ]\n\n        logging.info(proc)\n\n        if facility == 'NERSC':\n            logging.warning(f\"Have you renewed your token with sshproxy today?\")\n            token = input(\"(y/n)? \")\n\n            if token.lower() == \"n\":\n                self.sshproxy(user)\n\n        if debug:\n            os.system(proc[0])\n        else:\n            subprocess.Popen(\n                proc, shell=True,\n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n\n    def image_viewer(\n        self,\n        user: str,\n        run: int,\n        image_type: str,\n        group: str = None,\n        facility: str = \"NERSC\",\n        exp: str = '',\n        debug: bool = False):\n        \"\"\"Launch CCTBX XFEL GUI.\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            run (int): Enter -r for the run number\n\n            image_type (str): Enter -t for type of image view\n\n            group (str): the trial and rungroup number in the format 000_rg005.\n            Default is newest trial_rungroup\n\n            facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n            exp (str): experiment number in format 'mfxp1047723'.\n                       If none selected default is the current experiment.\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n        import subprocess\n\n        if exp != '':\n            experiment = exp\n        else:\n            experiment = self.experiment\n\n        proc = [\n            f\"ssh -Yt {user}@s3dflogin \"\n            f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/image_viewer.py \"\n            f\"-e {experiment} -f {facility} -d {str(debug)} -t {image_type} -r {run} -g {group}\"\n            ]\n\n        logging.info(proc)\n\n        if facility == 'NERSC':\n            logging.warning(f\"Have you renewed your token with sshproxy today?\")\n            token = input(\"(y/n)? \")\n\n            if token.lower() == \"n\":\n                self.sshproxy(user)\n\n        if debug:\n            os.system(proc[0])\n        else:\n            subprocess.Popen(\n                proc, shell=True,\n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n\n    def sshproxy(\n        self,\n        user: str,\n    ):\n\n        \"\"\"Launch sshproxy check for getting NERSC token if needed\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n        import subprocess\n        logging.info(f\"Creating new sshproxy token for {user}.\")\n        proc = [\n            f\"ssh -Yt {user}@s3dflogin \"\n            f\"/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/sshproxy.sh \"\n            f\"-c cctbx -u {user}\"\n            ]\n\n        logging.info(proc)\n\n        os.system(proc[0])\n\n\n    def xfel_gui(\n        self,\n        user: str,\n        facility: str = \"NERSC\",\n        exp: str  = '',\n        debug: bool = False,\n    ):\n        \"\"\"Launch CCTBX XFEL GUI.\n\n        Parameters:\n\n            user (str): username for computer account at facility.\n\n            facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n            exp (str): experiment number in format 'mfxp1047723'.\n                       If none selected default is the current experiment.\n\n            debug (bool): Default: False.\n        \"\"\"\n        import logging\n        import os\n        import subprocess\n\n        if exp != '':\n            experiment = exp\n        else:\n            experiment = self.experiment\n\n        proc = [\n            f\"ssh -Yt {user}@s3dflogin \"\n            f\"/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/cctbx.sh \"\n            f\"{user} {experiment} {facility} 1 {str(debug)} \"\n            ]\n\n        logging.info(proc)\n\n        if facility == 'NERSC':\n            logging.warning(f\"Have you renewed your token with sshproxy today?\")\n            token = input(\"(y/n)? \")\n\n            if token.lower() == \"n\":\n                self.sshproxy(user)\n\n        if debug:\n            os.system(proc[0])\n        else:\n            subprocess.Popen(\n                proc, shell=True,\n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n\n    def notch_check(self, user, runs=[]):\n        import logging\n        import subprocess\n        import sys\n        if len(runs) &gt; 0:\n            run_list = []\n            for run in runs:\n                run_list.append(f'{experiment}:{run}')\n            logging.info(f'Selected runs: {run_list}')\n            runlist = ' '\n            runlist = runlist.join(run_list)\n            logging.info(f'Selected runs: {runlist}')\n        else:\n            logging.warning(f'No selected runs. Program will exit.')\n            sys.exit()\n\n        proc = [\n            f'ssh -YAC {user}@s3dflogin '\n            f'/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/cctbx_notch_check.sh \"{self.runlist}\"'\n            ]\n\n        logging.info(proc)\n\n        subprocess.Popen(\n            proc, shell=True, \n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"cctbx.html#mfx.cctbx.cctbx.average","title":"<code>average(user, run, facility='NERSC', exp='', debug=False)</code>","text":"<p>Launch CCTBX XFEL GUI.</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\nrun (int): Enter -r for the run number\n\nfacility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\nexp (str): experiment number in format 'mfxp1047723'.\n           If none selected default is the current experiment.\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/cctbx.py</code> <pre><code>def average(\n    self,\n    user: str,\n    run: int,\n    facility: str = \"NERSC\",\n    exp: str = '',\n    debug: bool = False):\n    \"\"\"Launch CCTBX XFEL GUI.\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        run (int): Enter -r for the run number\n\n        facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n        exp (str): experiment number in format 'mfxp1047723'.\n                   If none selected default is the current experiment.\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n    import subprocess\n\n    if exp != '':\n        experiment = exp\n    else:\n        experiment = self.experiment\n\n    proc = [\n        f\"ssh -Yt {user}@s3dflogin \"\n        f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/average.py \"\n        f\"-e {experiment} -f {facility} -d {str(debug)} -r {run}\"\n        ]\n\n    logging.info(proc)\n\n    if facility == 'NERSC':\n        logging.warning(f\"Have you renewed your token with sshproxy today?\")\n        token = input(\"(y/n)? \")\n\n        if token.lower() == \"n\":\n            self.sshproxy(user)\n\n    if debug:\n        os.system(proc[0])\n    else:\n        subprocess.Popen(\n            proc, shell=True,\n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"cctbx.html#mfx.cctbx.cctbx.geom_refine","title":"<code>geom_refine(user, group, level=None, facility='NERSC', exp='')</code>","text":"<p>Launch CCTBX XFEL GUI.</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\ngroup (str): the trial and rungroup number in the format 000_rg005.\nDefault is newest trial_rungroup\n\nlevel (int): the level of geometry refinement.\n0 = whole detector and 1 = individual detector panels.\nDefault is to systematically do both.\n\nfacility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\nexp (str): experiment number in format 'mfxp1047723'.\n           If none selected default is the current experiment.\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/cctbx.py</code> <pre><code>def geom_refine(\n    self,\n    user: str,\n    group: str,\n    level: int = None,\n    facility: str = \"NERSC\",\n    exp: str = ''):\n    \"\"\"Launch CCTBX XFEL GUI.\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        group (str): the trial and rungroup number in the format 000_rg005.\n        Default is newest trial_rungroup\n\n        level (int): the level of geometry refinement.\n        0 = whole detector and 1 = individual detector panels.\n        Default is to systematically do both.\n\n        facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n        exp (str): experiment number in format 'mfxp1047723'.\n                   If none selected default is the current experiment.\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n\n    if exp != '':\n        experiment = exp\n    else:\n        experiment = self.experiment\n\n    proc = [\n        f\"ssh -Yt {user}@s3dflogin \"\n        f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/geom_refine.py \"\n        f\"-e {experiment} -f {facility} -g {group} -l {level} \"\n        ]\n\n    logging.info(proc)\n\n    if facility == 'NERSC':\n        logging.warning(f\"Have you renewed your token with sshproxy today?\")\n        token = input(\"(y/n)? \")\n\n        if token.lower() == \"n\":\n            self.sshproxy(user)\n\n    os.system(proc[0])\n</code></pre>"},{"location":"cctbx.html#mfx.cctbx.cctbx.image_viewer","title":"<code>image_viewer(user, run, image_type, group=None, facility='NERSC', exp='', debug=False)</code>","text":"<p>Launch CCTBX XFEL GUI.</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\nrun (int): Enter -r for the run number\n\nimage_type (str): Enter -t for type of image view\n\ngroup (str): the trial and rungroup number in the format 000_rg005.\nDefault is newest trial_rungroup\n\nfacility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\nexp (str): experiment number in format 'mfxp1047723'.\n           If none selected default is the current experiment.\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/cctbx.py</code> <pre><code>def image_viewer(\n    self,\n    user: str,\n    run: int,\n    image_type: str,\n    group: str = None,\n    facility: str = \"NERSC\",\n    exp: str = '',\n    debug: bool = False):\n    \"\"\"Launch CCTBX XFEL GUI.\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        run (int): Enter -r for the run number\n\n        image_type (str): Enter -t for type of image view\n\n        group (str): the trial and rungroup number in the format 000_rg005.\n        Default is newest trial_rungroup\n\n        facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n        exp (str): experiment number in format 'mfxp1047723'.\n                   If none selected default is the current experiment.\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n    import subprocess\n\n    if exp != '':\n        experiment = exp\n    else:\n        experiment = self.experiment\n\n    proc = [\n        f\"ssh -Yt {user}@s3dflogin \"\n        f\"python /sdf/group/lcls/ds/tools/mfx/scripts/cctbx/image_viewer.py \"\n        f\"-e {experiment} -f {facility} -d {str(debug)} -t {image_type} -r {run} -g {group}\"\n        ]\n\n    logging.info(proc)\n\n    if facility == 'NERSC':\n        logging.warning(f\"Have you renewed your token with sshproxy today?\")\n        token = input(\"(y/n)? \")\n\n        if token.lower() == \"n\":\n            self.sshproxy(user)\n\n    if debug:\n        os.system(proc[0])\n    else:\n        subprocess.Popen(\n            proc, shell=True,\n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"cctbx.html#mfx.cctbx.cctbx.sshproxy","title":"<code>sshproxy(user)</code>","text":"<p>Launch sshproxy check for getting NERSC token if needed</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/cctbx.py</code> <pre><code>def sshproxy(\n    self,\n    user: str,\n):\n\n    \"\"\"Launch sshproxy check for getting NERSC token if needed\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n    import subprocess\n    logging.info(f\"Creating new sshproxy token for {user}.\")\n    proc = [\n        f\"ssh -Yt {user}@s3dflogin \"\n        f\"/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/sshproxy.sh \"\n        f\"-c cctbx -u {user}\"\n        ]\n\n    logging.info(proc)\n\n    os.system(proc[0])\n</code></pre>"},{"location":"cctbx.html#mfx.cctbx.cctbx.xfel_gui","title":"<code>xfel_gui(user, facility='NERSC', exp='', debug=False)</code>","text":"<p>Launch CCTBX XFEL GUI.</p> <p>Parameters:</p> <pre><code>user (str): username for computer account at facility.\n\nfacility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\nexp (str): experiment number in format 'mfxp1047723'.\n           If none selected default is the current experiment.\n\ndebug (bool): Default: False.\n</code></pre> Source code in <code>mfx/cctbx.py</code> <pre><code>def xfel_gui(\n    self,\n    user: str,\n    facility: str = \"NERSC\",\n    exp: str  = '',\n    debug: bool = False,\n):\n    \"\"\"Launch CCTBX XFEL GUI.\n\n    Parameters:\n\n        user (str): username for computer account at facility.\n\n        facility (str): Default: \"NERSC\". Options: \"S3DF, NERSC\".\n\n        exp (str): experiment number in format 'mfxp1047723'.\n                   If none selected default is the current experiment.\n\n        debug (bool): Default: False.\n    \"\"\"\n    import logging\n    import os\n    import subprocess\n\n    if exp != '':\n        experiment = exp\n    else:\n        experiment = self.experiment\n\n    proc = [\n        f\"ssh -Yt {user}@s3dflogin \"\n        f\"/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/cctbx.sh \"\n        f\"{user} {experiment} {facility} 1 {str(debug)} \"\n        ]\n\n    logging.info(proc)\n\n    if facility == 'NERSC':\n        logging.warning(f\"Have you renewed your token with sshproxy today?\")\n        token = input(\"(y/n)? \")\n\n        if token.lower() == \"n\":\n            self.sshproxy(user)\n\n    if debug:\n        os.system(proc[0])\n    else:\n        subprocess.Popen(\n            proc, shell=True,\n            stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"cctbx_start.html","title":"Cctbx start","text":"<p>cctbx_start</p>"},{"location":"cctbx_start.html#scripts.cctbx.cctbx_start.main","title":"<code>main(args)</code>","text":"<p>Main entry point allowing external calls Entry point for console_scripts Args:   args ([str]): command line parameter list</p> Source code in <code>scripts/cctbx/cctbx_start.py</code> <pre><code>def main(args):\n    \"\"\"\n    Main entry point allowing external calls\n    Entry point for console_scripts\n    Args:\n      args ([str]): command line parameter list\n    \"\"\"\n    args = parse_args(args)\n    user = args.username\n    exp = args.experiment\n    facility = args.facility\n    debug = bool(args.debug)\n    step = args.step\n\n    if int(step) == 1:\n\n        logging.info(\"Starting up cctbx\")\n\n        if facility == \"S3DF\":\n            proc = [\n                f\"ssh -YAC psana \"\n                f\"/sdf/group/lcls/ds/tools/mfx/scripts/cctbx/cctbx.sh \"\n                f\"{user} {exp} {facility} 2 {str(debug)}\"\n            ]\n        elif facility == \"NERSC\":\n            proc = [\n                f\"ssh -i ~/.ssh/cctbx -YAC cctbx@perlmutter-p1.nersc.gov \"\n                f\"/global/common/software/lcls/mfx/scripts/cctbx/cctbx.sh \"\n                f\"{user} {exp} {facility} 2 {str(debug)}\"\n            ]\n\n        logging.info(proc)\n        if debug:\n            os.system(proc[0])\n        else:\n            subprocess.Popen(\n                proc, shell=True,\n                stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n\n    else:\n\n        if facility == \"NERSC\":\n            cctbx_dir = f\"/global/homes/c/cctbx/.cctbx.xfel\"\n        elif facility == \"S3DF\":\n            cctbx_dir = f\"/sdf/home/{user[0]}/{user}/.cctbx.xfel\"\n        else:\n            cctbx_dir = None\n            logging.warning(f\"Facility not found: {facility}\")\n\n        if cctbx_dir is not None:\n            if not os.path.exists(cctbx_dir):\n                os.makedirs(cctbx_dir)\n\n            check_settings(exp, facility, cctbx_dir)\n</code></pre>"},{"location":"cctbx_start.html#scripts.cctbx.cctbx_start.parse_args","title":"<code>parse_args(args)</code>","text":"<p>Parse command line parameters</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>[str]</code> <p>command line parameters as list of strings</p> required <p>Returns:</p> Type Description <p>obj:<code>argparse.Namespace</code>: command line parameters namespace</p> Source code in <code>scripts/cctbx/cctbx_start.py</code> <pre><code>def parse_args(args):\n    \"\"\"Parse command line parameters\n\n    Args:\n      args ([str]): command line parameters as list of strings\n\n    Returns:\n      :obj:`argparse.Namespace`: command line parameters namespace\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"startup script for cctbx on iana.\"\n    )\n    parser.add_argument(\n        \"--username\",\n        \"-u\",\n        dest=\"username\",\n        default=None,\n        help=\"Enter -u to specify username\",\n    )\n    parser.add_argument(\n        \"--experiment\",\n        \"-e\",\n        dest=\"experiment\",\n        default=None,\n        help=\"Enter -e to specify experiment number\",\n    )\n    parser.add_argument(\n        \"--facility\",\n        \"-f\",\n        dest=\"facility\",\n        default=None,\n        help=\"Enter -f to specify facility\",\n    )\n    parser.add_argument(\n        \"--debug\",\n        \"-d\",\n        dest=\"debug\",\n        default=str(False),\n        help=\"Enter -d to set debugging mode\",\n    )\n    parser.add_argument(\n        \"--step\",\n        \"-s\",\n        dest=\"step\",\n        default=None,\n        help=\"Enter -s to setup step\",\n    )\n\n    return parser.parse_args(args)\n</code></pre>"},{"location":"cctbx_start.html#scripts.cctbx.cctbx_start.run","title":"<code>run()</code>","text":"<p>Entry point for console_scripts</p> Source code in <code>scripts/cctbx/cctbx_start.py</code> <pre><code>def run():\n    \"\"\"Entry point for console_scripts\"\"\"\n    main(sys.argv[1:])\n</code></pre>"},{"location":"codi.html","title":"Codi","text":""},{"location":"codi.html#dod.codi.CoDI","title":"<code>CoDI</code>","text":"Source code in <code>dod/codi.py</code> <pre><code>class CoDI: \n    def __init__(self, reload_presets = False):\n        \"\"\"\n        Class definition of the DoD codi injector \n        Parameters\n        reload_presets : Boolean\n            force resetting the presets (overwriting existing hutch presets)\n        ----------\n        \"\"\"\n\n        from pcdsdevices.device import ObjectComponent as OCpt\n        from pcdsdevices.epics_motor import SmarAct, Motor\n        import time\n\n        # CoDI motor PVs loading \n        self.CoDI_rot_left = SmarAct('MFX:MCS2:01:m3', name='CoDI_rot_left')\n        self.CoDI_rot_right = SmarAct('MFX:MCS2:01:m1', name='CoDI_rot_right')\n        self.CoDI_rot_base = SmarAct('MFX:MCS2:01:m2', name='CoDI_rot_base')\n        self.CoDI_trans_z = SmarAct('MFX:MCS2:01:m4', name='CoDI_trans_z')\n\n        #Predefined positions CoDI\n        self.CoDI_pos_predefined = dict()\n\n        if reload_presets == True: \n            # self.CoDI_pos_predefined['aspiration'] = (0.0,0.0,0.0,0.0) \n            # self.CoDI_pos_predefined['angled_vert'] = (0.0,45.0,45.0,0.0)\n            # self.CoDI_pos_predefined['angled_hor'] = (90.0,45.0,45.0,0.0)\n\n            self.set_CoDI_predefined('aspiration',0.0,0.0,0.0,0.0)\n            self.set_CoDI_predefined('angled_vert',0.0,45.0,45.0,0.0)\n            self.set_CoDI_predefined('angled_hor',90.0,45.0,45.0,0.0)\n        else: \n            all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n            for preset, preset_value in all_presets.items(): \n                try: \n                    # get preset position\n                    exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n                    exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n                    exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n                    exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n                    exec(exec_base)\n                    exec(exec_rot_left)\n                    exec(exec_rot_right)\n                    exec(exec_trans_z)\n\n                    # Save to local database\n                    print(preset)\n                    self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n                except: \n                    print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n\n        # # create config parser handler\n        # json_handler = JsonFileHandler(supported_json)\n        # # load configs and launch web server\n        # json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n\n\n    def get_CoDI_predefined(self):\n\n\n        return self.CoDI_pos_predefined\n\n\n    def update_CoDI_predefined(self): \n        'reloads all the hutch python presets for motors and overwrites local position preset dict'\n\n        #Predefined positions CoDI\n        self.CoDI_pos_predefined = dict()\n\n        all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n        for preset in all_presets.keys(): \n            # try: \n            # get preset position\n            self.exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n            self.exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n            self.exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n            self.exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n            print(self.exec_base)\n            exec(self.exec_base)\n\n            exec(self.exec_rot_left)\n            print(self.exec_rot_left)\n\n            exec(self.exec_rot_right)\n            print(self.exec_rot_left)\n\n            exec(self.exec_trans_z)\n            print(self.exec_trans_z)\n            print(preset_trans_z)\n\n            # Save to local database\n            print(preset)\n            self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n            # except: \n            #     print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n    def set_CoDI_predefined(self, name, base, left, right, z):\n        \"\"\"\n        defines or updates a predefined combination for CoDI\n\n        Parameters\n        name : str\n            name of the pre-definition\n        base : float\n            rotation of base\n        left : float\n            rotation of left injector\n        right : float\n            rotation of right injector\n        z : float\n            translation of right injector\n        ----------\n\n        \"\"\"\n        self.CoDI_pos_predefined.update({name: (base,left, right, z)})\n\n        # Presets using MFX presets functionalities \n        self.CoDI_rot_left.presets.add_hutch(name, value = left)\n        self.CoDI_rot_right.presets.add_hutch(name, value = right)\n        self.CoDI_rot_base.presets.add_hutch(name, value = base)\n        self.CoDI_trans_z.presets.add_hutch(name, value = z)\n\n\n\n    def get_CoDI_pos(self, precision_digits = 1): \n        \"\"\"\n        gets the colliding droplet injector motor positions as tuple\n\n        Parameters\n        precision_digits : int\n            precision with which the pre-defined positions are checked \n\n        ----------\n        Return : (tuple, 5)\n            motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)\n        \"\"\"\n        pos_rot_base  = self.CoDI_rot_base.wm()\n        pos_rot_left  = self.CoDI_rot_left.wm()\n        pos_rot_right = self.CoDI_rot_right.wm()\n        pos_trans_z   = self.CoDI_trans_z.wm()\n\n        # # for testing purposes\n        # pos_rot_base  = 0\n        # pos_rot_left  = 45\n        # pos_rot_right = 45\n        # pos_trans_z   = 0\n\n        pos_tuple = (pos_rot_base,pos_rot_left, pos_rot_right,pos_trans_z)\n\n        pos_rounded = tuple([float(round(each_pos,1)) for each_pos in pos_tuple])\n\n        # Test if this is one of the preset positions: \n        pos_name = 'undefined'\n        for preset in self.CoDI_pos_predefined:\n            preset_rounded = tuple([float(round(each_pos,1)) for each_pos in self.CoDI_pos_predefined[preset]])\n            if preset_rounded[:-1] == pos_rounded[:-1]: \n                pos_name = preset\n\n        return pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z\n\n\n    def set_CoDI_pos(self, pos_name, wait = True): \n        \"\"\"\n        Moves the colliding droplet injector into a pre-defined position. \n\n        Parameters\n        pos_name : string\n            name of the pre-defined position\n        wait : boolean\n            if the robot waits before continuing further steps\n\n        ----------\n        Return : \n\n        \"\"\"\n        # pos_rot_base  = CoDI_base.wm()\n        # pos_rot_left  = CoDI_left.wm()\n        # pos_rot_right = CoDI_right.wm()\n        # pos_trans_z   = CoDI_z.wm()\n        import time\n\n        # get target positions\n        pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[pos_name]\n\n        # Move motors\n\n        # Old wayy \n        # self.CoDI_rot_base.mv(pos_rot_base, wait=False)\n        # self.CoDI_rot_left.mv(pos_rot_left,  wait=False)\n        # self.CoDI_rot_right.mv(pos_rot_right, wait=False)\n        # self.CoDI_trans_z.mv(pos_trans_z, wait=False)\n\n        # Move using hutch python presets\n        exec_base = \"self.CoDI_rot_base.mv_\" + pos_name + '()'\n        exec(exec_base)\n        exec_left = \"self.CoDI_rot_left.mv_\" + pos_name + '()'\n        exec(exec_left)\n        exec_right = \"self.CoDI_rot_right.mv_\" + pos_name + '()'\n        exec(exec_right)\n        exec_z = \"self.CoDI_trans_z.mv_\" + pos_name + '()'\n        exec(exec_z)\n\n        if wait == True: \n            test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n            i = 0\n            while pos_name != test_name: \n                time.sleep(1)\n                print('\\r waiting for motion to end: %i s' %i, end=\"\\r\")\n                i = i+1\n                test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n            print('Motion ended')\n\n\n    def set_CoDI_current_pos(self, name):\n        \"\"\"\n        defines or updates the current motor combination for CoDI\n\n        Parameters\n        name : str\n            name of the pre-definition\n        ----------\n\n        \"\"\"\n        pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.get_CoDI_pos()\n        self.set_CoDI_predefined(name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z)\n\n\n    def set_CoDI_current_z(self, verbose = True):\n        \"\"\"\n        sets the current z position to all preloaded positions\n        Useful for global change of z after aligning\n\n        Parameters\n        verbose : Boolean\n            prints the new positions as a sanity check if True\n        ----------\n\n        \"\"\"\n        # get current z position:\n        pos_trans_z_new  = self.CoDI_trans_z.wm()\n\n        # get all keys from the positions\n        position_keys = self.CoDI_pos_predefined.keys\n\n        #go through all positions and change the z-value to the current z value\n        for key in position_keys: \n            pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[key]\n            self.set_CoDI_predefined(pos_name,pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z_new)\n\n        #Print the new predefined positions as a sanity check\n        if verbose == True:\n            print(self.get_CoDI_predefined)\n\n\n    def remove_CoDI_pos(self, name):\n        \"\"\"\n        removes the defined motor combination for CoDI from local database\n\n        Parameters\n        name : str\n            name of the pre-definition to be deleted\n        ----------\n\n        \"\"\"\n        del self.CoDI_pos_predefined[name]\n\n\n    def move_z_rel(self, z_rel):\n        \"\"\"\n        moves the z position relative to the current position \n\n        Parameters\n        z_rel : float\n            relative motion in mm\n        ----------\n\n        \"\"\"\n        # get current z position:\n        pos_trans_z  = self.CoDI_trans_z.wm()\n\n        # set new position\n        self.CoDI_trans_z.umvr(z_rel)\n\n    def move_rot_left_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the left nozzle relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_left  = self.CoDI_rot_left.wm()\n\n        # set new position: \n        self.CoDI_rot_left.umvr(rot_rel)\n\n\n    def move_rot_right_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the right nozzle relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_right  = self.CoDI_rot_right.wm()\n\n        # set new position: \n        self.CoDI_rot_right.umvr(rot_rel)\n\n\n    def move_rot_base_rel(self, rot_rel):\n        \"\"\"\n        moves the rotation of the base relative to the current position in degree\n\n        Parameters\n        rot_rel : float\n            relative motion in degree\n        ----------\n\n        \"\"\"\n        # get current position:\n        pos_rot_base  = self.CoDI_rot_base.wm()\n\n        # set new position: \n        self.CoDI_rot_base.umvr(rot_rel)\n\n\n    def move_z_abs(self, z_abs):\n        \"\"\"\n        moves the z position to the absolute position in mm\n\n        Parameters\n        z_abs : float\n            absolute motion in mm\n        ----------\n\n        \"\"\"\n        # move z position:\n        self.CoDI_trans_z.umv(z_abs)\n\n\n    def move_rot_left_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the left nozzle to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_left.umv(rot_abs)\n\n\n    def move_rot_right_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the right nozzle to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_right.umv(rot_abs)\n\n\n    def move_rot_base_abs(self, rot_abs):\n            \"\"\"\n            moves the rotation of the base to the absolute position in degree\n\n            Parameters\n            rot_abs : float\n                abs motion in degree\n            ----------\n\n            \"\"\"\n\n            # set new position: \n            self.CoDI_rot_base.umv(rot_abs)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.__init__","title":"<code>__init__(reload_presets=False)</code>","text":"<p>Class definition of the DoD codi injector  Parameters reload_presets : Boolean     force resetting the presets (overwriting existing hutch presets)</p> Source code in <code>dod/codi.py</code> <pre><code>def __init__(self, reload_presets = False):\n    \"\"\"\n    Class definition of the DoD codi injector \n    Parameters\n    reload_presets : Boolean\n        force resetting the presets (overwriting existing hutch presets)\n    ----------\n    \"\"\"\n\n    from pcdsdevices.device import ObjectComponent as OCpt\n    from pcdsdevices.epics_motor import SmarAct, Motor\n    import time\n\n    # CoDI motor PVs loading \n    self.CoDI_rot_left = SmarAct('MFX:MCS2:01:m3', name='CoDI_rot_left')\n    self.CoDI_rot_right = SmarAct('MFX:MCS2:01:m1', name='CoDI_rot_right')\n    self.CoDI_rot_base = SmarAct('MFX:MCS2:01:m2', name='CoDI_rot_base')\n    self.CoDI_trans_z = SmarAct('MFX:MCS2:01:m4', name='CoDI_trans_z')\n\n    #Predefined positions CoDI\n    self.CoDI_pos_predefined = dict()\n\n    if reload_presets == True: \n        # self.CoDI_pos_predefined['aspiration'] = (0.0,0.0,0.0,0.0) \n        # self.CoDI_pos_predefined['angled_vert'] = (0.0,45.0,45.0,0.0)\n        # self.CoDI_pos_predefined['angled_hor'] = (90.0,45.0,45.0,0.0)\n\n        self.set_CoDI_predefined('aspiration',0.0,0.0,0.0,0.0)\n        self.set_CoDI_predefined('angled_vert',0.0,45.0,45.0,0.0)\n        self.set_CoDI_predefined('angled_hor',90.0,45.0,45.0,0.0)\n    else: \n        all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n        for preset, preset_value in all_presets.items(): \n            try: \n                # get preset position\n                exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n                exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n                exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n                exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n                exec(exec_base)\n                exec(exec_rot_left)\n                exec(exec_rot_right)\n                exec(exec_trans_z)\n\n                # Save to local database\n                print(preset)\n                self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n            except: \n                print('skipping preset '+ preset + ', as it is not defined in all motors')    \n\n\n    # # create config parser handler\n    # json_handler = JsonFileHandler(supported_json)\n    # # load configs and launch web server\n    # json_handler.reload_endpoints()\n\n    # Flag that can be used later on for safety aborts during task execution\n    self.safety_abort = False\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.get_CoDI_pos","title":"<code>get_CoDI_pos(precision_digits=1)</code>","text":"<p>gets the colliding droplet injector motor positions as tuple</p> <p>Parameters precision_digits : int     precision with which the pre-defined positions are checked </p> <p>Return : (tuple, 5)     motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)</p> Source code in <code>dod/codi.py</code> <pre><code>def get_CoDI_pos(self, precision_digits = 1): \n    \"\"\"\n    gets the colliding droplet injector motor positions as tuple\n\n    Parameters\n    precision_digits : int\n        precision with which the pre-defined positions are checked \n\n    ----------\n    Return : (tuple, 5)\n        motor positions of the CoDI motors. (name of preset, rot_base, rot_left, rot_right, trans_z)\n    \"\"\"\n    pos_rot_base  = self.CoDI_rot_base.wm()\n    pos_rot_left  = self.CoDI_rot_left.wm()\n    pos_rot_right = self.CoDI_rot_right.wm()\n    pos_trans_z   = self.CoDI_trans_z.wm()\n\n    # # for testing purposes\n    # pos_rot_base  = 0\n    # pos_rot_left  = 45\n    # pos_rot_right = 45\n    # pos_trans_z   = 0\n\n    pos_tuple = (pos_rot_base,pos_rot_left, pos_rot_right,pos_trans_z)\n\n    pos_rounded = tuple([float(round(each_pos,1)) for each_pos in pos_tuple])\n\n    # Test if this is one of the preset positions: \n    pos_name = 'undefined'\n    for preset in self.CoDI_pos_predefined:\n        preset_rounded = tuple([float(round(each_pos,1)) for each_pos in self.CoDI_pos_predefined[preset]])\n        if preset_rounded[:-1] == pos_rounded[:-1]: \n            pos_name = preset\n\n    return pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_base_abs","title":"<code>move_rot_base_abs(rot_abs)</code>","text":"<p>moves the rotation of the base to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_base_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the base to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_base.umv(rot_abs)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_base_rel","title":"<code>move_rot_base_rel(rot_rel)</code>","text":"<p>moves the rotation of the base relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_base_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the base relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_base  = self.CoDI_rot_base.wm()\n\n    # set new position: \n    self.CoDI_rot_base.umvr(rot_rel)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_left_abs","title":"<code>move_rot_left_abs(rot_abs)</code>","text":"<p>moves the rotation of the left nozzle to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_left_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the left nozzle to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_left.umv(rot_abs)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_left_rel","title":"<code>move_rot_left_rel(rot_rel)</code>","text":"<p>moves the rotation of the left nozzle relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_left_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the left nozzle relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_left  = self.CoDI_rot_left.wm()\n\n    # set new position: \n    self.CoDI_rot_left.umvr(rot_rel)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_right_abs","title":"<code>move_rot_right_abs(rot_abs)</code>","text":"<p>moves the rotation of the right nozzle to the absolute position in degree</p> <p>Parameters rot_abs : float     abs motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_right_abs(self, rot_abs):\n        \"\"\"\n        moves the rotation of the right nozzle to the absolute position in degree\n\n        Parameters\n        rot_abs : float\n            abs motion in degree\n        ----------\n\n        \"\"\"\n\n        # set new position: \n        self.CoDI_rot_right.umv(rot_abs)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_rot_right_rel","title":"<code>move_rot_right_rel(rot_rel)</code>","text":"<p>moves the rotation of the right nozzle relative to the current position in degree</p> <p>Parameters rot_rel : float     relative motion in degree</p> Source code in <code>dod/codi.py</code> <pre><code>def move_rot_right_rel(self, rot_rel):\n    \"\"\"\n    moves the rotation of the right nozzle relative to the current position in degree\n\n    Parameters\n    rot_rel : float\n        relative motion in degree\n    ----------\n\n    \"\"\"\n    # get current position:\n    pos_rot_right  = self.CoDI_rot_right.wm()\n\n    # set new position: \n    self.CoDI_rot_right.umvr(rot_rel)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_z_abs","title":"<code>move_z_abs(z_abs)</code>","text":"<p>moves the z position to the absolute position in mm</p> <p>Parameters z_abs : float     absolute motion in mm</p> Source code in <code>dod/codi.py</code> <pre><code>def move_z_abs(self, z_abs):\n    \"\"\"\n    moves the z position to the absolute position in mm\n\n    Parameters\n    z_abs : float\n        absolute motion in mm\n    ----------\n\n    \"\"\"\n    # move z position:\n    self.CoDI_trans_z.umv(z_abs)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.move_z_rel","title":"<code>move_z_rel(z_rel)</code>","text":"<p>moves the z position relative to the current position </p> <p>Parameters z_rel : float     relative motion in mm</p> Source code in <code>dod/codi.py</code> <pre><code>def move_z_rel(self, z_rel):\n    \"\"\"\n    moves the z position relative to the current position \n\n    Parameters\n    z_rel : float\n        relative motion in mm\n    ----------\n\n    \"\"\"\n    # get current z position:\n    pos_trans_z  = self.CoDI_trans_z.wm()\n\n    # set new position\n    self.CoDI_trans_z.umvr(z_rel)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.remove_CoDI_pos","title":"<code>remove_CoDI_pos(name)</code>","text":"<p>removes the defined motor combination for CoDI from local database</p> <p>Parameters name : str     name of the pre-definition to be deleted</p> Source code in <code>dod/codi.py</code> <pre><code>def remove_CoDI_pos(self, name):\n    \"\"\"\n    removes the defined motor combination for CoDI from local database\n\n    Parameters\n    name : str\n        name of the pre-definition to be deleted\n    ----------\n\n    \"\"\"\n    del self.CoDI_pos_predefined[name]\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.set_CoDI_current_pos","title":"<code>set_CoDI_current_pos(name)</code>","text":"<p>defines or updates the current motor combination for CoDI</p> <p>Parameters name : str     name of the pre-definition</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_current_pos(self, name):\n    \"\"\"\n    defines or updates the current motor combination for CoDI\n\n    Parameters\n    name : str\n        name of the pre-definition\n    ----------\n\n    \"\"\"\n    pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.get_CoDI_pos()\n    self.set_CoDI_predefined(name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.set_CoDI_current_z","title":"<code>set_CoDI_current_z(verbose=True)</code>","text":"<p>sets the current z position to all preloaded positions Useful for global change of z after aligning</p> <p>Parameters verbose : Boolean     prints the new positions as a sanity check if True</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_current_z(self, verbose = True):\n    \"\"\"\n    sets the current z position to all preloaded positions\n    Useful for global change of z after aligning\n\n    Parameters\n    verbose : Boolean\n        prints the new positions as a sanity check if True\n    ----------\n\n    \"\"\"\n    # get current z position:\n    pos_trans_z_new  = self.CoDI_trans_z.wm()\n\n    # get all keys from the positions\n    position_keys = self.CoDI_pos_predefined.keys\n\n    #go through all positions and change the z-value to the current z value\n    for key in position_keys: \n        pos_name, pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[key]\n        self.set_CoDI_predefined(pos_name,pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z_new)\n\n    #Print the new predefined positions as a sanity check\n    if verbose == True:\n        print(self.get_CoDI_predefined)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.set_CoDI_pos","title":"<code>set_CoDI_pos(pos_name, wait=True)</code>","text":"<p>Moves the colliding droplet injector into a pre-defined position. </p> <p>Parameters pos_name : string     name of the pre-defined position wait : boolean     if the robot waits before continuing further steps</p> <p>Return :</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_pos(self, pos_name, wait = True): \n    \"\"\"\n    Moves the colliding droplet injector into a pre-defined position. \n\n    Parameters\n    pos_name : string\n        name of the pre-defined position\n    wait : boolean\n        if the robot waits before continuing further steps\n\n    ----------\n    Return : \n\n    \"\"\"\n    # pos_rot_base  = CoDI_base.wm()\n    # pos_rot_left  = CoDI_left.wm()\n    # pos_rot_right = CoDI_right.wm()\n    # pos_trans_z   = CoDI_z.wm()\n    import time\n\n    # get target positions\n    pos_rot_base, pos_rot_left, pos_rot_right, pos_trans_z = self.CoDI_pos_predefined[pos_name]\n\n    # Move motors\n\n    # Old wayy \n    # self.CoDI_rot_base.mv(pos_rot_base, wait=False)\n    # self.CoDI_rot_left.mv(pos_rot_left,  wait=False)\n    # self.CoDI_rot_right.mv(pos_rot_right, wait=False)\n    # self.CoDI_trans_z.mv(pos_trans_z, wait=False)\n\n    # Move using hutch python presets\n    exec_base = \"self.CoDI_rot_base.mv_\" + pos_name + '()'\n    exec(exec_base)\n    exec_left = \"self.CoDI_rot_left.mv_\" + pos_name + '()'\n    exec(exec_left)\n    exec_right = \"self.CoDI_rot_right.mv_\" + pos_name + '()'\n    exec(exec_right)\n    exec_z = \"self.CoDI_trans_z.mv_\" + pos_name + '()'\n    exec(exec_z)\n\n    if wait == True: \n        test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n        i = 0\n        while pos_name != test_name: \n            time.sleep(1)\n            print('\\r waiting for motion to end: %i s' %i, end=\"\\r\")\n            i = i+1\n            test_name, test_pos_rot_base, test_pos_rot_left, test_pos_rot_right, test_pos_trans_z = self.get_CoDI_pos()\n        print('Motion ended')\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.set_CoDI_predefined","title":"<code>set_CoDI_predefined(name, base, left, right, z)</code>","text":"<p>defines or updates a predefined combination for CoDI</p> <p>Parameters name : str     name of the pre-definition base : float     rotation of base left : float     rotation of left injector right : float     rotation of right injector z : float     translation of right injector</p> Source code in <code>dod/codi.py</code> <pre><code>def set_CoDI_predefined(self, name, base, left, right, z):\n    \"\"\"\n    defines or updates a predefined combination for CoDI\n\n    Parameters\n    name : str\n        name of the pre-definition\n    base : float\n        rotation of base\n    left : float\n        rotation of left injector\n    right : float\n        rotation of right injector\n    z : float\n        translation of right injector\n    ----------\n\n    \"\"\"\n    self.CoDI_pos_predefined.update({name: (base,left, right, z)})\n\n    # Presets using MFX presets functionalities \n    self.CoDI_rot_left.presets.add_hutch(name, value = left)\n    self.CoDI_rot_right.presets.add_hutch(name, value = right)\n    self.CoDI_rot_base.presets.add_hutch(name, value = base)\n    self.CoDI_trans_z.presets.add_hutch(name, value = z)\n</code></pre>"},{"location":"codi.html#dod.codi.CoDI.update_CoDI_predefined","title":"<code>update_CoDI_predefined()</code>","text":"<p>reloads all the hutch python presets for motors and overwrites local position preset dict</p> Source code in <code>dod/codi.py</code> <pre><code>def update_CoDI_predefined(self): \n    'reloads all the hutch python presets for motors and overwrites local position preset dict'\n\n    #Predefined positions CoDI\n    self.CoDI_pos_predefined = dict()\n\n    all_presets = vars(self.CoDI_rot_left.presets.positions) #Needs to be fixed\n    for preset in all_presets.keys(): \n        # try: \n        # get preset position\n        self.exec_base = \"preset_rot_base = self.CoDI_rot_base.presets.positions.\" + preset + '.pos'\n        self.exec_rot_left = \"preset_rot_left = self.CoDI_rot_left.presets.positions.\" + preset + '.pos'\n        self.exec_rot_right = \"preset_rot_right = self.CoDI_rot_right.presets.positions.\" + preset + '.pos'\n        self.exec_trans_z = \"preset_trans_z = self.CoDI_trans_z.presets.positions.\" + preset + '.pos'\n        print(self.exec_base)\n        exec(self.exec_base)\n\n        exec(self.exec_rot_left)\n        print(self.exec_rot_left)\n\n        exec(self.exec_rot_right)\n        print(self.exec_rot_left)\n\n        exec(self.exec_trans_z)\n        print(self.exec_trans_z)\n        print(preset_trans_z)\n\n        # Save to local database\n        print(preset)\n        self.set_CoDI_predefined(preset, preset_rot_base, preset_rot_left, preset_rot_right, preset_trans_z)\n</code></pre>"},{"location":"common.html","title":"Common","text":""},{"location":"common.html#dod.common.busy_wait","title":"<code>busy_wait(timeout)</code>","text":"<p>Busy wait untill timeout value is reached, timeout : sec returns true if timeout occured</p> Source code in <code>dod/common.py</code> <pre><code>def busy_wait(timeout: int):\n  '''\n        Busy wait untill timeout value is reached,\n        timeout : sec\n        returns true if timeout occured\n  '''\n  start = time.time()\n  r = client.get_status()\n  delta = 0\n\n  while(r.STATUS['Status'] == \"Busy\"):\n    if delta &gt; timeout:\n      return True\n\n    time.sleep(0.1) #Wait a ms to stop spamming robot\n    r = client.get_status()\n    delta = time.time() - start\n\n  return False\n</code></pre>"},{"location":"debug.html","title":"Debug","text":""},{"location":"debug.html#mfx.debug.Debug","title":"<code>Debug</code>","text":"Source code in <code>mfx/debug.py</code> <pre><code>class Debug:\n    def __init__(self):\n        import os\n        full_ioc_serverlist = os.popen(f\"netconfig search ioc-mfx* --brief\").read().splitlines()\n        full_daq_serverlist = os.popen(f\"netconfig search daq-mfx* --brief\").read().splitlines()\n        self.ioc_serverlist = [ioc for ioc in full_ioc_serverlist if not ioc.endswith(\n            \"-ipmi\") and not ioc.endswith(\"-fez\") and not ioc.endswith(\"-ics\")]\n        self.daq_serverlist = [ioc for ioc in full_daq_serverlist if not ioc.endswith(\n            \"-ipmi\") and not ioc.endswith(\"-fez\") and not ioc.endswith(\"-ana\")]\n\n\n    def awr(self, hutch='mfx'):\n        \"\"\"\n        Checks if the beamline is ready to take beam\n\n        Parameters\n        ----------\n        hutch: str, optional\n            Specify the hutch you want to check. Default is MFX because it is the best\n        \"\"\"\n        import os\n        import logging\n        logging.info(f\"{hutch} Beamline Check\")\n        os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/awr {hutch}\")\n\n\n    def motor_check(self):\n        import os\n        import logging\n        logging.info(f\"Powering up all available motors\")\n        os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/mfxpowerup.sh\")\n\n\n    def check_server(self, server):\n        \"\"\"\n        Checks the status of an individual server\n\n        Parameters\n        ----------\n        server: str, required\n            Specify the server name to check. Use debug.server_list('all') to see all servers\n        \"\"\"\n        import os\n        import logging\n        status = None\n        if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n            logging.info(f\"Checking the status of: {server}\")\n            status = os.popen(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} status\").read().splitlines()\n        else:\n            logging.info(f\"The server you are looking for does not exist please select one of the following\")\n            self.server_list('ioc')\n            self.server_list('daq')\n        return status\n\n\n    def cycle_server(self, server):\n        \"\"\"\n        Cycles an individual server\n\n        Parameters\n        ----------\n        server: str, required\n            Specify the server name to cycle. Use debug.server_list('all') to see all servers\n        \"\"\"\n        import os\n        import logging\n        if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n            logging.info(f\"Power cycling: {server}\")\n            os.system(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} cycle\")\n        else:\n            logging.info(f\"The server you are looking for does not exist please select one of the following\")\n            self.server_list('ioc')\n            self.server_list('daq')\n\n\n    def check_all_servers(self, server_type):\n        \"\"\"\n        Checks the status of all servers local to MFX\n\n        Parameters\n        ----------\n        server_type: str, required\n            Specify the server type input either 'all', 'ioc', or 'daq\n        \"\"\"\n        import logging\n        self.error_servers = []\n        if str(server_type) == 'all':\n            logging.info(f\"You've decided to check all {len(self.ioc_serverlist) + len(self.daq_serverlist)} servers.\")\n            for server in self.ioc_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    logging.error(status)\n                    self.error_servers.append(server)\n\n            for server in self.daq_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    logging.error(status)\n                    self.error_servers.append(server)\n\n        elif str(server_type) == 'ioc':\n            logging.info(f\"You've decided to check all {len(self.ioc_serverlist)} ioc servers.\")\n            for server in self.ioc_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    self.error_servers.append(server)\n\n        elif str(server_type) == 'daq':\n            logging.info(f\"You've decided to check all {len(self.daq_serverlist)} daq servers.\")\n            for server in self.daq_serverlist:\n                status = self.check_server(str(server))\n                if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                    logging.info(f\"Server {server} has passed all tests\")\n                else:\n                    logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                    self.error_servers.append(server)\n        else:\n            logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq or all.\")\n\n        if len(self.error_servers) != 0:\n            logging.warning(f\"There is something wrong with the following servers.\")\n            for server in self.error_servers:\n                print(f'{server}')\n            cycle = input(\"\\nWould you like to power cycle all error servers? (y/n)? \")\n\n            if cycle.lower() == \"y\":\n                logging.info(f\"You've decided to cycle all {len(self.error_servers)} broken servers.\")\n                for server in self.error_servers:\n                    self.cycle_server(str(server))\n            else:\n                logging.info(f\"You've decided not to cycle {len(self.error_servers)} broken servers.\")\n        else:\n            logging.info(f\"All {len(self.error_servers)} servers are ready to rock.\")\n\n        return self.error_servers\n\n\n    def server_list(self, server_type):\n        \"\"\"\n        Lists servers local to MFX\n\n        Parameters\n        ----------\n        server_type: str, required\n            Specify the server type input either 'all', 'ioc', or 'daq\n        \"\"\"\n        import logging\n        if str(server_type) == 'all':\n            print('IOC SERVERS\\n#########################')\n            for server in self.ioc_serverlist:\n                print(f'{server}')\n            print('\\nDAQ SERVERS\\n#########################')\n            for server in self.daq_serverlist:\n                print(f'{server}')\n        elif str(server_type) == 'ioc':\n            print('IOC SERVERS\\n#########################')\n            for server in self.ioc_serverlist:\n                print(f'{server}')\n        elif str(server_type) == 'daq':\n            print('DAQ SERVERS\\n#########################')\n            for server in self.daq_serverlist:\n                print(f'{server}')\n        else:\n            logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq.\")\n</code></pre>"},{"location":"debug.html#mfx.debug.Debug.awr","title":"<code>awr(hutch='mfx')</code>","text":"<p>Checks if the beamline is ready to take beam</p>"},{"location":"debug.html#mfx.debug.Debug.awr--parameters","title":"Parameters","text":"<p>hutch: str, optional     Specify the hutch you want to check. Default is MFX because it is the best</p> Source code in <code>mfx/debug.py</code> <pre><code>def awr(self, hutch='mfx'):\n    \"\"\"\n    Checks if the beamline is ready to take beam\n\n    Parameters\n    ----------\n    hutch: str, optional\n        Specify the hutch you want to check. Default is MFX because it is the best\n    \"\"\"\n    import os\n    import logging\n    logging.info(f\"{hutch} Beamline Check\")\n    os.system(f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/awr {hutch}\")\n</code></pre>"},{"location":"debug.html#mfx.debug.Debug.check_all_servers","title":"<code>check_all_servers(server_type)</code>","text":"<p>Checks the status of all servers local to MFX</p>"},{"location":"debug.html#mfx.debug.Debug.check_all_servers--parameters","title":"Parameters","text":"<p>server_type: str, required     Specify the server type input either 'all', 'ioc', or 'daq</p> Source code in <code>mfx/debug.py</code> <pre><code>def check_all_servers(self, server_type):\n    \"\"\"\n    Checks the status of all servers local to MFX\n\n    Parameters\n    ----------\n    server_type: str, required\n        Specify the server type input either 'all', 'ioc', or 'daq\n    \"\"\"\n    import logging\n    self.error_servers = []\n    if str(server_type) == 'all':\n        logging.info(f\"You've decided to check all {len(self.ioc_serverlist) + len(self.daq_serverlist)} servers.\")\n        for server in self.ioc_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                logging.error(status)\n                self.error_servers.append(server)\n\n        for server in self.daq_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].split(\", \")[0].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                logging.error(status)\n                self.error_servers.append(server)\n\n    elif str(server_type) == 'ioc':\n        logging.info(f\"You've decided to check all {len(self.ioc_serverlist)} ioc servers.\")\n        for server in self.ioc_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                self.error_servers.append(server)\n\n    elif str(server_type) == 'daq':\n        logging.info(f\"You've decided to check all {len(self.daq_serverlist)} daq servers.\")\n        for server in self.daq_serverlist:\n            status = self.check_server(str(server))\n            if status[0].endswith('on') and status[1].endswith('1)') and status[2].endswith('up'):\n                logging.info(f\"Server {server} has passed all tests\")\n            else:\n                logging.error(f\"Server {server} has failed one or more tests and is added to the broken list\")\n                self.error_servers.append(server)\n    else:\n        logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq or all.\")\n\n    if len(self.error_servers) != 0:\n        logging.warning(f\"There is something wrong with the following servers.\")\n        for server in self.error_servers:\n            print(f'{server}')\n        cycle = input(\"\\nWould you like to power cycle all error servers? (y/n)? \")\n\n        if cycle.lower() == \"y\":\n            logging.info(f\"You've decided to cycle all {len(self.error_servers)} broken servers.\")\n            for server in self.error_servers:\n                self.cycle_server(str(server))\n        else:\n            logging.info(f\"You've decided not to cycle {len(self.error_servers)} broken servers.\")\n    else:\n        logging.info(f\"All {len(self.error_servers)} servers are ready to rock.\")\n\n    return self.error_servers\n</code></pre>"},{"location":"debug.html#mfx.debug.Debug.check_server","title":"<code>check_server(server)</code>","text":"<p>Checks the status of an individual server</p>"},{"location":"debug.html#mfx.debug.Debug.check_server--parameters","title":"Parameters","text":"<p>server: str, required     Specify the server name to check. Use debug.server_list('all') to see all servers</p> Source code in <code>mfx/debug.py</code> <pre><code>def check_server(self, server):\n    \"\"\"\n    Checks the status of an individual server\n\n    Parameters\n    ----------\n    server: str, required\n        Specify the server name to check. Use debug.server_list('all') to see all servers\n    \"\"\"\n    import os\n    import logging\n    status = None\n    if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n        logging.info(f\"Checking the status of: {server}\")\n        status = os.popen(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} status\").read().splitlines()\n    else:\n        logging.info(f\"The server you are looking for does not exist please select one of the following\")\n        self.server_list('ioc')\n        self.server_list('daq')\n    return status\n</code></pre>"},{"location":"debug.html#mfx.debug.Debug.cycle_server","title":"<code>cycle_server(server)</code>","text":"<p>Cycles an individual server</p>"},{"location":"debug.html#mfx.debug.Debug.cycle_server--parameters","title":"Parameters","text":"<p>server: str, required     Specify the server name to cycle. Use debug.server_list('all') to see all servers</p> Source code in <code>mfx/debug.py</code> <pre><code>def cycle_server(self, server):\n    \"\"\"\n    Cycles an individual server\n\n    Parameters\n    ----------\n    server: str, required\n        Specify the server name to cycle. Use debug.server_list('all') to see all servers\n    \"\"\"\n    import os\n    import logging\n    if str(server) in self.ioc_serverlist or str(server) in self.daq_serverlist:\n        logging.info(f\"Power cycling: {server}\")\n        os.system(f\"/reg/g/pcds/engineering_tools/latest-released/scripts/serverStat {server} cycle\")\n    else:\n        logging.info(f\"The server you are looking for does not exist please select one of the following\")\n        self.server_list('ioc')\n        self.server_list('daq')\n</code></pre>"},{"location":"debug.html#mfx.debug.Debug.server_list","title":"<code>server_list(server_type)</code>","text":"<p>Lists servers local to MFX</p>"},{"location":"debug.html#mfx.debug.Debug.server_list--parameters","title":"Parameters","text":"<p>server_type: str, required     Specify the server type input either 'all', 'ioc', or 'daq</p> Source code in <code>mfx/debug.py</code> <pre><code>def server_list(self, server_type):\n    \"\"\"\n    Lists servers local to MFX\n\n    Parameters\n    ----------\n    server_type: str, required\n        Specify the server type input either 'all', 'ioc', or 'daq\n    \"\"\"\n    import logging\n    if str(server_type) == 'all':\n        print('IOC SERVERS\\n#########################')\n        for server in self.ioc_serverlist:\n            print(f'{server}')\n        print('\\nDAQ SERVERS\\n#########################')\n        for server in self.daq_serverlist:\n            print(f'{server}')\n    elif str(server_type) == 'ioc':\n        print('IOC SERVERS\\n#########################')\n        for server in self.ioc_serverlist:\n            print(f'{server}')\n    elif str(server_type) == 'daq':\n        print('DAQ SERVERS\\n#########################')\n        for server in self.daq_serverlist:\n            print(f'{server}')\n    else:\n        logging.warning(f\"There is no server of the type you requested. Please use either ioc or daq.\")\n</code></pre>"},{"location":"delay_scan.html","title":"Delay scan","text":""},{"location":"delay_scan.html#mfx.delay_scan.delay_scan","title":"<code>delay_scan(daq, time_motor, time_points, sweep_time, duration=None, record=None, use_l3t=False, controls=None)</code>","text":"<p>Bluesky plan that sets up and executes the delay scan.</p>"},{"location":"delay_scan.html#mfx.delay_scan.delay_scan--parameters","title":"Parameters","text":"<p>daq: Daq     The daq</p> DelayNewport <p>The movable device in seconds</p> list of float <p>The times in second to move between</p> float <p>The duration we take to move from one end of the range to the other.</p> bool, optional <p>Whether or not to record in the daq</p> float, optional <p>If provided, the time to run in seconds. If omitted, we'll run forever.</p> bool, optional <p>If True, events argument will be interpreted to only count events that pass the level 3 trigger</p> dict or list of devices, optional <p>If provided, values will make it to DAQ data stream as variables</p> Source code in <code>mfx/delay_scan.py</code> <pre><code>def delay_scan(daq, time_motor, time_points, sweep_time, duration=None, \n               record=None, use_l3t=False, controls=None):\n    \"\"\"\n    Bluesky plan that sets up and executes the delay scan.\n\n    Parameters\n    ----------\n    daq: Daq\n        The daq\n\n    time_motor: DelayNewport\n        The movable device in seconds\n\n    time_points: list of float\n        The times in second to move between\n\n    sweep_time: float\n        The duration we take to move from one end of the range to the other.\n\n    record: bool, optional\n        Whether or not to record in the daq\n\n    duration: float, optional\n        If provided, the time to run in seconds. If omitted, we'll run forever.\n\n    use_l3t: bool, optional\n        If True, events argument will be interpreted to only count events that\n        pass the level 3 trigger\n\n    controls: dict or list of devices, optional\n        If provided, values will make it to DAQ data stream as variables\n    \"\"\"\n\n    spatial_pts = []\n    for time_pt in time_points:\n        pseudo_tuple = time_motor.PseudoPosition(delay=time_pt)\n        real_tuple = time_motor.forward(pseudo_tuple)\n        spatial_pts.append(real_tuple.motor)\n\n    space_delta = abs(spatial_pts[0] - spatial_pts[1])\n    velo = space_delta/sweep_time\n\n    yield from bps.abs_set(time_motor.motor.velocity, velo)\n\n    scan = infinite_scan([], time_motor, time_points, duration=duration)\n\n    if daq is not None:\n        yield from daq_during_wrapper(scan, record=record, use_l3t=use_l3t,\n                                      controls=controls)\n    else:\n        yield from scan\n</code></pre>"},{"location":"delay_scan.html#mfx.delay_scan.infinite_scan","title":"<code>infinite_scan(detectors, motor, points, duration=None, per_step=None, md=None)</code>","text":"<p>Bluesky plan that moves a motor among points until interrupted.</p>"},{"location":"delay_scan.html#mfx.delay_scan.infinite_scan--parameters","title":"Parameters","text":"<p>detectors: list of readables     Objects to read into Python in the scan.</p> settable <p>Object to move in the scan.</p> list of floats <p>Positions to move between in the scan.</p> float <p>If provided, the time to run in seconds. If omitted, we'll run forever.</p> Source code in <code>mfx/delay_scan.py</code> <pre><code>def infinite_scan(detectors, motor, points, duration=None,\n                  per_step=None, md=None):\n    \"\"\"\n    Bluesky plan that moves a motor among points until interrupted.\n\n    Parameters\n    ----------\n    detectors: list of readables\n        Objects to read into Python in the scan.\n\n    motor: settable\n        Object to move in the scan.\n\n    points: list of floats\n        Positions to move between in the scan.\n\n    duration: float\n        If provided, the time to run in seconds. If omitted, we'll run forever.\n    \"\"\"\n    if per_step is None:\n        per_step = bps.one_nd_step\n\n    if md is None:\n        md = {}\n\n    md.update(motors=[motor.name])\n    start = time.time()\n\n    #@bpp.stage_decorator(list(detectors) + [motor])\n    @bpp.reset_positions_decorator()\n    @bpp.run_decorator(md=md)\n    def inner():\n        # Where last position is stored\n        pos_cache = defaultdict(lambda: None)\n        while duration is None or time.time() - start &lt; duration:\n            for pt in points:\n                step = {motor: pt}\n                yield from per_step(detectors, step, pos_cache)\n\n    return (yield from inner())\n</code></pre>"},{"location":"detector_image.html","title":"Detector image","text":""},{"location":"detector_image.html#mfx.detector_image.detector_image","title":"<code>detector_image(node=5, det='Rayonix', calibdir=None, ave=1)</code>","text":"<p>Launches detector monitor</p>"},{"location":"detector_image.html#mfx.detector_image.detector_image--parameters","title":"Parameters","text":"<p>node: int, optional     Node to run detector monitor 1-9 only</p> str, optional <p>Detector name. Example 'Rayonix'</p> str, optional <p>path to calib directory</p> int, optional <p>Average over this number of events</p>"},{"location":"detector_image.html#mfx.detector_image.detector_image--operations","title":"Operations","text":"Source code in <code>mfx/detector_image.py</code> <pre><code>def detector_image(node=5, det='Rayonix', calibdir=None, ave=1):\n    \"\"\"\n    Launches detector monitor\n\n    Parameters\n    ----------\n    node: int, optional\n        Node to run detector monitor 1-9 only\n\n    det: str, optional\n        Detector name. Example 'Rayonix'\n\n    calibdir: str, optional\n        path to calib directory\n\n    ave: int, optional\n        Average over this number of events\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n    from mfx.macros import get_exp\n\n    experiment = str(get_exp())\n\n    proc = [\n        f\"ssh -YAC mfxopr@daq-mfx-mon0{str(node)} \"\n        f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/\"\n        f\"detector_image.sh {experiment} {str(det)} {str(calibdir)} {str(ave)}\"\n        ]\n\n    logging.info(proc)\n\n    subprocess.Popen(\n        proc, shell=True, \n        stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT)\n</code></pre>"},{"location":"detector_image.html#mfx.detector_image.detector_image_kill","title":"<code>detector_image_kill(node=5)</code>","text":"<p>Kills all detector monitors made with this script</p>"},{"location":"detector_image.html#mfx.detector_image.detector_image_kill--parameters","title":"Parameters","text":"<p>node: int, optional     Node to run detector monitor 1-9 only</p> str, optional <p>Detector name. Example 'Rayonix'</p> str, optional <p>path to calib directory</p> int, optional <p>Average over this number of events</p>"},{"location":"detector_image.html#mfx.detector_image.detector_image_kill--operations","title":"Operations","text":"Source code in <code>mfx/detector_image.py</code> <pre><code>def detector_image_kill(node=5):\n    \"\"\"\n    Kills all detector monitors made with this script\n\n    Parameters\n    ----------\n    node: int, optional\n        Node to run detector monitor 1-9 only\n\n    det: str, optional\n        Detector name. Example 'Rayonix'\n\n    calibdir: str, optional\n        path to calib directory\n\n    ave: int, optional\n        Average over this number of events\n\n    Operations\n    ----------\n\n    \"\"\"\n    import logging\n    import subprocess\n\n    proc = [\n        f\"ssh -YAC mfxopr@daq-mfx-mon0{str(node)} \" +\n        f\"/cds/group/pcds/pyps/apps/hutch-python/mfx/scripts/\"\n        f\"detector_image_kill.sh\"\n        ]\n\n    logging.info(proc)\n\n    subprocess.Popen(\n        proc, shell=True)\n</code></pre>"},{"location":"devices.html","title":"Devices","text":""},{"location":"devices.html#mfx.devices.LaserShutter","title":"<code>LaserShutter</code>","text":"<p>               Bases: <code>InOutPositioner</code></p> <p>Controls shutter controlled by Analog Output</p> Source code in <code>mfx/devices.py</code> <pre><code>class LaserShutter(InOutPositioner):\n    \"\"\"Controls shutter controlled by Analog Output\"\"\"\n    # EpicsSignals\n    voltage = C(EpicsSignal, '')\n    state = FC(AttributeSignal, 'voltage_check')\n    # Constants\n    out_voltage = 5.0\n    in_voltage = 0.0\n    barrier_voltage = 1.4\n\n    @property\n    def voltage_check(self):\n        \"\"\"Return the position we believe shutter based on the channel\"\"\"\n        if self.voltage.get() &gt;= self.barrier_voltage:\n            return 'OUT'\n        else:\n            return 'IN'\n\n    def _do_move(self, state):\n        \"\"\"Override to just put to the channel\"\"\"\n        if state.name == 'IN':\n            self.voltage.put(self.in_voltage)\n        elif state.name == 'OUT':\n            self.voltage.put(self.out_voltage)\n        else:\n            raise ValueError(\"%s is in an invalid state\", state)\n</code></pre>"},{"location":"devices.html#mfx.devices.LaserShutter.voltage_check","title":"<code>voltage_check</code>  <code>property</code>","text":"<p>Return the position we believe shutter based on the channel</p>"},{"location":"devices.html#mfx.devices.Piezo","title":"<code>Piezo</code>","text":"<p>               Bases: <code>Device</code></p> <p>Device for controlling piezo injector motors</p> Source code in <code>mfx/devices.py</code> <pre><code>class Piezo(Device):\n    \"\"\"\n    Device for controlling piezo injector motors\n    \"\"\"\n    velocity =  C(EpicsSignalRO, ':VELOCITYGET')\n    req_velocity = C(EpicsSignal, ':VELOCITYSET')\n    open_loop_step = C(EpicsSignal, ':OPENLOOPSTEP')\n\n    _default_read_attrs = ['open_loop_step']\n    _default_configuration_attrs = ['velocity']\n\n    def tweak(self, distance):\n        \"\"\"\n        Tweak the Piezo by a distance\n        \"\"\"\n        return self.open_loop_step.set(distance)\n</code></pre>"},{"location":"devices.html#mfx.devices.Piezo.tweak","title":"<code>tweak(distance)</code>","text":"<p>Tweak the Piezo by a distance</p> Source code in <code>mfx/devices.py</code> <pre><code>def tweak(self, distance):\n    \"\"\"\n    Tweak the Piezo by a distance\n    \"\"\"\n    return self.open_loop_step.set(distance)\n</code></pre>"},{"location":"devices.html#mfx.devices.XFLS","title":"<code>XFLS</code>","text":"<p>               Bases: <code>XFLS</code></p> <p>XRay Focusing Lens (Be)</p> <p>These are the stacks with common names on their states and state config PVs that show the focusing config</p> Source code in <code>mfx/devices.py</code> <pre><code>class XFLS(pcdsdevices.device_types.XFLS):\n    \"\"\"\n    XRay Focusing Lens (Be)\n\n    These are the stacks with common names on their states and state config PVs\n    that show the focusing config\n    \"\"\"\n    states_list = ['6K70', '7K50', '9K45', 'OUT']\n    in_states = ['6K70', '7K50', '9K45']\n</code></pre>"},{"location":"dod.html","title":"Dod","text":""},{"location":"dod.html#dod.dod.DoD","title":"<code>DoD</code>","text":"Source code in <code>dod/dod.py</code> <pre><code>class DoD: \n    def __init__(self, modules = 'None', ip = \"172.21.72.187\", port = 9999, supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n):\n        \"\"\"\n        Class definition of the DoD robot\n        Parameters\n        ----------\n        modules : string\n            Defines the optional modules of the robot. \n            Options: 'None', 'codi', , \n        ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"            \n        \"\"\"\n        from dod.DropsDriver import myClient\n        from dod.JsonFileHandler import JsonFileHandler\n        from dod.ServerResponse import ServerResponse\n\n        import time\n\n        # Create object \n        # pytest encourages this pattern, apologies.\n        # ip = \"172.21.72.187\" #\"172.21.148.101\"\n        # port = 9999\n        # supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n\n        # User input parameters: \n        # Safety parameters in hutch coordinate system. \n        # Note: hutch (x,y,z) = robot (x,-z, y) \n        # \n        self.y_min     = 10000 # minimum value in y.\n        self.y_safety  = 50000 # value in y, above which the robot can only be in vertical configuration\n        self.y_max     = 50000 # maximum value in y\n\n        #Initialize safety regions for horizontal and vertical rotation: \n        self.forbidden_regions_horizontal = []\n        self.forbidden_regions_vertical = []\n        #minimum region: \n        self.set_forbidden_region(0, 300000, 0, self.y_min,rotation_state='both')\n        #maximum region: \n        self.set_forbidden_region(0, 300000, self.y_max, 500000,rotation_state='both')\n        #region where horizontal rotation is forbidden: \n        self.set_forbidden_region(0, 300000,  self.y_safety, self.y_max,rotation_state='horizontal')\n\n        # Initializing the robot client that is used for communication\n        self.client = myClient(ip=ip, port=port, supported_json=supported_json, reload=False)\n\n        # create config parser handler\n        json_handler = JsonFileHandler(supported_json)\n        # load configs and launch web server\n        json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n        if modules == 'codi': \n            from dod.codi import CoDI\n            self.codi = CoDI()\n\n        # Timing section\n        from pcdsdevices.evr import Trigger\n        self.delay = None\n\n        # Trigger objects\n        self.trigger_Xray = Trigger('MFX:LAS:EVR:01:TRIG7', name='trigger_X-ray_simulator')\n        self.trigger_nozzle_1 = Trigger('MFX:LAS:EVR:01:TRIG2', name='trigger_nozzle_1')\n        self.trigger_nozzle_2 = Trigger('MFX:LAS:EVR:01:TRIG3', name='trigger_nozzle_2')\n        self.trigger_LED = Trigger('MFX:LAS:EVR:01:TRIG1', name='trigger_LED_array')\n\n        # Timing parameter\n        self.timing_Xray = self.trigger_Xray.ns_delay.get()\n        self.timing_nozzle_1 = self.trigger_nozzle_1.ns_delay.get()\n        self.timing_nozzle_2 = self.trigger_nozzle_2.ns_delay.get()\n        self.timing_LED = self.trigger_LED.ns_delay.get()\n        self.timing_delay_sciPulse = 60600\n        self.timing_delay_LED = 1000 #delay of LED relative to X-ray timing\n        self.timing_delay_reaction = 0\n        self.timing_delay_nozzle_1 = self.timing_Xray - self.timing_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        self.timing_delay_nozzle_2 = self.timing_Xray - self.timing_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n\n\n    def stop_task(self, verbose = True):\n        \"\"\"\n        Stop task while running\n        ** ISSUES **\n        -  When stop task  is called, the Robot stays in \"BUSY\" Status.\n        Parameters\n        ----------\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        Returns: \n        r : \n            status readback when aborted\n        \"\"\"\n        r = self.client.connect(\"Test\")\n        self.safety_abort = False\n        r = self.client.stop_task()\n        r = self.client.disconnect()\n        if verbose == True: \n            return r\n\n\n    def clear_abort(self, verbose = True):\n        \"\"\"\n        clear abort flag\n        Parameters\n        verbose : boolean\n           Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            status readback after error cleared\n        '''\n        \"\"\"\n        r = self.client.connect(\"Test\")\n        r = self.client.get_status()\n        self.safety_abort = False\n        rr = self.client.disconnect()\n\n        if verbose == True: \n            return r\n\n\n    # def clear_popup_window(self, verbose = True):\n    #     \"\"\"\n    #     clears a popup window that might pop up on the robot gui\n    #     Parameters\n    #     verbose : boolean\n    #        Defines whether the function returns the full output, or only the results\n    #     ----------\n    #     Returns: \n    #     r : \n    #         status readback after error cleared\n    #     '''\n    #     \"\"\"\n    #     r = self.client.connect(\"Test\")\n    #     r = self.client.get_status()\n\n    #     self.client.close_dialog(reference, selection)\n\n    #     if verbose == True: \n    #         return r\n\n\n    def get_status(self, verbose = False):\n        \"\"\"\n        returns the robot state\n\n        Parameters\n        verbose : boolean\n           Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : dict\n            different states of the robot\n        \"\"\"\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_status()\n        # expected_keys = [\n        #     'Position',\n        #     'RunningTask',\n        #     'Dialog',\n        #     'LastProbe',\n        #     'Humidity',\n        #     'Temperature',\n        #     'BathTemp',\n        #     ]\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def busy_wait(self, timeout):\n        '''\n            Busy wait untill timeout value is reached,\n            timeout : sec\n            returns true if timeout occured\n        '''\n        import time\n        start = time.time()\n        r = self.client.get_status()\n        delta = 0\n\n        while(r.STATUS['Status'] == \"Busy\"):\n            if delta &gt; timeout:\n                return True\n\n            time.sleep(0.1) #Wait a ms to stop spamming robot\n            r = self.client.get_status()\n            delta = time.time() - start    \n        return False\n\n\n    # def __del__(self):\n    #     # close network connection\n    #     self.client.conn.close()\n\n\n    def get_task_details(self, task_name, verbose = False):\n        \"\"\"\n            This gets the details of a task from the robot to see the scripted routines\n            Parameters\n            task_name : string\n                Name of the task that we want to get\n            verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n            Returns: \n            r : \n                returns the robot tasks\n        \"\"\"\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_task_details(task_name)\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_task_names(self, verbose = False):\n        \"\"\"\n            This gets the names of available tasks from the robot\n            Parameters\n            task_name : string\n                Name of the task that we want to get\n            verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n            Returns: \n            r : dict\n                returns the robot tasks\n        \"\"\"\n        # Check if reponse is not an empty array or any errors occured\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_task_names()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_current_position(self, verbose = False):\n        '''\n        Returns current robot position\n        name and properties of the last selected position, together with the real current position coordinates\n        Parameters\n\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : \n            returns the current position.         \n        # expected_keys = [\n        #         'CurrentPosition',\n        #         'Position',\n        #         'PositionReal',\n        #         ]\n        '''\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_nozzle_status(self, verbose = False):\n        '''\n        Returns current nozzle parameters position\n        Parameters\n\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            returns the current nozzle parameters.         \n        #         expected_keys = [\n                \"Activated Nozzles\",\n                \"Selected Nozzles\",\n                \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n                \"Dispensing\",\n                ]\n        '''\n        rr = self.client.connect(\"Test\")\n        r = self.client.get_nozzle_status()\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def set_nozzle_dispensing(self, mode = \"Off\", verbose = False):\n        '''\n        Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\"\n        Parameters\n        mode : string \n            either \"free\", \"triggered\", or \"off\"\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n        '''\n        rr = self.client.connect(\"Test\")\n        if mode == 'Free': \n            r = self.client.dispensing('Free')\n        elif mode == 'Triggered':\n            r = self.client.dispensing('Triggered')\n        else: \n            #turns active nozzles off. Safer if all nozzles would be turned off\n            r = self.client.dispensing('Off')\n            for i in [1,2,3,4]: \n                r = self.client.select_nozzle(i)\n                r = self.client.dispensing('Off')\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def do_move(self, position, safety_test = False, verbose = False):\n        '''\n            Moves robot to new position\n\n        Parameters\n        position : string\n            Position name to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n\n        if safety_test == False:  \n            r = self.client.move(position)\n        else: \n            print('safety test of move has yet to be implemented')\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(15)\n\n        r = self.client.get_current_positions()\n        new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_x_abs(self, position_x, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute x position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_x(position_x)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(position_x, y_current): \n                r = self.client.move_x(position_x)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_y_abs(self, position_y, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute x position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_y(position_y)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(x_current, position_y): \n                r = self.client.move_y(position_y)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def move_z_abs(self, position_z, safety_test = False, verbose = False):\n        '''\n            Robot coordinate system!!!: \n            Moves robot to new absolute Z position. \n            No safety test. \n\n        Parameters\n        position : int\n            Absolute position in um(?) to which the robot is supposed to move\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : current position\n        '''\n\n        r = self.client.connect(\"Test\")\n        r = self.client.get_current_positions()\n        current_real_position = r.RESULTS['PositionReal']\n        x_current, y_current, z_current = current_real_position\n\n        if safety_test == False:  \n            r = self.client.move_z(position_z)\n        else: \n            print('safety test of move has yet to be implemented')\n            if self.test_forbidden_region(x_current, y_current): \n                r = self.client.move_z(position_z)\n\n\n        # WAIT FOR MOVEMENT TO BE DONE\n        self.busy_wait(25)\n\n        # r = self.client.get_current_positions()\n        # new_real_position = r.RESULTS['PositionReal']\n\n        rr = self.client.disconnect()\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def do_task(self, task_name, safety_check = False, verbose = False):\n        '''\n        Executes a task of the robot\n\n        Parameters\n        task_name : string\n            task name which robot is supposed to perform\n        safety_test : Boolean\n            question whether a safety test is to be performed or not\n            True: Test will be performed\n            False: Not performed\n        verbose : boolean\n                Defines whether the function returns the full output, or only the results\n            ----------\n        Returns: \n        r : \n        '''\n        import time\n\n        rr = self.client.connect(\"Test\")\n        if safety_check == False: \n            r = self.client.execute_task(task_name)\n        else: \n            print('safety check needs to be implemented')\n\n        ## Wait for task to be done\n        while(r.STATUS['Status'] == \"Busy\"):\n            #Possible if loop is not enterd?\n            time.sleep(0.5)\n            r = self.client.get_status()\n            if self.safety_abort == True: \n                r = self.client.stop_task()\n                print('User aborted task execution')\n                return r\n\n        r = self.client.get_status()\n\n        #Check if any error occured\n        if r.ERROR_CODE == 0:\n            print('no error')\n        else: \n            print('error while performing task!')\n\n        if verbose == True: \n            return r\n        else: \n            return r.RESULTS\n\n\n    def get_forbidden_region(self, rotation_state = 'both'): \n        \"\"\"\n        returns forbidden regions in the robot coordinate x y plane for end-point testing \n        defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n        returns the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n        Parameters\n        rotation_state: string\n            options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n        ----------\n\n        \"\"\"\n\n        #combine the lists depending on the rotation \n        if rotation_state == \"vertical\": \n            test_list_safety = self.forbidden_regions_vertical\n        elif rotation_state == \"horizontal\": \n            test_list_safety = self.forbidden_regions_horizontal\n        else:\n            test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n        return test_list_safety\n\n\n    def set_forbidden_region(self, x_start, x_stop, y_start, y_stop, rotation_state = 'both'): \n        \"\"\"\n        set a forbidden region in the robot coordinate x y plane for end-point testing \n        defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n        set the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n        Parameters\n        x_start : float\n            x-position start \n        x_stop : float\n            x-position stop\n        y_start : float\n            y-position start \n        y_stop : float\n            y-position stop\n        rotation_state: string\n            options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n        ----------\n\n        \"\"\"\n        region_tuple = (min(x_start,x_stop), max(x_start,x_stop), min(y_start,y_stop), max(y_start,y_stop))\n        if rotation_state == \"horizontal\": \n            self.forbidden_regions_horizontal.append(region_tuple)\n        elif rotation_state == \"vertical\": \n            self.forbidden_regions_vertical.append(region_tuple)\n        elif rotation_state == \"both\": \n            self.forbidden_regions_vertical.append(region_tuple)\n            self.forbidden_regions_horizontal.append(region_tuple)\n        else:\n            print('invalid input of rotation state')\n\n\n    def test_forbidden_region(self, x_test, y_test): \n        \"\"\"\n        tests if the end point of a motion is inside a forbidden region\n        No testing of the path of a motion included!\n\n        Parameters\n        x_test : float\n            x-position to test \n        y_test : float \n            y-position to test \n\n        ----------\n        Returns: \n        safe_motion : bool\n            boolean flag if endpoint of motion is safe or not\n        \"\"\"\n        from dod.codi import CoDI_base\n        # Get current rotation state\n        pos_rot_base  = round(CoDI_base.wm(),0)\n\n        #Initialize safe flag (True = safe)\n        flag_safe_endpoint = True\n\n        #combine the lists depending on the rotation \n        if pos_rot_base == 90: \n            test_list_safety = self.forbidden_regions_vertical\n        elif pos_rot_base == 0:\n            test_list_safety = self.forbidden_regions_horizontal\n        else:\n            test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n        #Test for all regions if the end point is in the forbidden region\n        for tuple_current in test_list_safety: \n            x_start, x_stop, y_start, y_stop = tuple_current\n            if ((x_start &lt; x_test) and (x_stop &gt; x_test) and (y_start &lt; y_test) and (y_stop &gt; y_test)): \n                flag_safe_endpoint = flag_safe_endpoint and False\n            else:\n                flag_safe_endpoint = flag_safe_endpoint and True\n\n        return flag_safe_endpoint\n\n\n    def set_timing_update(self): \n        \"\"\"\n        updating the timing triggers according to the set relative and absolute timing values\n\n        Parameters\n               ----------\n        Returns: \n        \"\"\"\n        # Nozzle 1\n        self.timing_nozzle_1 = self.timing_Xray - self.timing_delay_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        if self.timing_nozzle_1 &lt; 0: \n            self.timing_nozzle_1 = self.timing_nozzle_1 + 1/120*1000000000\n        self.trigger_nozzle_1.ns_delay.put(self.timing_nozzle_1)\n\n        # Nozzle 2\n        self.timing_nozzle_2 = self.timing_Xray - self.timing_delay_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        if self.timing_nozzle_2 &lt; 0: \n            self.timing_nozzle_2 = self.timing_nozzle_2 + 1/120*1000000000\n        self.trigger_nozzle_2.ns_delay.put(self.timing_nozzle_2)\n\n        # LED\n        self.timing_LED = self.timing_Xray + self.timing_delay_LED\n        self.trigger_LED.ns_delay.put(self.timing_LED)\n\n\n    def set_timing_zero_nozzle(self, nozzle, timing_rel): \n        \"\"\"\n        Setting the time zero for the nozzles from the LED alignment in robot\n\n        Parameters\n        nozle : int\n            nozzle number\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        if nozzle == 1: \n            self.timing_delay_nozzle_1 = timing_rel\n        elif nozzle == 2: \n            self.timing_delay_nozzle_2 = timing_rel\n        else: \n            print('no valid nozzle selected.')\n            return\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_rel_LED(self, timing_rel): \n        \"\"\"\n        Setting the relative timing of the LED relative to the X-rays\n\n        Parameters\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_delay_LED = timing_rel #delay of LED relative to X-ray timing\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_rel_reaction(self, timing_rel): \n        \"\"\"\n        Setting the relative timing of the reaction relative to the X-rays\n\n        Parameters\n        timing_rel : float\n            relative delay in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_delay_reaction = timing_rel #delay of LED relative to X-ray timing\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_abs_Xray(self, timing_abs): \n        \"\"\"\n        Setting the absolute timing of the X-rays for claculation purposes\n\n        Parameters\n        timing_abs : float\n            abs timing in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        self.timing_Xray = timing_abs #delay of LED relative to X-ray timing\n        #self.trigger_Xray.ns_delay.put(self.timing_Xray)\n\n        # update timings\n        self.set_timing_update()\n\n\n    def set_timing_relative_nozzle(self, nozzle, timing_rel): \n        \"\"\"\n        Changing the timing of the selected nozzle by a relative amount \n\n        Parameters\n        nozle : int\n            nozzle number\n        timing_rel : float\n            relative change in ns from robot alignment\n        ----------\n        Returns: \n        \"\"\"\n        if nozzle == 1: \n            current_timing = self.timing_delay_nozzle_1\n            self.timing_delay_nozzle_1 = self.timing_delay_nozzle_1 + timing_rel\n        elif nozzle == 2: \n            current_timing = self.timing_delay_nozzle_2\n            self.timing_delay_nozzle_2 = self.timing_delay_nozzle_2 + timing_rel\n        else: \n            print('no valid nozzle selected.')\n            return\n\n        # update timings\n        self.set_timing_update()\n\n\n    def logging_string(self):\n        \"\"\"\n        Creating the string to post to the e-log. \n\n        Parameters\n        ----------\n        Returns: \n        post : string\n            String with useful logging information for posting into the e-log \n        \"\"\"\n        post_str = ''\n\n        # Info to be posted: \n\n        # Nozzle angles: \n        position = self.codi.get_CoDI_pos()\n        position_str = 'Codi Information: \\n CoDI data: name: ' + str(position[0]) + '\\n rot_base: '+ str(position[1])+ '\\n rot_left: '+ str(position[2]) + '\\n rot_right: '+ str(position[3])+ '\\n z-transl: '+ str(position[4]) \n        post_str = post_str + position_str +' \\n '\n\n        #Timings:\n        post_str = post_str + 'Timing:' + ' \\n '\n        post_str = post_str + 'timing_Xray:' + str(self.timing_Xray) +' \\n '\n        post_str = post_str + 'timing_nozzle_1:' + str(self.timing_nozzle_1) +' \\n '\n        post_str = post_str + 'timing_nozzle_2:' + str(self.timing_nozzle_2) +' \\n '\n        post_str = post_str + 'timing_LED:' + str(self.timing_LED) +' \\n '\n        post_str = post_str + 'timing_delay_LED:' + str(self.timing_delay_LED) +' \\n '\n        post_str = post_str + 'timing_delay_reaction:' + str(self.timing_delay_reaction) +' \\n '        \n        post_str = post_str + 'timing_delay_nozzle_1:' + str(self.timing_delay_nozzle_1) +' \\n '   \n        post_str = post_str + 'timing_delay_nozzle_2:' + str(self.timing_delay_nozzle_2) +' \\n '   \n\n        return post_str\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.__init__","title":"<code>__init__(modules='None', ip='172.21.72.187', port=9999, supported_json='/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json')</code>","text":"<p>Class definition of the DoD robot Parameters</p> <p>modules : string     Defines the optional modules of the robot.      Options: 'None', 'codi', ,  ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"</p> Source code in <code>dod/dod.py</code> <pre><code>    def __init__(self, modules = 'None', ip = \"172.21.72.187\", port = 9999, supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n):\n        \"\"\"\n        Class definition of the DoD robot\n        Parameters\n        ----------\n        modules : string\n            Defines the optional modules of the robot. \n            Options: 'None', 'codi', , \n        ip = \"172.21.72.187\" , port = 9999, supported_json = \"supported.json\"            \n        \"\"\"\n        from dod.DropsDriver import myClient\n        from dod.JsonFileHandler import JsonFileHandler\n        from dod.ServerResponse import ServerResponse\n\n        import time\n\n        # Create object \n        # pytest encourages this pattern, apologies.\n        # ip = \"172.21.72.187\" #\"172.21.148.101\"\n        # port = 9999\n        # supported_json = '/cds/group/pcds/pyps/apps/hutch-python/mfx/dod/supported.json'\n\n        # User input parameters: \n        # Safety parameters in hutch coordinate system. \n        # Note: hutch (x,y,z) = robot (x,-z, y) \n        # \n        self.y_min     = 10000 # minimum value in y.\n        self.y_safety  = 50000 # value in y, above which the robot can only be in vertical configuration\n        self.y_max     = 50000 # maximum value in y\n\n        #Initialize safety regions for horizontal and vertical rotation: \n        self.forbidden_regions_horizontal = []\n        self.forbidden_regions_vertical = []\n        #minimum region: \n        self.set_forbidden_region(0, 300000, 0, self.y_min,rotation_state='both')\n        #maximum region: \n        self.set_forbidden_region(0, 300000, self.y_max, 500000,rotation_state='both')\n        #region where horizontal rotation is forbidden: \n        self.set_forbidden_region(0, 300000,  self.y_safety, self.y_max,rotation_state='horizontal')\n\n        # Initializing the robot client that is used for communication\n        self.client = myClient(ip=ip, port=port, supported_json=supported_json, reload=False)\n\n        # create config parser handler\n        json_handler = JsonFileHandler(supported_json)\n        # load configs and launch web server\n        json_handler.reload_endpoints()\n\n        # Flag that can be used later on for safety aborts during task execution\n        self.safety_abort = False\n        if modules == 'codi': \n            from dod.codi import CoDI\n            self.codi = CoDI()\n\n        # Timing section\n        from pcdsdevices.evr import Trigger\n        self.delay = None\n\n        # Trigger objects\n        self.trigger_Xray = Trigger('MFX:LAS:EVR:01:TRIG7', name='trigger_X-ray_simulator')\n        self.trigger_nozzle_1 = Trigger('MFX:LAS:EVR:01:TRIG2', name='trigger_nozzle_1')\n        self.trigger_nozzle_2 = Trigger('MFX:LAS:EVR:01:TRIG3', name='trigger_nozzle_2')\n        self.trigger_LED = Trigger('MFX:LAS:EVR:01:TRIG1', name='trigger_LED_array')\n\n        # Timing parameter\n        self.timing_Xray = self.trigger_Xray.ns_delay.get()\n        self.timing_nozzle_1 = self.trigger_nozzle_1.ns_delay.get()\n        self.timing_nozzle_2 = self.trigger_nozzle_2.ns_delay.get()\n        self.timing_LED = self.trigger_LED.ns_delay.get()\n        self.timing_delay_sciPulse = 60600\n        self.timing_delay_LED = 1000 #delay of LED relative to X-ray timing\n        self.timing_delay_reaction = 0\n        self.timing_delay_nozzle_1 = self.timing_Xray - self.timing_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n        self.timing_delay_nozzle_2 = self.timing_Xray - self.timing_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.busy_wait","title":"<code>busy_wait(timeout)</code>","text":"<p>Busy wait untill timeout value is reached, timeout : sec returns true if timeout occured</p> Source code in <code>dod/dod.py</code> <pre><code>def busy_wait(self, timeout):\n    '''\n        Busy wait untill timeout value is reached,\n        timeout : sec\n        returns true if timeout occured\n    '''\n    import time\n    start = time.time()\n    r = self.client.get_status()\n    delta = 0\n\n    while(r.STATUS['Status'] == \"Busy\"):\n        if delta &gt; timeout:\n            return True\n\n        time.sleep(0.1) #Wait a ms to stop spamming robot\n        r = self.client.get_status()\n        delta = time.time() - start    \n    return False\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.clear_abort","title":"<code>clear_abort(verbose=True)</code>","text":"<p>clear abort flag Parameters verbose : boolean    Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      status readback after error cleared '''</p> Source code in <code>dod/dod.py</code> <pre><code>def clear_abort(self, verbose = True):\n    \"\"\"\n    clear abort flag\n    Parameters\n    verbose : boolean\n       Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n        status readback after error cleared\n    '''\n    \"\"\"\n    r = self.client.connect(\"Test\")\n    r = self.client.get_status()\n    self.safety_abort = False\n    rr = self.client.disconnect()\n\n    if verbose == True: \n        return r\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.do_move","title":"<code>do_move(position, safety_test=False, verbose=False)</code>","text":"<pre><code>Moves robot to new position\n</code></pre> <p>Parameters position : string     Position name to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def do_move(self, position, safety_test = False, verbose = False):\n    '''\n        Moves robot to new position\n\n    Parameters\n    position : string\n        Position name to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n\n    if safety_test == False:  \n        r = self.client.move(position)\n    else: \n        print('safety test of move has yet to be implemented')\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(15)\n\n    r = self.client.get_current_positions()\n    new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.do_task","title":"<code>do_task(task_name, safety_check=False, verbose=False)</code>","text":"<p>Executes a task of the robot</p> <p>Parameters task_name : string     task name which robot is supposed to perform safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r :</p> Source code in <code>dod/dod.py</code> <pre><code>def do_task(self, task_name, safety_check = False, verbose = False):\n    '''\n    Executes a task of the robot\n\n    Parameters\n    task_name : string\n        task name which robot is supposed to perform\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : \n    '''\n    import time\n\n    rr = self.client.connect(\"Test\")\n    if safety_check == False: \n        r = self.client.execute_task(task_name)\n    else: \n        print('safety check needs to be implemented')\n\n    ## Wait for task to be done\n    while(r.STATUS['Status'] == \"Busy\"):\n        #Possible if loop is not enterd?\n        time.sleep(0.5)\n        r = self.client.get_status()\n        if self.safety_abort == True: \n            r = self.client.stop_task()\n            print('User aborted task execution')\n            return r\n\n    r = self.client.get_status()\n\n    #Check if any error occured\n    if r.ERROR_CODE == 0:\n        print('no error')\n    else: \n        print('error while performing task!')\n\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_current_position","title":"<code>get_current_position(verbose=False)</code>","text":"<p>Returns current robot position name and properties of the last selected position, together with the real current position coordinates Parameters</p> boolean <p>Defines whether the function returns the full output, or only the results</p> <pre><code>----------\n</code></pre> <p>Returns:  r :      returns the current position.         </p>"},{"location":"dod.html#dod.dod.DoD.get_current_position--expected_keys","title":"expected_keys = [","text":""},{"location":"dod.html#dod.dod.DoD.get_current_position--currentposition","title":"'CurrentPosition',","text":""},{"location":"dod.html#dod.dod.DoD.get_current_position--position","title":"'Position',","text":""},{"location":"dod.html#dod.dod.DoD.get_current_position--positionreal","title":"'PositionReal',","text":""},{"location":"dod.html#dod.dod.DoD.get_current_position--_1","title":"]","text":"Source code in <code>dod/dod.py</code> <pre><code>def get_current_position(self, verbose = False):\n    '''\n    Returns current robot position\n    name and properties of the last selected position, together with the real current position coordinates\n    Parameters\n\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : \n        returns the current position.         \n    # expected_keys = [\n    #         'CurrentPosition',\n    #         'Position',\n    #         'PositionReal',\n    #         ]\n    '''\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_forbidden_region","title":"<code>get_forbidden_region(rotation_state='both')</code>","text":"<p>returns forbidden regions in the robot coordinate x y plane for end-point testing  defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop returns the region depending on the rotation state, as some regions are forbidden only in one configuration</p> <p>Parameters rotation_state: string     options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"</p> Source code in <code>dod/dod.py</code> <pre><code>def get_forbidden_region(self, rotation_state = 'both'): \n    \"\"\"\n    returns forbidden regions in the robot coordinate x y plane for end-point testing \n    defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n    returns the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n    Parameters\n    rotation_state: string\n        options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n    ----------\n\n    \"\"\"\n\n    #combine the lists depending on the rotation \n    if rotation_state == \"vertical\": \n        test_list_safety = self.forbidden_regions_vertical\n    elif rotation_state == \"horizontal\": \n        test_list_safety = self.forbidden_regions_horizontal\n    else:\n        test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n    return test_list_safety\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_nozzle_status","title":"<code>get_nozzle_status(verbose=False)</code>","text":"<p>Returns current nozzle parameters position Parameters</p> boolean <p>Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      returns the current nozzle parameters.         </p>"},{"location":"dod.html#dod.dod.DoD.get_nozzle_status--expected_keys","title":"expected_keys = [","text":"<pre><code>    \"Activated Nozzles\",\n    \"Selected Nozzles\",\n    \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n    \"Dispensing\",\n    ]\n</code></pre> Source code in <code>dod/dod.py</code> <pre><code>def get_nozzle_status(self, verbose = False):\n    '''\n    Returns current nozzle parameters position\n    Parameters\n\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n        returns the current nozzle parameters.         \n    #         expected_keys = [\n            \"Activated Nozzles\",\n            \"Selected Nozzles\",\n            \"ID,Volt,Pulse,Freq,Volume\",  # Intreseting? all one key\n            \"Dispensing\",\n            ]\n    '''\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_nozzle_status()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_status","title":"<code>get_status(verbose=False)</code>","text":"<p>returns the robot state</p> <p>Parameters verbose : boolean    Defines whether the function returns the full output, or only the results</p> <p>Returns:  r : dict     different states of the robot</p> Source code in <code>dod/dod.py</code> <pre><code>def get_status(self, verbose = False):\n    \"\"\"\n    returns the robot state\n\n    Parameters\n    verbose : boolean\n       Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : dict\n        different states of the robot\n    \"\"\"\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_status()\n    # expected_keys = [\n    #     'Position',\n    #     'RunningTask',\n    #     'Dialog',\n    #     'LastProbe',\n    #     'Humidity',\n    #     'Temperature',\n    #     'BathTemp',\n    #     ]\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_task_details","title":"<code>get_task_details(task_name, verbose=False)</code>","text":"<p>This gets the details of a task from the robot to see the scripted routines Parameters task_name : string     Name of the task that we want to get verbose : boolean     Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :      returns the robot tasks</p> Source code in <code>dod/dod.py</code> <pre><code>def get_task_details(self, task_name, verbose = False):\n    \"\"\"\n        This gets the details of a task from the robot to see the scripted routines\n        Parameters\n        task_name : string\n            Name of the task that we want to get\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : \n            returns the robot tasks\n    \"\"\"\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_task_details(task_name)\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.get_task_names","title":"<code>get_task_names(verbose=False)</code>","text":"<p>This gets the names of available tasks from the robot Parameters task_name : string     Name of the task that we want to get verbose : boolean     Defines whether the function returns the full output, or only the results</p> <p>Returns:  r : dict     returns the robot tasks</p> Source code in <code>dod/dod.py</code> <pre><code>def get_task_names(self, verbose = False):\n    \"\"\"\n        This gets the names of available tasks from the robot\n        Parameters\n        task_name : string\n            Name of the task that we want to get\n        verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n        Returns: \n        r : dict\n            returns the robot tasks\n    \"\"\"\n    # Check if reponse is not an empty array or any errors occured\n    rr = self.client.connect(\"Test\")\n    r = self.client.get_task_names()\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.logging_string","title":"<code>logging_string()</code>","text":"<p>Creating the string to post to the e-log. </p>"},{"location":"dod.html#dod.dod.DoD.logging_string--parameters","title":"Parameters","text":"<p>Returns:  post : string     String with useful logging information for posting into the e-log</p> Source code in <code>dod/dod.py</code> <pre><code>def logging_string(self):\n    \"\"\"\n    Creating the string to post to the e-log. \n\n    Parameters\n    ----------\n    Returns: \n    post : string\n        String with useful logging information for posting into the e-log \n    \"\"\"\n    post_str = ''\n\n    # Info to be posted: \n\n    # Nozzle angles: \n    position = self.codi.get_CoDI_pos()\n    position_str = 'Codi Information: \\n CoDI data: name: ' + str(position[0]) + '\\n rot_base: '+ str(position[1])+ '\\n rot_left: '+ str(position[2]) + '\\n rot_right: '+ str(position[3])+ '\\n z-transl: '+ str(position[4]) \n    post_str = post_str + position_str +' \\n '\n\n    #Timings:\n    post_str = post_str + 'Timing:' + ' \\n '\n    post_str = post_str + 'timing_Xray:' + str(self.timing_Xray) +' \\n '\n    post_str = post_str + 'timing_nozzle_1:' + str(self.timing_nozzle_1) +' \\n '\n    post_str = post_str + 'timing_nozzle_2:' + str(self.timing_nozzle_2) +' \\n '\n    post_str = post_str + 'timing_LED:' + str(self.timing_LED) +' \\n '\n    post_str = post_str + 'timing_delay_LED:' + str(self.timing_delay_LED) +' \\n '\n    post_str = post_str + 'timing_delay_reaction:' + str(self.timing_delay_reaction) +' \\n '        \n    post_str = post_str + 'timing_delay_nozzle_1:' + str(self.timing_delay_nozzle_1) +' \\n '   \n    post_str = post_str + 'timing_delay_nozzle_2:' + str(self.timing_delay_nozzle_2) +' \\n '   \n\n    return post_str\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.move_x_abs","title":"<code>move_x_abs(position_x, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute x position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_x_abs(self, position_x, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute x position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_x(position_x)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(position_x, y_current): \n            r = self.client.move_x(position_x)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.move_y_abs","title":"<code>move_y_abs(position_y, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute x position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_y_abs(self, position_y, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute x position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_y(position_y)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(x_current, position_y): \n            r = self.client.move_y(position_y)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.move_z_abs","title":"<code>move_z_abs(position_z, safety_test=False, verbose=False)</code>","text":"<pre><code>Robot coordinate system!!!: \nMoves robot to new absolute Z position. \nNo safety test.\n</code></pre> <p>Parameters position : int     Absolute position in um(?) to which the robot is supposed to move safety_test : Boolean     question whether a safety test is to be performed or not     True: Test will be performed     False: Not performed verbose : boolean         Defines whether the function returns the full output, or only the results     ---------- Returns:  r : current position</p> Source code in <code>dod/dod.py</code> <pre><code>def move_z_abs(self, position_z, safety_test = False, verbose = False):\n    '''\n        Robot coordinate system!!!: \n        Moves robot to new absolute Z position. \n        No safety test. \n\n    Parameters\n    position : int\n        Absolute position in um(?) to which the robot is supposed to move\n    safety_test : Boolean\n        question whether a safety test is to be performed or not\n        True: Test will be performed\n        False: Not performed\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n        ----------\n    Returns: \n    r : current position\n    '''\n\n    r = self.client.connect(\"Test\")\n    r = self.client.get_current_positions()\n    current_real_position = r.RESULTS['PositionReal']\n    x_current, y_current, z_current = current_real_position\n\n    if safety_test == False:  \n        r = self.client.move_z(position_z)\n    else: \n        print('safety test of move has yet to be implemented')\n        if self.test_forbidden_region(x_current, y_current): \n            r = self.client.move_z(position_z)\n\n\n    # WAIT FOR MOVEMENT TO BE DONE\n    self.busy_wait(25)\n\n    # r = self.client.get_current_positions()\n    # new_real_position = r.RESULTS['PositionReal']\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_forbidden_region","title":"<code>set_forbidden_region(x_start, x_stop, y_start, y_stop, rotation_state='both')</code>","text":"<p>set a forbidden region in the robot coordinate x y plane for end-point testing  defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop set the region depending on the rotation state, as some regions are forbidden only in one configuration</p> <p>Parameters x_start : float     x-position start  x_stop : float     x-position stop y_start : float     y-position start  y_stop : float     y-position stop rotation_state: string     options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"</p> Source code in <code>dod/dod.py</code> <pre><code>def set_forbidden_region(self, x_start, x_stop, y_start, y_stop, rotation_state = 'both'): \n    \"\"\"\n    set a forbidden region in the robot coordinate x y plane for end-point testing \n    defined via a rectangle in the x-y-plane. x_start&lt;x_stop, y_start&lt;y_stop\n    set the region depending on the rotation state, as some regions are forbidden only in one configuration\n\n    Parameters\n    x_start : float\n        x-position start \n    x_stop : float\n        x-position stop\n    y_start : float\n        y-position start \n    y_stop : float\n        y-position stop\n    rotation_state: string\n        options are \"horizontal\" (nozzle sideways, base 90 degrees), \"vertical\" (nozzle vertical, base 0 degree), \"both\"\n    ----------\n\n    \"\"\"\n    region_tuple = (min(x_start,x_stop), max(x_start,x_stop), min(y_start,y_stop), max(y_start,y_stop))\n    if rotation_state == \"horizontal\": \n        self.forbidden_regions_horizontal.append(region_tuple)\n    elif rotation_state == \"vertical\": \n        self.forbidden_regions_vertical.append(region_tuple)\n    elif rotation_state == \"both\": \n        self.forbidden_regions_vertical.append(region_tuple)\n        self.forbidden_regions_horizontal.append(region_tuple)\n    else:\n        print('invalid input of rotation state')\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_nozzle_dispensing","title":"<code>set_nozzle_dispensing(mode='Off', verbose=False)</code>","text":"<p>Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\" Parameters mode : string      either \"free\", \"triggered\", or \"off\" verbose : boolean         Defines whether the function returns the full output, or only the results</p> <p>Returns:  r :</p> Source code in <code>dod/dod.py</code> <pre><code>def set_nozzle_dispensing(self, mode = \"Off\", verbose = False):\n    '''\n    Sets the dispensing, either \"Free\", \"Triggered\", or \"Off\"\n    Parameters\n    mode : string \n        either \"free\", \"triggered\", or \"off\"\n    verbose : boolean\n            Defines whether the function returns the full output, or only the results\n    ----------\n    Returns: \n    r : \n    '''\n    rr = self.client.connect(\"Test\")\n    if mode == 'Free': \n        r = self.client.dispensing('Free')\n    elif mode == 'Triggered':\n        r = self.client.dispensing('Triggered')\n    else: \n        #turns active nozzles off. Safer if all nozzles would be turned off\n        r = self.client.dispensing('Off')\n        for i in [1,2,3,4]: \n            r = self.client.select_nozzle(i)\n            r = self.client.dispensing('Off')\n\n    rr = self.client.disconnect()\n    if verbose == True: \n        return r\n    else: \n        return r.RESULTS\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_abs_Xray","title":"<code>set_timing_abs_Xray(timing_abs)</code>","text":"<p>Setting the absolute timing of the X-rays for claculation purposes</p> <p>Parameters timing_abs : float     abs timing in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_abs_Xray(self, timing_abs): \n    \"\"\"\n    Setting the absolute timing of the X-rays for claculation purposes\n\n    Parameters\n    timing_abs : float\n        abs timing in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_Xray = timing_abs #delay of LED relative to X-ray timing\n    #self.trigger_Xray.ns_delay.put(self.timing_Xray)\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_rel_LED","title":"<code>set_timing_rel_LED(timing_rel)</code>","text":"<p>Setting the relative timing of the LED relative to the X-rays</p> <p>Parameters timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_rel_LED(self, timing_rel): \n    \"\"\"\n    Setting the relative timing of the LED relative to the X-rays\n\n    Parameters\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_delay_LED = timing_rel #delay of LED relative to X-ray timing\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_rel_reaction","title":"<code>set_timing_rel_reaction(timing_rel)</code>","text":"<p>Setting the relative timing of the reaction relative to the X-rays</p> <p>Parameters timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_rel_reaction(self, timing_rel): \n    \"\"\"\n    Setting the relative timing of the reaction relative to the X-rays\n\n    Parameters\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    self.timing_delay_reaction = timing_rel #delay of LED relative to X-ray timing\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_relative_nozzle","title":"<code>set_timing_relative_nozzle(nozzle, timing_rel)</code>","text":"<p>Changing the timing of the selected nozzle by a relative amount </p> <p>Parameters nozle : int     nozzle number timing_rel : float     relative change in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_relative_nozzle(self, nozzle, timing_rel): \n    \"\"\"\n    Changing the timing of the selected nozzle by a relative amount \n\n    Parameters\n    nozle : int\n        nozzle number\n    timing_rel : float\n        relative change in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    if nozzle == 1: \n        current_timing = self.timing_delay_nozzle_1\n        self.timing_delay_nozzle_1 = self.timing_delay_nozzle_1 + timing_rel\n    elif nozzle == 2: \n        current_timing = self.timing_delay_nozzle_2\n        self.timing_delay_nozzle_2 = self.timing_delay_nozzle_2 + timing_rel\n    else: \n        print('no valid nozzle selected.')\n        return\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_update","title":"<code>set_timing_update()</code>","text":"<p>updating the timing triggers according to the set relative and absolute timing values</p> <p>Parameters        ---------- Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_update(self): \n    \"\"\"\n    updating the timing triggers according to the set relative and absolute timing values\n\n    Parameters\n           ----------\n    Returns: \n    \"\"\"\n    # Nozzle 1\n    self.timing_nozzle_1 = self.timing_Xray - self.timing_delay_nozzle_1 - self.timing_delay_sciPulse - self.timing_delay_reaction\n    if self.timing_nozzle_1 &lt; 0: \n        self.timing_nozzle_1 = self.timing_nozzle_1 + 1/120*1000000000\n    self.trigger_nozzle_1.ns_delay.put(self.timing_nozzle_1)\n\n    # Nozzle 2\n    self.timing_nozzle_2 = self.timing_Xray - self.timing_delay_nozzle_2 - self.timing_delay_sciPulse - self.timing_delay_reaction\n    if self.timing_nozzle_2 &lt; 0: \n        self.timing_nozzle_2 = self.timing_nozzle_2 + 1/120*1000000000\n    self.trigger_nozzle_2.ns_delay.put(self.timing_nozzle_2)\n\n    # LED\n    self.timing_LED = self.timing_Xray + self.timing_delay_LED\n    self.trigger_LED.ns_delay.put(self.timing_LED)\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.set_timing_zero_nozzle","title":"<code>set_timing_zero_nozzle(nozzle, timing_rel)</code>","text":"<p>Setting the time zero for the nozzles from the LED alignment in robot</p> <p>Parameters nozle : int     nozzle number timing_rel : float     relative delay in ns from robot alignment</p> <p>Returns:</p> Source code in <code>dod/dod.py</code> <pre><code>def set_timing_zero_nozzle(self, nozzle, timing_rel): \n    \"\"\"\n    Setting the time zero for the nozzles from the LED alignment in robot\n\n    Parameters\n    nozle : int\n        nozzle number\n    timing_rel : float\n        relative delay in ns from robot alignment\n    ----------\n    Returns: \n    \"\"\"\n    if nozzle == 1: \n        self.timing_delay_nozzle_1 = timing_rel\n    elif nozzle == 2: \n        self.timing_delay_nozzle_2 = timing_rel\n    else: \n        print('no valid nozzle selected.')\n        return\n\n    # update timings\n    self.set_timing_update()\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.stop_task","title":"<code>stop_task(verbose=True)</code>","text":"<p>Stop task while running ** ISSUES ** -  When stop task  is called, the Robot stays in \"BUSY\" Status. Parameters</p> <p>verbose : boolean     Defines whether the function returns the full output, or only the results Returns:  r :      status readback when aborted</p> Source code in <code>dod/dod.py</code> <pre><code>def stop_task(self, verbose = True):\n    \"\"\"\n    Stop task while running\n    ** ISSUES **\n    -  When stop task  is called, the Robot stays in \"BUSY\" Status.\n    Parameters\n    ----------\n    verbose : boolean\n        Defines whether the function returns the full output, or only the results\n    Returns: \n    r : \n        status readback when aborted\n    \"\"\"\n    r = self.client.connect(\"Test\")\n    self.safety_abort = False\n    r = self.client.stop_task()\n    r = self.client.disconnect()\n    if verbose == True: \n        return r\n</code></pre>"},{"location":"dod.html#dod.dod.DoD.test_forbidden_region","title":"<code>test_forbidden_region(x_test, y_test)</code>","text":"<p>tests if the end point of a motion is inside a forbidden region No testing of the path of a motion included!</p> <p>Parameters x_test : float     x-position to test  y_test : float      y-position to test </p> <p>Returns:  safe_motion : bool     boolean flag if endpoint of motion is safe or not</p> Source code in <code>dod/dod.py</code> <pre><code>def test_forbidden_region(self, x_test, y_test): \n    \"\"\"\n    tests if the end point of a motion is inside a forbidden region\n    No testing of the path of a motion included!\n\n    Parameters\n    x_test : float\n        x-position to test \n    y_test : float \n        y-position to test \n\n    ----------\n    Returns: \n    safe_motion : bool\n        boolean flag if endpoint of motion is safe or not\n    \"\"\"\n    from dod.codi import CoDI_base\n    # Get current rotation state\n    pos_rot_base  = round(CoDI_base.wm(),0)\n\n    #Initialize safe flag (True = safe)\n    flag_safe_endpoint = True\n\n    #combine the lists depending on the rotation \n    if pos_rot_base == 90: \n        test_list_safety = self.forbidden_regions_vertical\n    elif pos_rot_base == 0:\n        test_list_safety = self.forbidden_regions_horizontal\n    else:\n        test_list_safety = self.forbidden_regions_horizontal + self.forbidden_regions_vertical\n\n    #Test for all regions if the end point is in the forbidden region\n    for tuple_current in test_list_safety: \n        x_start, x_stop, y_start, y_stop = tuple_current\n        if ((x_start &lt; x_test) and (x_stop &gt; x_test) and (y_start &lt; y_test) and (y_stop &gt; y_test)): \n            flag_safe_endpoint = flag_safe_endpoint and False\n        else:\n            flag_safe_endpoint = flag_safe_endpoint and True\n\n    return flag_safe_endpoint\n</code></pre>"},{"location":"door_watcher.html","title":"Door watcher","text":""},{"location":"door_watcher.html#scripts.door_watcher.door_watcher.Watchman","title":"<code>Watchman</code>","text":"Source code in <code>scripts/door_watcher/door_watcher.py</code> <pre><code>class Watchman:\n    cbid = None\n    retries = 3\n\n    def __init__(self, door_state, voltage_read, voltage_write):\n        self.door_state = EpicsSignalRO(door_state)\n        self.mesh_voltage = EpicsSignal(voltage_read,\n                                        write_pv=voltage_write)\n        print('Using door pv {}'.format(door_state))\n\n    def start(self):\n        \"\"\"Sets up self.callback to be run when door state changes\"\"\"\n        # Make sure we don't start 2 processes\n        self.stop()\n        print('Starting door watcher')\n        self.door_state.subscribe(self.callback)\n\n    def callback(self, old_value=None, value=None, **kwargs):\n        \"\"\"To be run every time the door state changes\"\"\"\n        print('Door PV changed from {} to {}'.format(old_value, value))\n        if old_value == 1 and value == 0:\n            print('Zeroing the mesh voltage because door was opened')\n            # Let's retry a few times in case of a network error\n            for i in range(self.retries):\n                try:\n                    self.mesh_voltage.put(0)\n                except Exception:\n                    pass\n\n    def stop(self):\n        \"\"\"Shutdown the watcher\"\"\"\n        if self.cbid is not None:\n            print('Stopping door watcher')\n            self.door_state.unsubscribe(self.cbid)\n            self.cbid = None\n</code></pre>"},{"location":"door_watcher.html#scripts.door_watcher.door_watcher.Watchman.callback","title":"<code>callback(old_value=None, value=None, **kwargs)</code>","text":"<p>To be run every time the door state changes</p> Source code in <code>scripts/door_watcher/door_watcher.py</code> <pre><code>def callback(self, old_value=None, value=None, **kwargs):\n    \"\"\"To be run every time the door state changes\"\"\"\n    print('Door PV changed from {} to {}'.format(old_value, value))\n    if old_value == 1 and value == 0:\n        print('Zeroing the mesh voltage because door was opened')\n        # Let's retry a few times in case of a network error\n        for i in range(self.retries):\n            try:\n                self.mesh_voltage.put(0)\n            except Exception:\n                pass\n</code></pre>"},{"location":"door_watcher.html#scripts.door_watcher.door_watcher.Watchman.start","title":"<code>start()</code>","text":"<p>Sets up self.callback to be run when door state changes</p> Source code in <code>scripts/door_watcher/door_watcher.py</code> <pre><code>def start(self):\n    \"\"\"Sets up self.callback to be run when door state changes\"\"\"\n    # Make sure we don't start 2 processes\n    self.stop()\n    print('Starting door watcher')\n    self.door_state.subscribe(self.callback)\n</code></pre>"},{"location":"door_watcher.html#scripts.door_watcher.door_watcher.Watchman.stop","title":"<code>stop()</code>","text":"<p>Shutdown the watcher</p> Source code in <code>scripts/door_watcher/door_watcher.py</code> <pre><code>def stop(self):\n    \"\"\"Shutdown the watcher\"\"\"\n    if self.cbid is not None:\n        print('Stopping door watcher')\n        self.door_state.unsubscribe(self.cbid)\n        self.cbid = None\n</code></pre>"},{"location":"focus_scan.html","title":"Focus scan","text":""},{"location":"focus_scan.html#mfx.focus_scan.focus_scan","title":"<code>focus_scan(camera, start=1, end=299, step=1)</code>","text":"<p>Runs through transfocator Z to find the best focus</p>"},{"location":"focus_scan.html#mfx.focus_scan.focus_scan--parameters","title":"Parameters","text":"<p>camera: str, required     camera where you want to focus</p> int, optional <p>step size of transfocator movements</p> int, optional <p>starting transfocator position</p> int, optional <p>final transfocator position</p> <p>Examples: mfx dg1 yag is MFX:DG1:P6740 mfx dg2 yag is MFX:DG2:P6740 mfx dg3 yag is MFX:GIGE:02:IMAGE1</p>"},{"location":"focus_scan.html#mfx.focus_scan.focus_scan--operations","title":"Operations","text":"Source code in <code>mfx/focus_scan.py</code> <pre><code>def focus_scan(camera, start=1, end=299, step=1):\n    \"\"\"\n    Runs through transfocator Z to find the best focus\n\n    Parameters\n    ----------\n    camera: str, required\n        camera where you want to focus\n\n    step: int, optional\n\tstep size of transfocator movements\n\n    start: int, optional\n\tstarting transfocator position\n\n    end: int, optional\n\tfinal transfocator position\n\n    Examples:\n    mfx dg1 yag is MFX:DG1:P6740\n    mfx dg2 yag is MFX:DG2:P6740\n    mfx dg3 yag is MFX:GIGE:02:IMAGE1\n\n    Operations\n    ----------\n\n    \"\"\"\n    # cd /reg/g/pcds/pyps/apps/hutch-python/mfx/mfx\n    # from mfx.transfocator_scan import *\n    from mfx.transfocator_scan import transfocator_aligner\n    import numpy as np\n    from mfx.db import tfs\n\n    trf_align = transfocator_aligner(camera)\n    trf_pos = np.arange(start, end, step)\n    trf_align.scan_transfocator(tfs.translation,trf_pos,1)\n</code></pre>"},{"location":"idler.html","title":"Idler","text":""},{"location":"lens.html","title":"Lens","text":"<p>Basic Lens object handling</p>"},{"location":"lens.html#tfs.lens.LensCalcMixin","title":"<code>LensCalcMixin</code>","text":"Source code in <code>tfs/lens.py</code> <pre><code>class LensCalcMixin():\n    def __init__(self, *args, **kwargs):\n        \"\"\"\n        Mixin class to abstract focal length calculation from a variety of \n        lens devices.\n\n        Relies on the following methods / attributes from the child class:\n        - self.radius\n        - self.z\n        \"\"\"\n        return\n\n    def focus(self, energy):\n        return ut.focal_length(self.radius, energy)\n\n    def image_from_obj(self, z_obj, energy):\n        \"\"\"\n        Method calculates the image distance in meters along the beam pipeline\n        from a point of origin given the focal length of the lens, location of\n        lens, and location of object.\n\n        Parameters\n        ----------\n        z_obj\n            Location of object along the beamline in meters (m)\n\n        Returns\n        -------\n        image\n            Returns the distance z_im of the image along the beam pipeline from\n            a point of origin in meters (m)\n        Note\n        ----\n        If the location of the object (z_obj) is equal to the focal length of\n        the lens, this function will return infinity.\n        \"\"\"\n        # Find the object location for the lens\n        obj = self.z - z_obj\n        # Check if the lens object is at the focal length\n        # If this happens, then the image location will be infinity.\n        # Note, this should not effect the recursive calculations that occur\n        # later in the code\n        if obj == self.focus(energy):\n            return np.inf\n        # Calculate the location of the focal plane\n        plane = 1/(1/self.focus(energy) - 1/obj)\n        # Find the position in accelerator coordinates\n        return plane + self.z\n</code></pre>"},{"location":"lens.html#tfs.lens.LensCalcMixin.__init__","title":"<code>__init__(*args, **kwargs)</code>","text":"<p>Mixin class to abstract focal length calculation from a variety of  lens devices.</p> <p>Relies on the following methods / attributes from the child class: - self.radius - self.z</p> Source code in <code>tfs/lens.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"\n    Mixin class to abstract focal length calculation from a variety of \n    lens devices.\n\n    Relies on the following methods / attributes from the child class:\n    - self.radius\n    - self.z\n    \"\"\"\n    return\n</code></pre>"},{"location":"lens.html#tfs.lens.LensCalcMixin.image_from_obj","title":"<code>image_from_obj(z_obj, energy)</code>","text":"<p>Method calculates the image distance in meters along the beam pipeline from a point of origin given the focal length of the lens, location of lens, and location of object.</p>"},{"location":"lens.html#tfs.lens.LensCalcMixin.image_from_obj--parameters","title":"Parameters","text":"<p>z_obj     Location of object along the beamline in meters (m)</p>"},{"location":"lens.html#tfs.lens.LensCalcMixin.image_from_obj--returns","title":"Returns","text":"<p>image     Returns the distance z_im of the image along the beam pipeline from     a point of origin in meters (m) Note</p> <p>If the location of the object (z_obj) is equal to the focal length of the lens, this function will return infinity.</p> Source code in <code>tfs/lens.py</code> <pre><code>def image_from_obj(self, z_obj, energy):\n    \"\"\"\n    Method calculates the image distance in meters along the beam pipeline\n    from a point of origin given the focal length of the lens, location of\n    lens, and location of object.\n\n    Parameters\n    ----------\n    z_obj\n        Location of object along the beamline in meters (m)\n\n    Returns\n    -------\n    image\n        Returns the distance z_im of the image along the beam pipeline from\n        a point of origin in meters (m)\n    Note\n    ----\n    If the location of the object (z_obj) is equal to the focal length of\n    the lens, this function will return infinity.\n    \"\"\"\n    # Find the object location for the lens\n    obj = self.z - z_obj\n    # Check if the lens object is at the focal length\n    # If this happens, then the image location will be infinity.\n    # Note, this should not effect the recursive calculations that occur\n    # later in the code\n    if obj == self.focus(energy):\n        return np.inf\n    # Calculate the location of the focal plane\n    plane = 1/(1/self.focus(energy) - 1/obj)\n    # Find the position in accelerator coordinates\n    return plane + self.z\n</code></pre>"},{"location":"lens.html#tfs.lens.LensConnect","title":"<code>LensConnect</code>","text":"<p>Data structure for a basic system of lenses</p>"},{"location":"lens.html#tfs.lens.LensConnect--parameters","title":"Parameters","text":"<p>args : Lens     Lens objects</p> Source code in <code>tfs/lens.py</code> <pre><code>class LensConnect:\n    \"\"\"\n    Data structure for a basic system of lenses\n\n    Parameters\n    ----------\n    args : Lens\n        Lens objects\n    \"\"\"\n    def __init__(self, *args):\n        \"\"\"\n        Parameters\n        ----------\n        args\n            Variable length argument list of the lenses in the system, their\n            radii, z position, and focal length.\n        \"\"\"\n        self.lenses = sorted(args, key=lambda lens: lens.z)\n\n    @property\n    def effective_radius(self):\n        \"\"\"\n        Method calculates the effective radius of the lens array\n        including prefocusing lens \n\n        Returns\n        -------\n        float\n            returns the effective radius of the lens array.\n        \"\"\"\n        if not self.lenses:\n            return 0.0\n        return 1/np.sum(np.reciprocal([float(l.radius) for l in self.lenses]))\n\n\n    @property\n    def tfs_radius(self):\n        \"\"\"\n        Method calculates the effective radius of the lens array\n        excluding prefocusing lens \n\n        Returns\n        -------\n        float\n            returns the effective radius of the lens array.\n        \"\"\"\n        if not self.lenses:\n            return 0.0\n        return 1/np.sum(np.reciprocal([float(l.radius) for l in self.lenses[1:]]))\n\n\n    def image(self, z_obj, energy):\n        \"\"\"\n        Method recursively calculates the z location of the image of a system\n        of lenses and returns it in meters (m)\n\n        Parameters\n        ----------\n        z_obj\n            Location of the object along the beam pipline from a designated\n            point of origin in meters (m)\n\n        Returns\n        -------\n        float\n            returns the location z of a system of lenses in meters (m).\n        \"\"\"\n        # Set the initial image as the z object\n        image = z_obj\n        # Determine the final output by looping through lenses\n        for lens in self.lenses:\n            image = lens.image_from_obj(image, energy)\n        return image\n\n    @property\n    def nlens(self):\n        \"\"\"\n        Method calculates the total number of lenses in the Lens array.\n\n        Returns\n        -------\n        int\n            Returns the total number of lenses in the array.\n        \"\"\"\n        return len(self.lenses)\n\n    def _info(self):\n        \"\"\"\n        Create a table with lens information\n        \"\"\"\n        # Create initial table\n        pt = prettytable.PrettyTable(['Prefix', 'Radius', 'Z'])\n        # Adjust table settings\n        pt.align = 'l'\n        pt.float_format = '8.5'\n        for lens in self.lenses:\n            pt.add_row([lens.prefix, lens.radius, lens.z])\n        return pt\n\n    def show_info(self):\n        \"\"\"\n        Show a table of information on the lens\n        \"\"\"\n        print(self._info())\n\n    @classmethod\n    def connect(cls, array1, array2):\n        \"\"\"\n        Create a new LensConnect from the combination of multiple\n        \"\"\"\n        return cls(*array1.lenses, *array2.lenses)\n</code></pre>"},{"location":"lens.html#tfs.lens.LensConnect.effective_radius","title":"<code>effective_radius</code>  <code>property</code>","text":"<p>Method calculates the effective radius of the lens array including prefocusing lens </p>"},{"location":"lens.html#tfs.lens.LensConnect.effective_radius--returns","title":"Returns","text":"<p>float     returns the effective radius of the lens array.</p>"},{"location":"lens.html#tfs.lens.LensConnect.nlens","title":"<code>nlens</code>  <code>property</code>","text":"<p>Method calculates the total number of lenses in the Lens array.</p>"},{"location":"lens.html#tfs.lens.LensConnect.nlens--returns","title":"Returns","text":"<p>int     Returns the total number of lenses in the array.</p>"},{"location":"lens.html#tfs.lens.LensConnect.tfs_radius","title":"<code>tfs_radius</code>  <code>property</code>","text":"<p>Method calculates the effective radius of the lens array excluding prefocusing lens </p>"},{"location":"lens.html#tfs.lens.LensConnect.tfs_radius--returns","title":"Returns","text":"<p>float     returns the effective radius of the lens array.</p>"},{"location":"lens.html#tfs.lens.LensConnect.__init__","title":"<code>__init__(*args)</code>","text":""},{"location":"lens.html#tfs.lens.LensConnect.__init__--parameters","title":"Parameters","text":"<p>args     Variable length argument list of the lenses in the system, their     radii, z position, and focal length.</p> Source code in <code>tfs/lens.py</code> <pre><code>def __init__(self, *args):\n    \"\"\"\n    Parameters\n    ----------\n    args\n        Variable length argument list of the lenses in the system, their\n        radii, z position, and focal length.\n    \"\"\"\n    self.lenses = sorted(args, key=lambda lens: lens.z)\n</code></pre>"},{"location":"lens.html#tfs.lens.LensConnect.connect","title":"<code>connect(array1, array2)</code>  <code>classmethod</code>","text":"<p>Create a new LensConnect from the combination of multiple</p> Source code in <code>tfs/lens.py</code> <pre><code>@classmethod\ndef connect(cls, array1, array2):\n    \"\"\"\n    Create a new LensConnect from the combination of multiple\n    \"\"\"\n    return cls(*array1.lenses, *array2.lenses)\n</code></pre>"},{"location":"lens.html#tfs.lens.LensConnect.image","title":"<code>image(z_obj, energy)</code>","text":"<p>Method recursively calculates the z location of the image of a system of lenses and returns it in meters (m)</p>"},{"location":"lens.html#tfs.lens.LensConnect.image--parameters","title":"Parameters","text":"<p>z_obj     Location of the object along the beam pipline from a designated     point of origin in meters (m)</p>"},{"location":"lens.html#tfs.lens.LensConnect.image--returns","title":"Returns","text":"<p>float     returns the location z of a system of lenses in meters (m).</p> Source code in <code>tfs/lens.py</code> <pre><code>def image(self, z_obj, energy):\n    \"\"\"\n    Method recursively calculates the z location of the image of a system\n    of lenses and returns it in meters (m)\n\n    Parameters\n    ----------\n    z_obj\n        Location of the object along the beam pipline from a designated\n        point of origin in meters (m)\n\n    Returns\n    -------\n    float\n        returns the location z of a system of lenses in meters (m).\n    \"\"\"\n    # Set the initial image as the z object\n    image = z_obj\n    # Determine the final output by looping through lenses\n    for lens in self.lenses:\n        image = lens.image_from_obj(image, energy)\n    return image\n</code></pre>"},{"location":"lens.html#tfs.lens.LensConnect.show_info","title":"<code>show_info()</code>","text":"<p>Show a table of information on the lens</p> Source code in <code>tfs/lens.py</code> <pre><code>def show_info(self):\n    \"\"\"\n    Show a table of information on the lens\n    \"\"\"\n    print(self._info())\n</code></pre>"},{"location":"lens.html#tfs.lens.LensTripLimits","title":"<code>LensTripLimits</code>","text":"<p>               Bases: <code>Device</code></p> <p>Trip limits for a given pre-focus lens (or lack thereof).</p> Source code in <code>tfs/lens.py</code> <pre><code>class LensTripLimits(Device):\n    \"\"\"Trip limits for a given pre-focus lens (or lack thereof).\"\"\"\n    # _table_name = Cpt(EpicsSignalRO, \":STR\", doc=\"Table name for trip information\")\n    low = Cpt(EpicsSignalRO, \":LOW\", doc=\"Trip region low [um]\", auto_monitor=False)\n    high = Cpt(EpicsSignalRO, \":HIGH\", doc=\"Trip region high [um]\", auto_monitor=False)\n</code></pre>"},{"location":"lens.html#tfs.lens.MFXLens","title":"<code>MFXLens</code>","text":"<p>               Bases: <code>InOutPVStatePositioner</code>, <code>LensCalcMixin</code></p> <p>Data structure for basic Lens object</p>"},{"location":"lens.html#tfs.lens.MFXLens--parameters","title":"Parameters","text":"<p>prefix : str     Name of the state record that controls the PV</p> str <p>Prefix for the PVs that contain focusing information</p> Source code in <code>tfs/lens.py</code> <pre><code>class MFXLens(InOutPVStatePositioner, LensCalcMixin):\n    \"\"\"\n    Data structure for basic Lens object\n\n    Parameters\n    ----------\n    prefix : str\n        Name of the state record that controls the PV\n\n    prefix_lens : str\n        Prefix for the PVs that contain focusing information\n    \"\"\"\n    # StatePositioner information\n    _inserted = Cpt(EpicsSignalRO, ':STATE')\n    _removed = Cpt(EpicsSignalRO, \":OUT\")\n    _insert = Cpt(EpicsSignal, ':INSERT')\n    _remove = Cpt(EpicsSignal, ':REMOVE')\n    _state_logic = {'_inserted': {0: 'defer',  1: 'IN'},\n                    '_removed': {0: 'defer', 1: 'OUT'}}\n    # Signals related to optical configuration\n    _sig_radius = Cpt(EpicsSignalRO, \":RADIUS\", auto_monitor=True)\n    _sig_z = Cpt(EpicsSignalRO, \":Z\", auto_monitor=True)\n    _sig_focus = Cpt(EpicsSignalRO, \":FOCUS\", auto_monitor=True)\n    # Default configuration attributes. Read attributes are set correctly by\n    # InOutRecordPositioner\n    _default_configuration_attrs = ['_sig_radius', '_sig_z']\n    # Signal for requested focus\n    _req_focus = Cpt(EpicsSignal, ':REQ_FOCUS')\n\n    def __init__(self, prefix, **kwargs):\n        super().__init__(prefix, **kwargs)\n\n\n    @property\n    def radius(self):\n        \"\"\"\n        Method converts the EPICS lens radius signal into a float that can be\n        used for calculations.\n\n        Returns\n        -------\n        float\n            Returns the radius of the lens\n        \"\"\"\n        return self._sig_radius.get()\n\n    @property\n    def z(self):\n        \"\"\"\n        Method converts the z position EPICS signal into a float.\n\n        Returns\n        -------\n        float\n            Returns the z position of the lens in meters along the beamline\n        \"\"\"\n        return self._sig_z.get()\n\n    @property\n    def sig_focus(self):\n        \"\"\"\n        Method converts the EPICS focal length signal of the lens into a float\n\n        Returns\n        -------\n        float\n            Returns the focal length of the lens in meters\n        \"\"\"\n        return self._sig_focus.get()\n\n    def _do_move(self, state):\n        if state.name == 'IN':\n            self._insert.put(1)\n        elif state.name == 'OUT':\n            self._remove.put(1)\n        # We shouldn't ever get to this line as most calls will have gone\n        # through check_value first. Just in case this is here to not fail\n        # silently\n        else:\n            raise ValueError(\"Invalid State {}\".format(state))\n</code></pre>"},{"location":"lens.html#tfs.lens.MFXLens.radius","title":"<code>radius</code>  <code>property</code>","text":"<p>Method converts the EPICS lens radius signal into a float that can be used for calculations.</p>"},{"location":"lens.html#tfs.lens.MFXLens.radius--returns","title":"Returns","text":"<p>float     Returns the radius of the lens</p>"},{"location":"lens.html#tfs.lens.MFXLens.sig_focus","title":"<code>sig_focus</code>  <code>property</code>","text":"<p>Method converts the EPICS focal length signal of the lens into a float</p>"},{"location":"lens.html#tfs.lens.MFXLens.sig_focus--returns","title":"Returns","text":"<p>float     Returns the focal length of the lens in meters</p>"},{"location":"lens.html#tfs.lens.MFXLens.z","title":"<code>z</code>  <code>property</code>","text":"<p>Method converts the z position EPICS signal into a float.</p>"},{"location":"lens.html#tfs.lens.MFXLens.z--returns","title":"Returns","text":"<p>float     Returns the z position of the lens in meters along the beamline</p>"},{"location":"macros.html","title":"Macros","text":""},{"location":"macros.html#mfx.macros.laser_in","title":"<code>laser_in(wait=False, timeout=10)</code>","text":"<p>Insert the Reference Laser and clear the beampath</p>"},{"location":"macros.html#mfx.macros.laser_in--parameters","title":"Parameters","text":"<p>wait: bool, optional     Wait and check that motion is properly completed</p> float, optional <p>Time to wait for motion completion if requested to do so</p>"},{"location":"macros.html#mfx.macros.laser_in--operations","title":"Operations","text":"<ul> <li>Insert the Reference Laser</li> <li>Set the Wave8 out (35 mm)</li> <li>Set the DG1 slits to 6 mm x 6 mm</li> <li>Set the DG2 upstream slits to 6 mm x 6 mm</li> <li>Set the DG2 midstream slits to 1 mm x 1 mm</li> <li>Set the DG2 downstream slits to 1 mm x 1 mm</li> </ul> Source code in <code>mfx/macros.py</code> <pre><code>def laser_in(wait=False, timeout=10):\n    \"\"\"\n    Insert the Reference Laser and clear the beampath\n\n    Parameters\n    ----------\n    wait: bool, optional\n        Wait and check that motion is properly completed\n\n    timeout: float, optional\n        Time to wait for motion completion if requested to do so\n\n    Operations\n    ----------\n    * Insert the Reference Laser\n    * Set the Wave8 out (35 mm)\n    * Set the DG1 slits to 6 mm x 6 mm\n    * Set the DG2 upstream slits to 6 mm x 6 mm\n    * Set the DG2 midstream slits to 1 mm x 1 mm\n    * Set the DG2 downstream slits to 1 mm x 1 mm\n    \"\"\"\n    # Command motion and collect status objects\n    ref = mfx_reflaser.insert(wait=False)\n    tfs = mfx_tfs.remove_all()\n    dg1_ipm=mfx_dg1_ipm.target.remove()\n    dg2_ipm=mfx_dg2_ipm.target.remove()\n    dg1 = mfx_dg1_slits.move(6., wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(6., wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(1., wait=False)\n#    dg2_ds = mfx_dg2_downstream_slits.move(1., wait=False)\n    # Combine status and wait for completion\n    if wait:\n        status_wait(ref &amp; dg1 &amp; dg2_us &amp; dg2_ms,\n                    timeout=timeout)\n</code></pre>"},{"location":"macros.html#mfx.macros.laser_out","title":"<code>laser_out(wait=False, timeout=10)</code>","text":"<p>Remove the Reference Laser and configure the beamline</p>"},{"location":"macros.html#mfx.macros.laser_out--parameters","title":"Parameters","text":"<p>wait: bool, optional     Wait and check that motion is properly completed</p> float, optional <p>Time to wait for motion completion if requested to do so</p>"},{"location":"macros.html#mfx.macros.laser_out--operations","title":"Operations","text":"<ul> <li>Remove the Reference Laser</li> <li>Set the Wave8 Target 3 In (5.5 mm)</li> <li>Set the DG1 slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 upstream slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 midstream slits to 0.7 mm x 0.7 mm</li> <li>Set the DG2 downstream slits to 0.7 mm x 0.7 mm</li> </ul> Source code in <code>mfx/macros.py</code> <pre><code>def laser_out(wait=False, timeout=10):\n    \"\"\"\n    Remove the Reference Laser and configure the beamline\n\n    Parameters\n    ----------\n    wait: bool, optional\n        Wait and check that motion is properly completed\n\n    timeout: float, optional\n        Time to wait for motion completion if requested to do so\n\n    Operations\n    ----------\n    * Remove the Reference Laser\n    * Set the Wave8 Target 3 In (5.5 mm)\n    * Set the DG1 slits to 0.7 mm x 0.7 mm\n    * Set the DG2 upstream slits to 0.7 mm x 0.7 mm\n    * Set the DG2 midstream slits to 0.7 mm x 0.7 mm\n    * Set the DG2 downstream slits to 0.7 mm x 0.7 mm\n    \"\"\"\n    # Command motion and collect status objects\n    ref = mfx_reflaser.remove(wait=False)\n# Removing dg1 wave8 movement for now, until wave8 target positions have been fixed\n#    w8 = mfx_dg1_wave8_motor.move(5.5, wait=False)\n    dg1 = mfx_dg1_slits.move(0.7, wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(0.7, wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(0.7, wait=False)\n#    dg2_ds = mfx_dg2_downstream_slits.move(0.7, wait=False)\n    # Combine status and wait for completion\n    if wait:\n        status_wait(ref &amp; w8 &amp; dg1 &amp; dg2_us &amp; dg2_ms ,\n                    timeout=timeout)\n</code></pre>"},{"location":"macros.html#mfx.macros.mfxslits","title":"<code>mfxslits(pos)</code>","text":"<p>Set all the slits to specific position</p> Source code in <code>mfx/macros.py</code> <pre><code>def mfxslits(pos):\n    \"\"\"Set all the slits to specific position\"\"\"\n    dg1 = mfx_dg1_slits.move(pos, wait=False)\n    dg2_us = mfx_dg2_upstream_slits.move(pos, wait=False)\n    dg2_ms = mfx_dg2_midstream_slits.move(pos, wait=False)\n    dg2_ds = mfx_dg2_downstream_slits.move(pos, wait=False)\n</code></pre>"},{"location":"mfxDOD_old.html","title":"mfxDOD old","text":""},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User","title":"<code>User</code>","text":"Source code in <code>dod/mfxDOD_old.py</code> <pre><code>class User:\n    from subprocess import check_output\n\n    import logging\n    import json\n    import sys\n    import time\n    import os\n\n    import numpy as np\n    import elog\n    from hutch_python.utils import safe_load\n    from ophyd import EpicsSignalRO\n    from ophyd import EpicsSignal\n    from bluesky import RunEngine\n    from bluesky.plans import scan\n    from bluesky.plans import list_scan\n    from ophyd import Component as Cpt\n    from ophyd import Device\n    from pcdsdevices.interface import BaseInterface\n    from pcdsdevices.areadetector import plugins\n    from mfx.db import daq\n    from mfx.db import camviewer\n    from mfx.db import RE\n    #from mfx.db import bec\n    #from mfx.db import mfx_ccm as ccm\n    from mfx.delay_scan import delay_scan\n    from mfx.db import mfx_lxt_fast1 as lxt_fast\n    from pcdsdevices.device_types import Newport, IMS\n    from pcdsdevices.evr import Trigger\n    from epics import caget \n\n    #from macros import *\n    import time\n\n    logger = logging.getLogger(__name__)\n\n    #from xpp.db import daq, seq, elog\n    #from ophyd.status import wait as status_wait\n    from pcdsdevices.evr import Trigger\n    #from xpp.db import cp\n    #from xpp.db import lp\n    #from xpp.db import xpp_pulsepicker as pp\n    #from xpp.db import xpp_ccm as ccm\n    #from pcdsdevices.device_types import Newport, IMS\n    # WAIT A WHILE FOR THE DAQ TO START\n    #import pcdsdaq.daq\n    #pcdsdaq.daq.BEGIN_TIMEOUT = 5\n\n\n\n    #######################\n    \"\"\"Generic User Object\"\"\"\n    with safe_load('Dummy'):\n        print('Import dummy')\n\n    def __init__(self):\n\n#        with safe_load ('VH_motors'):\n#            self.vh_y = IMS('XCS:USR:MMS:02', name='vh_y')\n#            self.vh_x = IMS('XCS:USR:MMS:03', name='vh_x')\n\n#        with safe_load('Von Hamos Beckhoff'):\n#            from pcdsdevices.epics_motor import BeckhoffAxis\n#            class VonHamos_Spec(Device):\n#                cr1_move = Cpt(BeckhoffAxis, ':01', name='cr1_move')\n#                cr2_move = Cpt(BeckhoffAxis, ':02', name='cr2_move')\n#                cr3_move = Cpt(BeckhoffAxis, ':03', name='cr3_move')\n#                cr4_move = Cpt(BeckhoffAxis, ':04', name='cr4_move')\n#                cr1_rot = Cpt(BeckhoffAxis, ':01', name='cr1_rot')\n#                cr2_rot = Cpt(BeckhoffAxis, ':02', name='cr2_rot')\n#                cr3_rot = Cpt(BeckhoffAxis, ':03', name='cr3_rot')\n#                cr4_rot = Cpt(BeckhoffAxis, ':04', name='cr4_rot')\n#            self.vhs = VonHamos_Spec('MFX:VHS:MMB', name='vhs')\n\n        with safe_load ('LED'):\n            #self.led = Trigger('XCS:R42:EVR:01:TRIG6', name='led_delay')\n            self.led = Trigger('MFX:LAS:EVR:01:TRIG3', name='led_delay')\n            #self.led = Trigger('XCS:R44:EVR:44:TRIG6', name='led_delay')\n            self.led_uS = MicroToNano()\n\n#        with safe_load('Laser Phase Motor'):\n#            from ophyd.epics_motor import EpicsMotor\n#            self.las_phase = EpicsMotor('LAS:FS4:MMS:PH', name='las_phase')\n\n    def set_current_position(self, motor, value):\n        motor.set_use_switch.put(1)\n        motor.set_use_switch.wait_for_connection()\n        motor.user_setpoint.put(value, force=True)\n        motor.user_setpoint.wait_for_connection()\n        motor.set_use_switch.put(0)\n    def led_scan(self, start, end, nsteps, duration):\n        \"\"\"\n        Function to scan led delays and dwell at each delay. Goes back to original delay after scanning.\n\n        Parameters\n        ---------\n        start : float\n            Start delay in microseconds.\n        end : float\n            End delay in microseconds.\n        nsteps : integer\n            number of steps for delay.\n        duration : float\n            Dwell time at each delay. In seconds.\n        \"\"\"\n        old_led = self.led.ns_delay.get()\n        print('Scanning LED delays...')\n        steps = np.linspace(start * 1000.0, end * 1000.0, nsteps)\n        for step in steps:\n            self.led.ns_delay.put(step)\n            time.sleep(duration)\n        self.led.ns_delay.put(old_led)\n        print('Scan complete setting delay back to old value: ' +str(old_led))\n\n    def lxt_fast_set_absolute_zero(self):\n        currentpos = lxt_fast()\n        lxt_fast1_enc = UsDigitalUsbEncoder('MFX:USDUSB4:01:CH0', name='lxt_fast_enc1', linked_axis=lxt_fast)\n        currentenc = lxt_fast_enc.get()\n        #elog.post('Set current stage position {}, encoder value {} to 0'.format(currentpos,currentenc.pos))\n        print('Set current stage position {}, encoder value {} to 0'.format(currentpos,currentenc.pos))\n        lxt_fast.set_current_position(0)\n        lxt_fast_enc.set_zero()\n        return\n\n    def takeRun(self, nEvents=None, duration=None, record=True, use_l3t=False):\n        daq.configure(events=120, record=record, use_l3t=use_l3t)\n        daq.begin(events=nEvents, duration=duration)\n        daq.wait()\n        daq.end_run()\n\n    def pvascan(self, motor, start, end, nsteps, nEvents, record=None):\n        currPos = motor.get()\n        daq.configure(nEvents, record=record, controls=[motor])\n        RE(scan([daq], motor, start, end, nsteps))\n        motor.put(currPos)\n\n    def pvdscan(self, motor, start, end, nsteps, nEvents, record=None):\n        daq.configure(nEvents, record=record, controls=[motor])\n        currPos = motor.get()\n        RE(scan([daq], motor, currPos + start, currPos + end, nsteps))\n        motor.put(currPos)\n\n    #def ascan(self, motor, start, end, nsteps, nEvents, record=True, use_l3t=False):\n    #    self.cleanup_RE()\n    #    currPos = motor.wm()\n    #    daq.configure(nEvents, record=record, controls=[motor], use_l3t=use_l3t)\n    #    try:\n    #        RE(scan([daq], motor, start, end, nsteps))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n    #    motor.mv(currPos)\n\n    def listscan(self, motor, posList, nEvents, record=True, use_l3t=False):\n        self.cleanup_RE()\n        currPos = motor.wm()\n        daq.configure(nEvents, record=record, controls=[motor], use_l3t=use_l3t)\n        try:\n            RE(list_scan([daq], motor, posList))\n        except Exception:\n            logger.debug('RE Exit', exc_info=True)\n        finally:\n            self.cleanup_RE()\n        motor.mv(currPos)\n\n    #def dscan(self, motor, start, end, nsteps, nEvents, record=True, use_l3t=False):\n    #    self.cleanup_RE()\n    #    daq.configure(nEvents, record=record, controls=[motor], use_l3t=use_l3t)\n    #    currPos = motor.wm()\n    #    try:\n    #        RE(scan([daq], motor, currPos+start, currPos+end, nsteps))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n    #    motor.mv(currPos)\n\n    #def a2scan(self, m1, a1, b1, m2, a2, b2, nsteps, nEvents, record=True, use_l3t=False):\n    #    self.cleanup_RE()\n    #    daq.configure(nEvents, record=record, controls=[m1, m2], use_l3t=use_l3t)\n    #    try:\n    #        RE(scan([daq], m1, a1, b1, m2, a2, b2, nsteps))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n\n    #def a3scan(self, m1, a1, b1, m2, a2, b2, m3, a3, b3, nsteps, nEvents, record=True):\n    #    self.cleanup_RE()\n    #    daq.configure(nEvents, record=record, controls=[m1, m2, m3])\n    #    try:\n    #        RE(scan([daq], m1, a1, b1, m2, a2, b2, m3, a3, b3, nsteps))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n\n    #def delay_scan(self, start, end, sweep_time, record=True, use_l3t=False,\n    #               duration=None):\n    #    \"\"\"Delay scan with the daq.\"\"\"\n    #    self.cleanup_RE()\n    #    bec.disable_plots()\n    #    controls = [lxt_fast]\n    #    try:\n    #        RE(delay_scan(daq, lxt_fast, [start, end], sweep_time,\n    #                      duration=duration, record=record, use_l3t=use_l3t,\n    #                      controls=controls))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n    #        bec.enable_plots()\n\n    #def empty_delay_scan(self, start, end, sweep_time, record=True,\n    #                     use_l3t=False, duration=None):\n    #    \"\"\"Delay scan without the daq.\"\"\"\n    #    self.cleanup_RE()\n    #    #daq.configure(events=None, duration=None, record=record,\n    #    #              use_l3t=use_l3t, controls=[lxt_fast])\n    #    try:\n    #        RE(delay_scan(None, lxt_fast, [start, end], sweep_time,\n    #                      duration=duration))\n    #    except Exception:\n    #        logger.debug('RE Exit', exc_info=True)\n    #    finally:\n    #        self.cleanup_RE()\n\n    def cleanup_RE(self):\n        if not RE.state.is_idle:\n            print('Cleaning up RunEngine')\n            print('Stopping previous run')\n            try:\n                RE.stop()\n            except Exception:\n                pass\n\n    def scanExamples(self):\n        print(\"\"\"\n        Absolute Scan\n          re.daq_ascan([], sim.fast_motor1, -1, 1, 21, events = 10, record = False)\n\n        Absolute 2D Scan\n          re.daq_a2scan([], sim.fast_motor1, -1, 1 , sim.fast_motor2, -1, 1, nsteps = 5, events = 10, record = False)\n\n        Absolute 3D Scan\n          re.daq_a3scan([], sim.fast_motor1, -1, 1 , sim.fast_motor2, -1, 1, sim.fast_motor3, -1, 1, nsteps = 5, events = 10, record = False)\n\n        Delta Scan\n          re.daq_dscan([], sim.fast_motor1, -1, 1, 21, events = 10, record = False)\n\n        Delay Scan\n          re.daq_delay_scan([], lxt_fast, [-1e-12, 1e-12], sweep_time = 5,  duration = 20, record = False)\n\n        Empty Delay Scan (no Daq)\n          re.delay_scan([], lxt_fast, [-1e-12,1e-12], sweep_time = 5,  duration = 20)\n        \"\"\")\n\n\n    ##########################\n    # CCM Scanning Functions #\n    ##########################\n    def perform_run(self, events, record=True, comment='', post=True,\n                    **kwargs):\n        \"\"\"\n        Perform a single run of the experiment\n\n        Parameters\n        ----------\n        events: int\n            Number of events to include in run\n\n        record: bool, optional\n            Whether to record the run\n\n        comment : str, optional\n            Comment for ELog\n\n        post: bool, optional\n            Whether to post to the experimental ELog or not. Will not post if\n            not recording\n\n        Note\n        ----\n        \"\"\"\n\n        comment = comment or ''\n        # Start recording\n        logger.info(\"Starting DAQ run, -&gt; record=%s\", record)\n        daq.begin(events=events, record=record)\n        time.sleep(1)\n        # Post to ELog if desired\n        runnum = daq._control.runnumber()\n        info = [runnum, comment, events, self._delaystr]\n        post_msg = post_template.format(*info)\n        print(post_msg)\n        if post and record:\n            elog(msg=post_msg, run=runnum)\n\n        # Wait for the DAQ to finish\n        logger.info(\"Waiting or DAQ to complete %s events ...\", events)\n        daq.wait()\n        logger.info(\"Run complete!\")\n        daq.end_run()\n        time.sleep(0.5)\n        return\n\n\n\n    def dummy_daq_test(self, events=360, sleep=3, record=False):\n        daq.connect()\n        while 1:\n            daq.begin(events=events, record=record)\n            daq.wait()\n            daq.end_run()\n            time.sleep(sleep)\n            print(time.ctime(time.time()))\n        return\n\n    post_template = \"\"\"\\\n    Run Number: {} {}\n\n    Acquiring {} events\n\n    {}\n    \"\"\"\n\n\n    post_template_escan = \"\"\"\\\n    Run Number: {} {}\n\n    {}\n    Minimum photon_energy -&gt; {}\n    Maximum photon_energy -&gt; {}\n    \"\"\"\n</code></pre>"},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User.led_scan","title":"<code>led_scan(start, end, nsteps, duration)</code>","text":"<p>Function to scan led delays and dwell at each delay. Goes back to original delay after scanning.</p>"},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User.led_scan--parameters","title":"Parameters","text":"<p>start : float     Start delay in microseconds. end : float     End delay in microseconds. nsteps : integer     number of steps for delay. duration : float     Dwell time at each delay. In seconds.</p> Source code in <code>dod/mfxDOD_old.py</code> <pre><code>def led_scan(self, start, end, nsteps, duration):\n    \"\"\"\n    Function to scan led delays and dwell at each delay. Goes back to original delay after scanning.\n\n    Parameters\n    ---------\n    start : float\n        Start delay in microseconds.\n    end : float\n        End delay in microseconds.\n    nsteps : integer\n        number of steps for delay.\n    duration : float\n        Dwell time at each delay. In seconds.\n    \"\"\"\n    old_led = self.led.ns_delay.get()\n    print('Scanning LED delays...')\n    steps = np.linspace(start * 1000.0, end * 1000.0, nsteps)\n    for step in steps:\n        self.led.ns_delay.put(step)\n        time.sleep(duration)\n    self.led.ns_delay.put(old_led)\n    print('Scan complete setting delay back to old value: ' +str(old_led))\n</code></pre>"},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User.perform_run","title":"<code>perform_run(events, record=True, comment='', post=True, **kwargs)</code>","text":"<p>Perform a single run of the experiment</p>"},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User.perform_run--parameters","title":"Parameters","text":"<p>events: int     Number of events to include in run</p> bool, optional <p>Whether to record the run</p> str, optional <p>Comment for ELog</p> bool, optional <p>Whether to post to the experimental ELog or not. Will not post if not recording</p>"},{"location":"mfxDOD_old.html#dod.mfxDOD_old.User.perform_run--note","title":"Note","text":"Source code in <code>dod/mfxDOD_old.py</code> <pre><code>def perform_run(self, events, record=True, comment='', post=True,\n                **kwargs):\n    \"\"\"\n    Perform a single run of the experiment\n\n    Parameters\n    ----------\n    events: int\n        Number of events to include in run\n\n    record: bool, optional\n        Whether to record the run\n\n    comment : str, optional\n        Comment for ELog\n\n    post: bool, optional\n        Whether to post to the experimental ELog or not. Will not post if\n        not recording\n\n    Note\n    ----\n    \"\"\"\n\n    comment = comment or ''\n    # Start recording\n    logger.info(\"Starting DAQ run, -&gt; record=%s\", record)\n    daq.begin(events=events, record=record)\n    time.sleep(1)\n    # Post to ELog if desired\n    runnum = daq._control.runnumber()\n    info = [runnum, comment, events, self._delaystr]\n    post_msg = post_template.format(*info)\n    print(post_msg)\n    if post and record:\n        elog(msg=post_msg, run=runnum)\n\n    # Wait for the DAQ to finish\n    logger.info(\"Waiting or DAQ to complete %s events ...\", events)\n    daq.wait()\n    logger.info(\"Run complete!\")\n    daq.end_run()\n    time.sleep(0.5)\n    return\n</code></pre>"},{"location":"mfx_dod_old.html","title":"Mfx dod old","text":""},{"location":"mfx_dod_old.html#dod.mfx_dod_old.led_scan","title":"<code>led_scan(start, end, nsteps, duration)</code>","text":"<p>Function to scan led delays and dwell at each delay. Goes back to original delay after scanning.</p>"},{"location":"mfx_dod_old.html#dod.mfx_dod_old.led_scan--parameters","title":"Parameters","text":"<p>start : float     Start delay in microseconds. end : float     End delay in microseconds. nsteps : integer     number of steps for delay. duration : float     Dwell time at each delay. In seconds.</p> Source code in <code>dod/mfx_dod_old.py</code> <pre><code>def led_scan(start, end, nsteps, duration):\n    \"\"\"\n    Function to scan led delays and dwell at each delay. Goes back to original delay after scanning.\n\n    Parameters\n    ---------\n    start : float\n        Start delay in microseconds.\n    end : float\n        End delay in microseconds.\n    nsteps : integer\n        number of steps for delay.\n    duration : float\n        Dwell time at each delay. In seconds.\n    \"\"\"\n\n    from hutch_python.utils import safe_load\n    import time\n    import numpy as np\n    from pcdsdevices.evr import Trigger\n\n    with safe_load ('LED'):\n        #self.led = Trigger('XCS:R42:EVR:01:TRIG6', name='led_delay')\n        led = Trigger('MFX:LAS:EVR:01:TRIG3', name='led_delay')\n        #self.led = Trigger('XCS:R44:EVR:44:TRIG6', name='led_delay')\n        led_uS = MicroToNano()\n\n    old_led = led.ns_delay.get()\n    print('Scanning LED delays...')\n    steps = np.linspace(start * 1000.0, end * 1000.0, nsteps)\n    for step in steps:\n        led.ns_delay.put(step)\n        time.sleep(duration)\n    led.ns_delay.put(old_led)\n    print('Scan complete setting delay back to old value: ' +str(old_led))\n</code></pre>"},{"location":"mfx_dod_old.html#dod.mfx_dod_old.perform_run","title":"<code>perform_run(events, record=True, comment='', post=True, **kwargs)</code>","text":"<p>Perform a single run of the experiment</p>"},{"location":"mfx_dod_old.html#dod.mfx_dod_old.perform_run--parameters","title":"Parameters","text":"<p>events: int     Number of events to include in run</p> bool, optional <p>Whether to record the run</p> str, optional <p>Comment for ELog</p> bool, optional <p>Whether to post to the experimental ELog or not. Will not post if not recording</p>"},{"location":"mfx_dod_old.html#dod.mfx_dod_old.perform_run--note","title":"Note","text":"Source code in <code>dod/mfx_dod_old.py</code> <pre><code>def perform_run(events, record=True, comment='', post=True,\n                **kwargs):\n    \"\"\"\n    Perform a single run of the experiment\n\n    Parameters\n    ----------\n    events: int\n        Number of events to include in run\n\n    record: bool, optional\n        Whether to record the run\n\n    comment : str, optional\n        Comment for ELog\n\n    post: bool, optional\n        Whether to post to the experimental ELog or not. Will not post if\n        not recording\n\n    Note\n    ----\n    \"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    import time\n    import elog\n    from mfx.db import daq\n\n    comment = comment or ''\n    # Start recording\n    logger.info(\"Starting DAQ run, -&gt; record=%s\", record)\n    daq.begin(events=events, record=record)\n    time.sleep(1)\n    # Post to ELog if desired\n    runnum = daq._control.runnumber()\n    info = [runnum, comment, events, self._delaystr]\n    post_msg = post_template.format(*info)\n    print(post_msg)\n    if post and record:\n        elog(msg=post_msg, run=runnum)\n\n    # Wait for the DAQ to finish\n    logger.info(\"Waiting or DAQ to complete %s events ...\", events)\n    daq.wait()\n    logger.info(\"Run complete!\")\n    daq.end_run()\n    time.sleep(0.5)\n    return\n</code></pre>"},{"location":"mfx_timing.html","title":"Mfx timing","text":""},{"location":"mfx_timing.html#mfx.mfx_timing.MFX_Timing","title":"<code>MFX_Timing</code>","text":"Source code in <code>mfx/mfx_timing.py</code> <pre><code>class MFX_Timing:\n    def __init__(self,sequencer=None):\n        from pcdsdevices.sequencer import EventSequencer\n        self.seq1 = EventSequencer('ECS:SYS0:7', name='mfx_sequencer')\n        self.seq2 = EventSequencer('ECS:SYS0:12', name='mfx_sequencer_spare')\n\n        self.evt_code = {\n            'wait':0,\n            'pp_trig':197,\n            'daq_readout':198,\n            'laser_on':203,\n            'laser_off':204,\n            'ray_readout':210,\n            'ray1':211,\n            'ray2':212,\n            'ray3':213,\n        }\n        self.sync_markers = {0.5:0, 1:1, 5:2, 10:3, 30:4, 60:5, 120:6, 360:7}\n        self.sequence = []\n\n\n    def _seq_step(self, evt_code_name=None, delta_beam=0):\n        try:\n            return [self.evt_code[evt_code_name], delta_beam, 0, 0]\n        except:\n            print('Error: event sequencer step not recognized.')\n\n\n    def _seq_init(self, sync_mark=30):\n        from time import sleep\n        self.seq.sync_marker.put(self.sync_markers[sync_mark])\n        self.sequence = []\n        sequence = []\n        for ii in range(15):\n            sequence.append(self._seq_step('wait', 0))\n        self.seq.sequence.put_seq(sequence)\n        sleep(1)\n\n\n    def _seq_put(self, steps):\n        for step in steps:\n            self.sequence.append(self._seq_step(step[0], step[1]))\n        self.seq.sequence.put_seq(self.sequence)\n\n\n    def _seq_120hz(self):\n        steps = [['ray_readout', 1],\n                 ['daq_readout',0],\n                 ['ray1',1],\n                 ['daq_readout',0],\n                 ['ray2',1],\n                 ['daq_readout',0],\n                 ['ray3',1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_120hz_trucated(self):\n        steps = [['ray_readout', 1],\n                 ['daq_readout',0]]\n        return steps\n\n\n    def _seq_60hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['daq_readout', 0],\n                 ['ray2', 1],\n                 ['pp_trig', 0],\n                 ['ray3', 1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_60hz_trucated(self):\n        steps = [['ray_readout', 1],\n                 ['ray1', 0],\n                 ['ray2', 1],\n                 ['daq_readout', 0]]\n        return steps\n\n\n    def _seq_30hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['ray2', 1],\n                 ['daq_readout', 0],\n                 ['ray3', 1]]\n        return steps\n\n\n    def _seq_20hz(self):\n        steps = [['ray_readout', 1],\n                 ['pp_trig', 0],\n                 ['ray1', 1],\n                 ['ray2', 1],\n                 ['daq_readout', 0],\n                 ['ray3', 1],\n                 ['ray3', 1],\n                 ['ray3', 1]]\n        return steps\n\n\n    def set_seq(self, rep=None, sequencer=None, laser=None):\n        \"\"\"\n    Set your event sequencer\n\n    Parameters\n    ----------\n    rep: int, optional\n        Set repitition rate only 120, 60, 30, and 20 Hz are currently available\n\n    sequencer: str, optional\n        default is event sequencer 7 and use 'spare' to run sequencer 12\n\n    laser: list, optional\n        sets laser sequence list in format [['laser_on',0],['laser_off',0],...]\n\n    Operations\n    ----------\n\n        \"\"\"\n        self.seq1.stop()\n        self.seq2.stop()\n        if str(sequencer).lower() == 'spare':\n            self.seq = self.seq2\n        else:\n            self.seq = self.seq1\n        if laser:\n            if rep is None or rep == 120:\n                self._seq_init(sync_mark=120)\n                for laser_evt in laser:\n                    sequence = self._seq_120hz_trucated()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 60:\n                self._seq_init(sync_mark=120)\n                for laser_evt in laser:\n                    sequence = self._seq_60hz_trucated()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 30:\n                self._seq_init(sync_mark=30)\n                for laser_evt in laser:\n                    sequence = self._seq_30hz()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n            elif rep == 20:\n                self._seq_init(sync_mark=60)\n                for laser_evt in laser:\n                    sequence = self._seq_20hz()\n                    block = sequence[:-1]\n                    block.append(laser_evt)\n                    block.append(sequence[-1])\n                    self._seq_put(block)\n        else:\n            if rep is None or rep == 120:\n                self._seq_init(sync_mark=120)\n                self._seq_put(self._seq_120hz())\n            elif rep == 60:\n                self._seq_init(sync_mark=60)\n                self._seq_put(self._seq_60hz())\n            elif rep == 30:\n                self._seq_init(sync_mark=30)\n                self._seq_put(self._seq_30hz())\n            elif rep == 20:\n                self._seq_init(sync_mark=20)\n                self._seq_put(self._seq_20hz())\n\n        self.seq.start()\n        return self.sequence\n\n    def check_seq(self):\n        for line in self.sequence:\n            print(line)\n</code></pre>"},{"location":"mfx_timing.html#mfx.mfx_timing.MFX_Timing.set_seq","title":"<code>set_seq(rep=None, sequencer=None, laser=None)</code>","text":"<p>Set your event sequencer</p>"},{"location":"mfx_timing.html#mfx.mfx_timing.MFX_Timing.set_seq--parameters","title":"Parameters","text":"<p>rep: int, optional     Set repitition rate only 120, 60, 30, and 20 Hz are currently available</p> str, optional <p>default is event sequencer 7 and use 'spare' to run sequencer 12</p> list, optional <p>sets laser sequence list in format [['laser_on',0],['laser_off',0],...]</p>"},{"location":"mfx_timing.html#mfx.mfx_timing.MFX_Timing.set_seq--operations","title":"Operations","text":"Source code in <code>mfx/mfx_timing.py</code> <pre><code>def set_seq(self, rep=None, sequencer=None, laser=None):\n    \"\"\"\nSet your event sequencer\n\nParameters\n----------\nrep: int, optional\n    Set repitition rate only 120, 60, 30, and 20 Hz are currently available\n\nsequencer: str, optional\n    default is event sequencer 7 and use 'spare' to run sequencer 12\n\nlaser: list, optional\n    sets laser sequence list in format [['laser_on',0],['laser_off',0],...]\n\nOperations\n----------\n\n    \"\"\"\n    self.seq1.stop()\n    self.seq2.stop()\n    if str(sequencer).lower() == 'spare':\n        self.seq = self.seq2\n    else:\n        self.seq = self.seq1\n    if laser:\n        if rep is None or rep == 120:\n            self._seq_init(sync_mark=120)\n            for laser_evt in laser:\n                sequence = self._seq_120hz_trucated()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 60:\n            self._seq_init(sync_mark=120)\n            for laser_evt in laser:\n                sequence = self._seq_60hz_trucated()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 30:\n            self._seq_init(sync_mark=30)\n            for laser_evt in laser:\n                sequence = self._seq_30hz()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n        elif rep == 20:\n            self._seq_init(sync_mark=60)\n            for laser_evt in laser:\n                sequence = self._seq_20hz()\n                block = sequence[:-1]\n                block.append(laser_evt)\n                block.append(sequence[-1])\n                self._seq_put(block)\n    else:\n        if rep is None or rep == 120:\n            self._seq_init(sync_mark=120)\n            self._seq_put(self._seq_120hz())\n        elif rep == 60:\n            self._seq_init(sync_mark=60)\n            self._seq_put(self._seq_60hz())\n        elif rep == 30:\n            self._seq_init(sync_mark=30)\n            self._seq_put(self._seq_30hz())\n        elif rep == 20:\n            self._seq_init(sync_mark=20)\n            self._seq_put(self._seq_20hz())\n\n    self.seq.start()\n    return self.sequence\n</code></pre>"},{"location":"offline_calculator.html","title":"Offline calculator","text":""},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator","title":"<code>TFS_Calculator</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>tfs/offline_calculator.py</code> <pre><code>class TFS_Calculator(object):\n    def __init__(self, tfs_lenses, prefocus_lenses=None):\n        self.tfs_lenses = tfs_lenses\n        self.prefocus_lenses = prefocus_lenses\n        self.combos = self.combinations()\n        return\n\n    def combinations(self):\n        \"\"\"\n        All possible combinations of the given lenses\n\n        Parameters\n        ----------\n\n        Returns\n        -------\n        combos: list\n            List of LensConnect objects\n        \"\"\"\n\n        tfs_combos = list()\n        for i in range(1, len(self.tfs_lenses)+1):\n            list_combos = list(itertools.combinations(self.tfs_lenses, i))\n            # Create LensConnect objects from all of our possible combinations\n            tfs_combos.extend([LensConnect(*combo) for combo in list_combos])\n        logger.debug(\"Found %s combinations of Transfocator lenses\",\n                     len(tfs_combos))\n        return tfs_combos\n\n    def _update_combos(self):\n        self.combos = self.combinations()\n\n    def get_pre_focus_lens(self, energy):\n        for e_range, lens in MFX_prefocus_energy_range.items():\n            if energy &gt;= e_range[0] and energy &lt; e_range[1]:\n                pre_focus_lens_idx = lens[0]\n                break\n        if pre_focus_lens_idx is None:\n            pre_focus_lens = None\n            print(f\"No pre-focussing lens at {energy} eV\")\n        else:\n            pre_focus_lens = self.prefocus_lenses[pre_focus_lens_idx]\n            print(f\"Pre-focussing lens for {energy} eV:\\n{pre_focus_lens}\")\n            print(f'Radius: {pre_focus_lens.radius} um\\n')\n        return pre_focus_lens\n\n    @staticmethod\n    def get_combo_image(combo, z_obj=0.0):\n        return combo.image(z_obj)\n\n    def find_solution(self, target, energy, n=4, z_obj=0.0):\n        \"\"\"\n        Find a combination to reach a specific focus\n\n        Parameters\n        ----------\n        target: float\n            The desired position of the focal plane in accelerator coordinates\n\n        n : int, optional\n            The maximum number of lenses in a valid combination. This saves\n            time by avoiding calculating the focal plane of combinations with a\n            large number of lenses\n\n        z_obj : float, optional\n            The source point of the beam\n\n        Returns\n        -------\n        array: LensConnect\n            An array of lens combinations with the closest possible image to\n            the target_image\n\n        Steps:\n        1) find the right pre-focussing lens. These are pre-defined based on\n        the photon energy (see prefocus_energy_range) and add it to the combos.\n        2) Calculate the focus and the difference to the target for each TFS\n        lens combination.\n        3) Pick the combo with the smallest difference\n        \"\"\"\n\n        # Step 1\n        pre_focus_lens = self.get_pre_focus_lens(energy)\n        if pre_focus_lens is None:\n            combos = self.combos\n        else:\n            pre_focus_lens = self.get_pre_focus_lens(energy)\n            combos = []\n            for combo in self.combos:\n                c = LensConnect(pre_focus_lens)\n                lens_combo = LensConnect.connect(c, combo)\n                combos.append(lens_combo)\n\n        # Step 2\n        diff = []\n        for ii, combo in enumerate(self.combos):\n            if combo.nlens &gt; n:\n                continue\n            image = combo.image(z_obj, energy)\n            diff.append(np.abs(image - target))\n\n        # Step 3\n        solution = combos[np.argmin(diff)]\n        return solution, np.min(diff)\n</code></pre>"},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.combinations","title":"<code>combinations()</code>","text":"<p>All possible combinations of the given lenses</p>"},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.combinations--parameters","title":"Parameters","text":""},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.combinations--returns","title":"Returns","text":"<p>combos: list     List of LensConnect objects</p> Source code in <code>tfs/offline_calculator.py</code> <pre><code>def combinations(self):\n    \"\"\"\n    All possible combinations of the given lenses\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n    combos: list\n        List of LensConnect objects\n    \"\"\"\n\n    tfs_combos = list()\n    for i in range(1, len(self.tfs_lenses)+1):\n        list_combos = list(itertools.combinations(self.tfs_lenses, i))\n        # Create LensConnect objects from all of our possible combinations\n        tfs_combos.extend([LensConnect(*combo) for combo in list_combos])\n    logger.debug(\"Found %s combinations of Transfocator lenses\",\n                 len(tfs_combos))\n    return tfs_combos\n</code></pre>"},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.find_solution","title":"<code>find_solution(target, energy, n=4, z_obj=0.0)</code>","text":"<p>Find a combination to reach a specific focus</p>"},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.find_solution--parameters","title":"Parameters","text":"<p>target: float     The desired position of the focal plane in accelerator coordinates</p> int, optional <p>The maximum number of lenses in a valid combination. This saves time by avoiding calculating the focal plane of combinations with a large number of lenses</p> float, optional <p>The source point of the beam</p>"},{"location":"offline_calculator.html#tfs.offline_calculator.TFS_Calculator.find_solution--returns","title":"Returns","text":"<p>array: LensConnect     An array of lens combinations with the closest possible image to     the target_image</p> <p>Steps: 1) find the right pre-focussing lens. These are pre-defined based on the photon energy (see prefocus_energy_range) and add it to the combos. 2) Calculate the focus and the difference to the target for each TFS lens combination. 3) Pick the combo with the smallest difference</p> Source code in <code>tfs/offline_calculator.py</code> <pre><code>def find_solution(self, target, energy, n=4, z_obj=0.0):\n    \"\"\"\n    Find a combination to reach a specific focus\n\n    Parameters\n    ----------\n    target: float\n        The desired position of the focal plane in accelerator coordinates\n\n    n : int, optional\n        The maximum number of lenses in a valid combination. This saves\n        time by avoiding calculating the focal plane of combinations with a\n        large number of lenses\n\n    z_obj : float, optional\n        The source point of the beam\n\n    Returns\n    -------\n    array: LensConnect\n        An array of lens combinations with the closest possible image to\n        the target_image\n\n    Steps:\n    1) find the right pre-focussing lens. These are pre-defined based on\n    the photon energy (see prefocus_energy_range) and add it to the combos.\n    2) Calculate the focus and the difference to the target for each TFS\n    lens combination.\n    3) Pick the combo with the smallest difference\n    \"\"\"\n\n    # Step 1\n    pre_focus_lens = self.get_pre_focus_lens(energy)\n    if pre_focus_lens is None:\n        combos = self.combos\n    else:\n        pre_focus_lens = self.get_pre_focus_lens(energy)\n        combos = []\n        for combo in self.combos:\n            c = LensConnect(pre_focus_lens)\n            lens_combo = LensConnect.connect(c, combo)\n            combos.append(lens_combo)\n\n    # Step 2\n    diff = []\n    for ii, combo in enumerate(self.combos):\n        if combo.nlens &gt; n:\n            continue\n        image = combo.image(z_obj, energy)\n        diff.append(np.abs(image - target))\n\n    # Step 3\n    solution = combos[np.argmin(diff)]\n    return solution, np.min(diff)\n</code></pre>"},{"location":"rayonix.html","title":"Rayonix","text":""},{"location":"rayonix.html#mfx.rayonix.Rayonix","title":"<code>Rayonix</code>","text":"Source code in <code>mfx/rayonix.py</code> <pre><code>class Rayonix:\n    def __init__(self, sequencer):\n        self.sequencer = sequencer\n\n    @property\n    def current_rate(self):\n        \"\"\"Current configured EventSequencer rate\"\"\"\n        delta = self.sequencer.sequence.get_seq()[0][1]\n        rate = 120 // (delta + 3)\n        return int(rate)\n\n    def configure_sequencer(self, rate=30, show_seq=True):\n        \"\"\"\n        Setup laser triggers and EventSequencer\n\n        Parameters\n        ----------\n        rate : int or str, optional\n            Any of the following rates\n            30Hz, 24Hz, 20Hz, 15Hz, 12Hz, 10Hz,\n            8Hz, 6Hz, 5Hz, 4Hz, 3Hz, 2Hz, 1Hz\n        \"\"\"\n        logger.info(\"Configure EventSequencer ...\")\n        valid_rates = (30, 24, 20, 15, 12, 10, 8, 6, 5, 4, 3, 2, 1)\n\n        if isinstance(rate, str):\n            rate = int(rate[:-2])\n        elif isinstance(rate, float):\n            if rate.is_integer():\n                rate = int(rate)\n\n        if rate not in valid_rates:\n            raise RuntimeError('Invalid rate, recieved {} but must be one of '\n                               '{}'.format(rate, valid_rates))\n\n        # Use sequence to regulate rate, not sync marker\n        self.sequencer.sync_marker.put('120Hz')\n\n        # Construct the sequence and submit\n        delta = 120 // rate - 3\n        sequence = [[213, delta, 0, 0],\n                    [197, 1, 0, 0],\n                    [212, 0, 0, 0],\n                    [211, 1, 0, 0],\n                    [210, 1, 0, 0],\n                    [198, 0, 0, 0]]\n\n        # sequence = [[213, 197, 212, 211, 210, 198],\n        #             [delta, 1, 0, 1, 1, 0],\n        #             [0, 0, 0, 0, 0, 0],\n        #             [0, 0, 0, 0, 0, 0]]\n        retries = 5\n        success = False\n        for i in range(retries):\n            self.sequencer.sequence.put_seq(sequence)\n            read_seq = [list(s) for s in self.sequencer.sequence.get_seq()]\n            if read_seq == sequence:\n                success = True\n                break\n\n        if success:\n            logger.info('Successfully configured sequencer')\n        else:\n            logger.error('Putting to sequencer failed!')\n\n        if show_seq:\n            self.sequencer.sequence.show()\n</code></pre>"},{"location":"rayonix.html#mfx.rayonix.Rayonix.current_rate","title":"<code>current_rate</code>  <code>property</code>","text":"<p>Current configured EventSequencer rate</p>"},{"location":"rayonix.html#mfx.rayonix.Rayonix.configure_sequencer","title":"<code>configure_sequencer(rate=30, show_seq=True)</code>","text":"<p>Setup laser triggers and EventSequencer</p>"},{"location":"rayonix.html#mfx.rayonix.Rayonix.configure_sequencer--parameters","title":"Parameters","text":"<p>rate : int or str, optional     Any of the following rates     30Hz, 24Hz, 20Hz, 15Hz, 12Hz, 10Hz,     8Hz, 6Hz, 5Hz, 4Hz, 3Hz, 2Hz, 1Hz</p> Source code in <code>mfx/rayonix.py</code> <pre><code>def configure_sequencer(self, rate=30, show_seq=True):\n    \"\"\"\n    Setup laser triggers and EventSequencer\n\n    Parameters\n    ----------\n    rate : int or str, optional\n        Any of the following rates\n        30Hz, 24Hz, 20Hz, 15Hz, 12Hz, 10Hz,\n        8Hz, 6Hz, 5Hz, 4Hz, 3Hz, 2Hz, 1Hz\n    \"\"\"\n    logger.info(\"Configure EventSequencer ...\")\n    valid_rates = (30, 24, 20, 15, 12, 10, 8, 6, 5, 4, 3, 2, 1)\n\n    if isinstance(rate, str):\n        rate = int(rate[:-2])\n    elif isinstance(rate, float):\n        if rate.is_integer():\n            rate = int(rate)\n\n    if rate not in valid_rates:\n        raise RuntimeError('Invalid rate, recieved {} but must be one of '\n                           '{}'.format(rate, valid_rates))\n\n    # Use sequence to regulate rate, not sync marker\n    self.sequencer.sync_marker.put('120Hz')\n\n    # Construct the sequence and submit\n    delta = 120 // rate - 3\n    sequence = [[213, delta, 0, 0],\n                [197, 1, 0, 0],\n                [212, 0, 0, 0],\n                [211, 1, 0, 0],\n                [210, 1, 0, 0],\n                [198, 0, 0, 0]]\n\n    # sequence = [[213, 197, 212, 211, 210, 198],\n    #             [delta, 1, 0, 1, 1, 0],\n    #             [0, 0, 0, 0, 0, 0],\n    #             [0, 0, 0, 0, 0, 0]]\n    retries = 5\n    success = False\n    for i in range(retries):\n        self.sequencer.sequence.put_seq(sequence)\n        read_seq = [list(s) for s in self.sequencer.sequence.get_seq()]\n        if read_seq == sequence:\n            success = True\n            break\n\n    if success:\n        logger.info('Successfully configured sequencer')\n    else:\n        logger.error('Putting to sequencer failed!')\n\n    if show_seq:\n        self.sequencer.sequence.show()\n</code></pre>"},{"location":"suspenders.html","title":"Suspenders","text":""},{"location":"suspenders.html#mfx.suspenders.AvgSignal","title":"<code>AvgSignal</code>","text":"<p>               Bases: <code>Signal</code></p> <p>Signal that acts as a rolling average of another signal</p> Source code in <code>mfx/suspenders.py</code> <pre><code>class AvgSignal(Signal):\n    \"\"\"\n    Signal that acts as a rolling average of another signal\n    \"\"\"\n    def __init__(self, signal, averages, name=None, parent=None, **kwargs):\n        super().__init__(name=name, parent=parent, **kwargs)\n        self.sig = signal\n        self.lock = threading.RLock()\n        self.index = 0\n        self.values = np.ones(averages) * self.sig.get()\n        self.sig.subscribe(self._update_avg)\n\n    def _update_avg(self, *args, value, **kwargs):\n        with self.lock:\n            self.values[self.index] = value\n            self.index += 1\n            if self.index == len(self.values):\n                self.index = 0\n            self.put(np.mean(self.values))\n</code></pre>"},{"location":"suspenders.html#mfx.suspenders.BeamEnergySuspendFloor","title":"<code>BeamEnergySuspendFloor</code>","text":"<p>               Bases: <code>SuspendFloor</code></p> <p>Suspend the run if the beam energy falls below a set value.</p> Source code in <code>mfx/suspenders.py</code> <pre><code>class BeamEnergySuspendFloor(SuspendFloor):\n    \"\"\"\n    Suspend the run if the beam energy falls below a set value.\n    \"\"\"\n    def __init__(self, suspend_thresh, resume_thresh=None, sleep=5.0,\n                 averages=120, **kwargs):\n\n        sig = EpicsSignalRO('GDET:FEE1:241:ENRC')\n        if averages &gt; 1:\n            sig = AvgSignal(sig, averages, name=sig.name + \"_avg\")\n\n        super().__init__(sig, suspend_thresh, resume_thresh=resume_thresh,\n                         sleep=sleep, **kwargs)\n</code></pre>"},{"location":"testServer.html","title":"testServer","text":""},{"location":"testServerSpawner.html","title":"testServerSpawner","text":""},{"location":"testServerSpawner.html#dod.testServerSpawner.ServerSpawner","title":"<code>ServerSpawner</code>","text":"<p>Class To start and kill local web server</p> Source code in <code>dod/testServerSpawner.py</code> <pre><code>class ServerSpawner():\n    \"\"\"\n    Class To start and kill local web server\n    \"\"\"\n    def __init__(self, hostName : str, serverPort : int, supportedJson : str):\n      self.hostName = hostName\n      self.serverPort = serverPort\n      self.supportedJson = supportedJson\n      self.event = Event()\n\n    def launch_web_server(self):\n        def server_launch():\n            \"\"\"\n            Function for server starting server process\n            \"\"\"\n            print(\"Server started http://%s:%s\" % (self.hostName, self.serverPort))\n            webServer = HTTPServer((self.hostName, self.serverPort), MyServer)\n\n            while not self.event.is_set():\n                webServer.handle_request()\n                # Time needed for one request to be recived and event flag to be set\n                time.sleep(0.1)\n\n            print(\"Server stopped.\")\n            webServer.server_close()\n\n        self.proc = Process(target=server_launch)\n        self.proc.start()\n        time.sleep(0.1)\n\n    def kill_web_server(self):\n        # send kill signal to test server\n        self.event.set()\n        self.proc.join()\n</code></pre>"},{"location":"timetool.html","title":"Timetool","text":"<p>Contains function definitions for managing the timetool and ultrafast timing during experiments.</p>"},{"location":"timetool.html#mfx.timetool--functions","title":"Functions","text":"<p>correct_timing_drift(amplitude_thresh: float, ipm_thresh: float,                      drift_adjustment_thresh: float, fwhm_threshs: Tuple,                      num_events: int, will_log: bool)     Automate the correction of long-term drift in timing by monitoring the mean     edge position on the timetool camera.</p>"},{"location":"timetool.html#mfx.timetool.correct_timing_drift","title":"<code>correct_timing_drift(amplitude_thresh=0.02, ipm_thresh=500.0, drift_adjustment_thresh=0.05, fwhm_threshs=(30, 130), num_events=61, will_log=True)</code>","text":"<p>Automate the correction of timing drift. Will adjust the stages to center the timetool edge on the camera and compensate the laser delay to maintain the desired nominal time point. Runs in an infinite loop.</p>"},{"location":"timetool.html#mfx.timetool.correct_timing_drift--parameters","title":"Parameters","text":"<p>amplitude_thresh : float, optional     The minimum amplitude of the fitted timetool peak to include the     data point in the rolling average used for drift correction.     Default: 0.02. ipm_thresh : float, optional     The minimum ipm DG2 value to perform drift correction. Setting a     reasonable value prevents attempts at drift correction when X-rays     are very weak or down. Default: 500. drift_adjustment_thresh : float, optional     The minimum drift value to correct for in picoseconds. E.g. a value     of 0.05 means any time the rolling average finds that the timetool     center is off by 50 fs in either direction it will compensate. Default:     0.05 ps. fwhm_threshs : Tuple[float, float], optional     Minimum and maximum FWHM from the processed timetool signal to consider     a measurement to be \"good.\" num_events : int, optional     The number of \"good\" timetool edge measurements to include in the     rolling average. Ideally a prime number to remove effects from     sytematic errors. Default 61 measurements. will_log : bool, optional     Log timing corrections to a file.</p> Source code in <code>mfx/timetool.py</code> <pre><code>def correct_timing_drift(\n    amplitude_thresh: float = 0.02,\n    ipm_thresh: float = 500.0,\n    drift_adjustment_thresh: float = 0.05,\n    fwhm_threshs: Tuple[float, float] = (30, 130),\n    num_events: int = 61,\n    will_log: bool = True,\n) -&gt; None:\n    \"\"\"\n    Automate the correction of timing drift. Will adjust the stages to\n    center the timetool edge on the camera and compensate the laser delay to\n    maintain the desired nominal time point. Runs in an infinite loop.\n\n    Parameters\n    ----------\n    amplitude_thresh : float, optional\n        The minimum amplitude of the fitted timetool peak to include the\n        data point in the rolling average used for drift correction.\n        Default: 0.02.\n    ipm_thresh : float, optional\n        The minimum ipm DG2 value to perform drift correction. Setting a\n        reasonable value prevents attempts at drift correction when X-rays\n        are very weak or down. Default: 500.\n    drift_adjustment_thresh : float, optional\n        The minimum drift value to correct for in picoseconds. E.g. a value\n        of 0.05 means any time the rolling average finds that the timetool\n        center is off by 50 fs in either direction it will compensate. Default:\n        0.05 ps.\n    fwhm_threshs : Tuple[float, float], optional\n        Minimum and maximum FWHM from the processed timetool signal to consider\n        a measurement to be \"good.\"\n    num_events : int, optional\n        The number of \"good\" timetool edge measurements to include in the\n        rolling average. Ideally a prime number to remove effects from\n        sytematic errors. Default 61 measurements.\n    will_log : bool, optional\n        Log timing corrections to a file.\n    \"\"\"\n    from mfx.db import lxt, txt\n\n    logfile: str = \"\"\n    if will_log:\n        logfile = input(\"Please enter a file to log correction info to: \")\n\n    timetool_edges: np.ndarray = np.zeros([num_events])\n\n    write_log(f\"Entering timetool drift correction loop\", logfile)\n    while True:\n        try:\n            num_curr_edges: int = 0\n            time_last_good_val: float = time.time()\n            while num_curr_edges &lt; num_events:\n                try:\n                    # EVENTBUILD PV contains 10 fields. TTALL makes up the last 8.\n                    # (indices 0-7), and IPM DG1 and DG2 makeup the first 2.\n                    # See `is_good_measurement` function for more accesses.\n                    timetool: EpicsSignal = EpicsSignal(\"MFX:TT:01:EVENTBUILD.VALA\")\n                    tt_data: np.ndarray = timetool.get()\n\n                    timetool_edge_ps: float = tt_data[3]\n\n                    if is_good_measurement(\n                        tt_data, amplitude_thresh, ipm_thresh, fwhm_threshs\n                    ):\n                        timetool_edges[num_curr_edges] = timetool_edge_ps\n                        num_curr_edges += 1\n                        time_last_good_val = time.time()\n                    elif time.time() - time_last_good_val &gt; 60:\n                        write_log(\n                            f\"No good measurement over one minute. Check thresholds?\",\n                            logfile,\n                        )\n                        time_last_good_val = time.time()\n\n                    time.sleep(0.01)\n                except KeyboardInterrupt as e:\n                    raise KeyboardInterrupt\n\n            tt_edge_average_ps: float = np.mean(timetool_edges)\n            write_log(f\"Current average: {tt_edge_average_ps}\", logfile)\n\n            if np.abs(tt_edge_average_ps) &gt; drift_adjustment_thresh:\n                tt_average_seconds: float = -(tt_edge_average_ps * 1e-12)\n                write_log(f\"Making adjustment to {tt_average_seconds}!\", logfile)\n                lxt.mvr(tt_average_seconds)\n                lxt.set_current_position(-float(txt.position))\n\n        except KeyboardInterrupt as e:\n            write_log(f\"Breaking out of timetool drift correction loop\", logfile)\n            break\n</code></pre>"},{"location":"timetool.html#mfx.timetool.is_good_measurement","title":"<code>is_good_measurement(tt_data, amplitude_thresh, ipm_thresh, fwhm_threshs)</code>","text":"<p>Determine whether a specific detected edge on the timetool camera is \"good\"</p> <p>Good/bad is defined by whether the timetool data shows the detected edge has a reasonable amplitude and a FWHM that falls within a specified range. A minimum X-ray intensity, as measured at IPM DG2, is also required for us to accept a measurement as accurate.</p>"},{"location":"timetool.html#mfx.timetool.is_good_measurement--parameters","title":"Parameters","text":"<p>tt_data : np.ndarray     Data read from the new timetool/EBUILD IOC which includes the TTALL     data as well as ipm readings. amplitude_thresh : float     Minimum amplitude extracted from timetool camera processing for the     measurement to be considered \"good.\" ipm_thresh : float     Minimum reading at ipm DG2 for a timetool measurement to be considered     \"good.\" fwhm_threshs : Tuple[float, float]     Minimum and maximum FWHM from the processed timetool signal to consider     a measurement to be \"good.\"</p> Source code in <code>mfx/timetool.py</code> <pre><code>def is_good_measurement(\n    tt_data: np.ndarray,\n    amplitude_thresh: float,\n    ipm_thresh: float,\n    fwhm_threshs: Tuple[float, float],\n) -&gt; bool:\n    \"\"\"\n    Determine whether a specific detected edge on the timetool camera is \"good\"\n\n    Good/bad is defined by whether the timetool data shows the detected edge\n    has a reasonable amplitude and a FWHM that falls within a specified range.\n    A minimum X-ray intensity, as measured at IPM DG2, is also required for us\n    to accept a measurement as accurate.\n\n    Parameters\n    ----------\n    tt_data : np.ndarray\n        Data read from the new timetool/EBUILD IOC which includes the TTALL\n        data as well as ipm readings.\n    amplitude_thresh : float\n        Minimum amplitude extracted from timetool camera processing for the\n        measurement to be considered \"good.\"\n    ipm_thresh : float\n        Minimum reading at ipm DG2 for a timetool measurement to be considered\n        \"good.\"\n    fwhm_threshs : Tuple[float, float]\n        Minimum and maximum FWHM from the processed timetool signal to consider\n        a measurement to be \"good.\"\n    \"\"\"\n    timetool_amp: float = tt_data[4]\n    ipm_dg2: float = tt_data[1]\n    fwhm: float = tt_data[7]\n\n    if timetool_amp &lt; amplitude_thresh:\n        return False\n    elif ipm_dg2 &lt; ipm_thresh:\n        return False\n    elif fwhm &lt; fwhm_threshs[0] or fwhm &gt; fwhm_threshs[1]:\n        return False\n\n    return True\n</code></pre>"},{"location":"timetool.html#mfx.timetool.write_log","title":"<code>write_log(msg, logfile='')</code>","text":"<p>Log messages both via the standard logger and optionally to a file.</p> <p>All messages will be timestamped.</p>"},{"location":"timetool.html#mfx.timetool.write_log--parameters","title":"Parameters","text":"<p>msg : str     Message to log. A timestamp will be prepended to the beginning of the     message - do NOT include one. logfile : str, optional     A logfile to also write the message to. Will append if the logfile     already exists. If the empty string is passed, no logfile is written     to. Default: \"\", i.e. do not write to a logfile.</p> Source code in <code>mfx/timetool.py</code> <pre><code>def write_log(msg: str, logfile: str = \"\") -&gt; None:\n    \"\"\"\n    Log messages both via the standard logger and optionally to a file.\n\n    All messages will be timestamped.\n\n    Parameters\n    ----------\n    msg : str\n        Message to log. A timestamp will be prepended to the beginning of the\n        message - do NOT include one.\n    logfile : str, optional\n        A logfile to also write the message to. Will append if the logfile\n        already exists. If the empty string is passed, no logfile is written\n        to. Default: \"\", i.e. do not write to a logfile.\n    \"\"\"\n    timestamped_msg: str = f\"[{time.ctime()}] {msg}\"\n    logger.info(timestamped_msg)\n\n    if logfile:\n        with open(logfile, \"a\") as f:\n            f.write(timestamped_msg)\n</code></pre>"},{"location":"transfocator.html","title":"Transfocator","text":""},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator","title":"<code>MFXTransfocator</code>","text":"<p>               Bases: <code>TransfocatorBase</code></p> <p>Class to represent the MFX Transfocator</p> Source code in <code>tfs/transfocator.py</code> <pre><code>class MFXTransfocator(TransfocatorBase):\n    \"\"\"\n    Class to represent the MFX Transfocator\n    \"\"\"\n    interlock = Cpt(TransfocatorInterlock, '')\n\n    # XRT Lenses\n    prefocus_top = Cpt(Lens, \":DIA:03\")\n    prefocus_mid = Cpt(Lens, \":DIA:02\")\n    prefocus_bot = Cpt(Lens, \":DIA:01\")\n    xrt_radius = Cpt(EpicsSignalRO, \":BEAM:XRT_RADIUS\", kind=\"normal\",\n                     doc=\"XRT effective radius\")\n    tfs_radius = Cpt(EpicsSignalRO, \":BEAM:TFS_RADIUS\", kind=\"normal\",\n                     doc=\"TFS effective radius\")\n\n    # TFS Lenses\n    tfs_02 = Cpt(Lens, \":TFS:02\")\n    tfs_03 = Cpt(Lens, \":TFS:03\")\n    tfs_04 = Cpt(Lens, \":TFS:04\")\n    tfs_05 = Cpt(Lens, \":TFS:05\")\n    tfs_06 = Cpt(Lens, \":TFS:06\")\n    tfs_07 = Cpt(Lens, \":TFS:07\")\n    tfs_08 = Cpt(Lens, \":TFS:08\")\n    tfs_09 = Cpt(Lens, \":TFS:09\")\n    tfs_10 = Cpt(Lens, \":TFS:10\")\n\n    # Requested energy\n    req_energy = Cpt(EpicsSignal, \":BEAM:REQ_ENERGY\")\n\n    # Actual beam energy\n    beam_energy = Cpt(EpicsSignal, \":BEAM:ENERGY\")\n\n    # Translation\n    translation = FormattedComponent(IMS, \"MFX:TFS:MMS:21\")\n\n    def __init__(self, prefix, *, nominal_sample=399.88103, **kwargs):\n        self.nominal_sample = nominal_sample\n        super().__init__(prefix, **kwargs)\n\n    @property\n    def lenses(self):\n        \"\"\"\n        Component lenses\n        \"\"\"\n        return [getattr(self, dev) for dev in self._sub_devices\n                if isinstance(getattr(self, dev), Lens)]\n\n    @property\n    def xrt_lenses(self):\n        \"\"\"\n        Lenses in the XRT\n        \"\"\"\n        return [lens for lens in self.lenses if 'DIA' in lens.prefix]\n\n    @property\n    def tfs_lenses(self):\n        \"\"\"\n        Transfocator lenses\n        \"\"\"\n        return [lens for lens in self.lenses if 'TFS' in lens.prefix]\n\n    @property\n    def current_focus(self):\n        \"\"\"\n        The distance from the focus of the Transfocator to nominal_sample\n\n        Note\n        ----\n        If no lenses are inserted this will retun NaN\n        \"\"\"\n        # Find inserted lenses\n        inserted = [lens for lens in self.lenses if lens.inserted]\n        # Check that we have any inserted lenses at all\n        if not inserted:\n            logger.warning(\"No lenses are currently inserted\")\n            return math.nan\n        # Calculate the image from this set of lenses\n        return LensConnect(*inserted).image(0.0) - self.nominal_sample\n    def remove_all(self):\n        \"\"\"\n        Removes all tfs lenses.\n        \"\"\"\n        self.tfs_02.remove()\n        self.tfs_03.remove()\n        self.tfs_04.remove()\n        self.tfs_05.remove()\n        self.tfs_06.remove()\n        self.tfs_07.remove()\n        self.tfs_08.remove()\n        self.tfs_09.remove()\n        self.tfs_10.remove()\n\n    def find_best_combo(self, target=None, energy=None, show=True, **kwargs):\n        \"\"\"\n        Calculate the best lens array to hit the nominal sample point\n\n        Parameters\n        ----------\n        target : float, optional\n            The target image of the lens array. By default this is\n            `nominal_sample`\n\n        show : bool, optional\n            Print a table of the of the calculated lens combination\n\n        kwargs:\n            Passed to :meth:`.Calculator.find_solution`\n        \"\"\"\n        energy = energy or self.beam_energy.get()\n        target = target or self.nominal_sample\n        calc = TFS_Calculator(tfs_lenses=self.tfs_lenses, prefocus_lenses=self.xrt_lenses)\n        combo, diff = calc.find_solution(target, energy, **kwargs)\n        if combo:\n            combo.show_info()\n            logger.info(f'Difference to desired focus position: {round(diff*1000, 2)} mm')\n            radius = combo.tfs_radius\n            logger.info(f'Calculated Radius: {round(radius, 2)} um')\n            estimate_beam_fwhm(radius=radius, energy=energy)\n            focal = focal_length(radius=radius, energy=energy)\n\n            logger.info(f'Calculated Focal Length: {focal} um\\n')\n\n        else:\n            logger.error(\"Unable to find a valid solution for target\")\n        return combo\n\n    def set(self, value, **kwargs):\n        \"\"\"\n        Set the Transfocator focus\n\n        Parameters\n        \"\"\"\n        return self.focus_at(value=value, **kwargs)\n\n    def focus_at(self, value=None, wait=False, timeout=None, **kwargs):\n        \"\"\"\n        Calculate a combination and insert the lenses\n\n        Parameters\n        ----------\n        value: float, optional\n            Chosen focal plane. Nominal sample by default\n\n        wait : bool, optional\n            Wait for the motion of the transfocator to complete\n\n        timeout: float, optional\n            Timeout for motion\n\n        kwargs:\n            All passed to :meth:`.find_best_combo`\n\n        Returns\n        -------\n        StateStatus\n            Status that represents whether the move is complete\n        \"\"\"\n        # Find the best combination of lenses to match the target image\n        plane = value or self.nominal_sample\n        best_combo = self.find_best_combo(target=plane, **kwargs)\n        # Collect status to combine\n        statuses = list()\n        # Only tell one XRT lens to insert\n        prefocused = False\n        for lens in self.xrt_lenses:\n            if lens in best_combo.lenses:\n                statuses.append(lens.insert(timeout=timeout))\n                prefocused = True\n                break\n        # If we have no XRT lenses one remove will do\n        if not prefocused:\n            statuses.append(self.xrt_lenses[0].remove(timeout=timeout))\n        # Ensure all Transfocator lenses are correct\n        for lens in self.tfs_lenses:\n            if lens in best_combo.lenses:\n                statuses.append(lens.insert(timeout=timeout))\n            else:\n                statuses.append(lens.remove(timeout=timeout))\n        # Conglomerate all status objects\n        status = statuses.pop(0)\n        for st in statuses:\n            status = status &amp; st\n        # Wait if necessary\n        if wait:\n            status_wait(status, timeout=timeout)\n        return status\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.current_focus","title":"<code>current_focus</code>  <code>property</code>","text":"<p>The distance from the focus of the Transfocator to nominal_sample</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.current_focus--note","title":"Note","text":"<p>If no lenses are inserted this will retun NaN</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.lenses","title":"<code>lenses</code>  <code>property</code>","text":"<p>Component lenses</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.tfs_lenses","title":"<code>tfs_lenses</code>  <code>property</code>","text":"<p>Transfocator lenses</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.xrt_lenses","title":"<code>xrt_lenses</code>  <code>property</code>","text":"<p>Lenses in the XRT</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.find_best_combo","title":"<code>find_best_combo(target=None, energy=None, show=True, **kwargs)</code>","text":"<p>Calculate the best lens array to hit the nominal sample point</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.find_best_combo--parameters","title":"Parameters","text":"<p>target : float, optional     The target image of the lens array. By default this is     <code>nominal_sample</code></p> bool, optional <p>Print a table of the of the calculated lens combination</p> kwargs <p>Passed to :meth:<code>.Calculator.find_solution</code></p> Source code in <code>tfs/transfocator.py</code> <pre><code>def find_best_combo(self, target=None, energy=None, show=True, **kwargs):\n    \"\"\"\n    Calculate the best lens array to hit the nominal sample point\n\n    Parameters\n    ----------\n    target : float, optional\n        The target image of the lens array. By default this is\n        `nominal_sample`\n\n    show : bool, optional\n        Print a table of the of the calculated lens combination\n\n    kwargs:\n        Passed to :meth:`.Calculator.find_solution`\n    \"\"\"\n    energy = energy or self.beam_energy.get()\n    target = target or self.nominal_sample\n    calc = TFS_Calculator(tfs_lenses=self.tfs_lenses, prefocus_lenses=self.xrt_lenses)\n    combo, diff = calc.find_solution(target, energy, **kwargs)\n    if combo:\n        combo.show_info()\n        logger.info(f'Difference to desired focus position: {round(diff*1000, 2)} mm')\n        radius = combo.tfs_radius\n        logger.info(f'Calculated Radius: {round(radius, 2)} um')\n        estimate_beam_fwhm(radius=radius, energy=energy)\n        focal = focal_length(radius=radius, energy=energy)\n\n        logger.info(f'Calculated Focal Length: {focal} um\\n')\n\n    else:\n        logger.error(\"Unable to find a valid solution for target\")\n    return combo\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.focus_at","title":"<code>focus_at(value=None, wait=False, timeout=None, **kwargs)</code>","text":"<p>Calculate a combination and insert the lenses</p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.focus_at--parameters","title":"Parameters","text":"<p>value: float, optional     Chosen focal plane. Nominal sample by default</p> bool, optional <p>Wait for the motion of the transfocator to complete</p> float, optional <p>Timeout for motion</p> kwargs <p>All passed to :meth:<code>.find_best_combo</code></p>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.focus_at--returns","title":"Returns","text":"<p>StateStatus     Status that represents whether the move is complete</p> Source code in <code>tfs/transfocator.py</code> <pre><code>def focus_at(self, value=None, wait=False, timeout=None, **kwargs):\n    \"\"\"\n    Calculate a combination and insert the lenses\n\n    Parameters\n    ----------\n    value: float, optional\n        Chosen focal plane. Nominal sample by default\n\n    wait : bool, optional\n        Wait for the motion of the transfocator to complete\n\n    timeout: float, optional\n        Timeout for motion\n\n    kwargs:\n        All passed to :meth:`.find_best_combo`\n\n    Returns\n    -------\n    StateStatus\n        Status that represents whether the move is complete\n    \"\"\"\n    # Find the best combination of lenses to match the target image\n    plane = value or self.nominal_sample\n    best_combo = self.find_best_combo(target=plane, **kwargs)\n    # Collect status to combine\n    statuses = list()\n    # Only tell one XRT lens to insert\n    prefocused = False\n    for lens in self.xrt_lenses:\n        if lens in best_combo.lenses:\n            statuses.append(lens.insert(timeout=timeout))\n            prefocused = True\n            break\n    # If we have no XRT lenses one remove will do\n    if not prefocused:\n        statuses.append(self.xrt_lenses[0].remove(timeout=timeout))\n    # Ensure all Transfocator lenses are correct\n    for lens in self.tfs_lenses:\n        if lens in best_combo.lenses:\n            statuses.append(lens.insert(timeout=timeout))\n        else:\n            statuses.append(lens.remove(timeout=timeout))\n    # Conglomerate all status objects\n    status = statuses.pop(0)\n    for st in statuses:\n        status = status &amp; st\n    # Wait if necessary\n    if wait:\n        status_wait(status, timeout=timeout)\n    return status\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.remove_all","title":"<code>remove_all()</code>","text":"<p>Removes all tfs lenses.</p> Source code in <code>tfs/transfocator.py</code> <pre><code>def remove_all(self):\n    \"\"\"\n    Removes all tfs lenses.\n    \"\"\"\n    self.tfs_02.remove()\n    self.tfs_03.remove()\n    self.tfs_04.remove()\n    self.tfs_05.remove()\n    self.tfs_06.remove()\n    self.tfs_07.remove()\n    self.tfs_08.remove()\n    self.tfs_09.remove()\n    self.tfs_10.remove()\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.MFXTransfocator.set","title":"<code>set(value, **kwargs)</code>","text":"<p>Set the Transfocator focus</p> <p>Parameters</p> Source code in <code>tfs/transfocator.py</code> <pre><code>def set(self, value, **kwargs):\n    \"\"\"\n    Set the Transfocator focus\n\n    Parameters\n    \"\"\"\n    return self.focus_at(value=value, **kwargs)\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.TransfocatorEnergyInterrupt","title":"<code>TransfocatorEnergyInterrupt</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception returned when input beam energy (user defined or current measured value) changes significantly during calculation</p> Source code in <code>tfs/transfocator.py</code> <pre><code>class TransfocatorEnergyInterrupt(Exception):\n    \"\"\"\n    Custom exception returned when input beam energy (user defined\n    or current measured value) changes significantly during\n    calculation\n    \"\"\"\n    pass\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.TransfocatorInterlock","title":"<code>TransfocatorInterlock</code>","text":"<p>               Bases: <code>Device</code></p> <p>Device containing signals pertinent to the interlock system.</p> Source code in <code>tfs/transfocator.py</code> <pre><code>class TransfocatorInterlock(Device):\n    \"\"\"\n    Device containing signals pertinent to the interlock system.\n    \"\"\"\n    limits = Cpt(\n        LensTripLimits, \":ACTIVE\",\n        doc=\"Active trip limit settings, based on pre-focus lens\"\n    )\n\n    # Active limits, predicated on pre-focus lens insertion:\n    # no_lens_limit = Cpt(LensTripLimits, \":NO_LENS\")\n    # lens1_limit = Cpt(LensTripLimits, \":LENS1\")\n    # lens2_limit = Cpt(LensTripLimits, \":LENS2\")\n    # lens3_limit = Cpt(LensTripLimits, \":LENS3\")\n\n    bypass = Cpt(\n        EpicsSignal, \":BYPASS:STATUS\", write_pv=\":BYPASS:SET\",\n        doc=\"Bypass in use?\",\n    )\n    bypass_energy = Cpt(\n        EpicsSignal, \":BYPASS:ENERGY\",\n        doc=\"Bypass energy\",\n    )\n    ioc_alive = Cpt(\n        EpicsSignalRO, \":BEAM:ALIVE\",  # string=True,\n        doc=\"IOC alive [active]\"\n    )\n    faulted = Cpt(\n        EpicsSignalRO, \":BEAM:FAULTED\",  # string=True,\n        doc=\"Fault currently active [active]\"\n    )\n    state_fault = Cpt(\n        EpicsSignalRO, \":BEAM:UNKNOWN\",  # string=True,\n        doc=\"Lens position unknown [active]\"\n    )\n\n    violated_fault = Cpt(\n        EpicsSignalRO, \":BEAM:VIOLATED\",  # string=True,\n        doc=\"Summary fault due to energy/lens combination [active]\"\n    )\n    min_fault = Cpt(\n        EpicsSignalRO, \":BEAM:MIN_FAULT\",  # string=True,\n        doc=\"Minimum required energy not met for lens combination [active]\"\n    )\n    lens_required_fault = Cpt(\n        EpicsSignalRO, \":BEAM:REQ_TFS_FAULT\",  # string=True,\n        doc=\"Transfocator lens required for energy/lens combination [active]\"\n    )\n    table_fault = Cpt(\n        EpicsSignalRO, \":BEAM:TAB_FAULT\",  # string=True,\n        doc=\"Effective radius in table-based disallowed area [active]\"\n    )\n\n    violated_fault_latch = Cpt(\n        EpicsSignalRO, \":BEAM:VIOLATED_LT\",  # string=True,\n        doc=\"Summary fault due to energy/lens combination [latched]\"\n    )\n    min_fault_latch = Cpt(\n        EpicsSignalRO, \":BEAM:MIN_FAULT_LT\",  # string=True,\n        doc=\"Minimum required energy not met for lens combination [latched]\"\n    )\n    lens_required_fault_latch = Cpt(\n        EpicsSignalRO, \":BEAM:REQ_TFS_FAULT_LT\",  # string=True,\n        doc=\"Transfocator lens required for energy/lens combination [latched]\"\n    )\n    table_fault_latch = Cpt(\n        EpicsSignalRO, \":BEAM:TAB_FAULT_LT\",  # string=True,\n        doc=\"Effective radius in table-based disallowed area [latched]\"\n    )\n</code></pre>"},{"location":"transfocator.html#tfs.transfocator.constant_energy","title":"<code>constant_energy(func)</code>","text":"<p>Ensures that requested energy does not change during calculation</p> <p>Parameters: transfocator_obj: transfocate.transfocator.Transfocator object</p> string <p>input string specifying 'req_energy' or 'beam_energy' to be monitored during calculation</p> float <p>energy (in eV) for which current beam energy can change during calculation and still assumed constant</p> Source code in <code>tfs/transfocator.py</code> <pre><code>def constant_energy(func):\n    \"\"\"\n    Ensures that requested energy does not change during calculation\n\n    Parameters:\n    transfocator_obj: transfocate.transfocator.Transfocator object\n\n    energy_type: string\n        input string specifying 'req_energy' or 'beam_energy'\n        to be monitored during calculation\n\n    tolerance: float\n        energy (in eV) for which current beam energy can change during\n        calculation and still assumed constant\n    \"\"\"\n    @wraps(func)\n    def with_constant_energy(transfocator_obj, energy_type, tolerance, *args, **kwargs):\n        try:\n            energy_signal = getattr(transfocator_obj, energy_type)\n        except Exception as e:\n            raise AttributeError(\"input 'energy_type' not defined\") from e\n        energy_before = energy_signal.get()\n        result = func(transfocator_obj, *args, **kwargs)\n        energy_after = energy_signal.get()\n        if not math.isclose(energy_before, energy_after, abs_tol=tolerance):\n            raise TransfocatorEnergyInterrupt(\"The beam energy changed significantly during the calculation\")\n        return result\n    return with_constant_energy\n</code></pre>"},{"location":"transfocator_scan.html","title":"Transfocator scan","text":""},{"location":"utils.html","title":"Utils","text":""},{"location":"utils.html#tfs.utils.focal_length","title":"<code>focal_length(radius, energy, N=1)</code>","text":"<p>Calculate focal length using the pcds version of the focal length calculator</p> Source code in <code>tfs/utils.py</code> <pre><code>def focal_length(radius, energy,N=1):\n    \"\"\"\n    Calculate focal length using the pcds version of the focal length calculator\n    \"\"\"\n    if N!=1:\n        logger.error('N does not equal 1!')\n    focal_length = calc.be_lens_calcs.calc_focal_length_for_single_lens(energy*1E-3,radius*1E-6)\n\n    return focal_length\n</code></pre>"},{"location":"utils.html#tfs.utils.focal_length_old","title":"<code>focal_length_old(radius, energy, N=1)</code>","text":"<p>Calculate the focal length of a Beryllium lens Ref: HR Beguiristain et al. OPTICS LETTERS, Vol. 27, No. 9 (2002)</p> <p>Probably want to use pcdscalc instead eventually</p> Source code in <code>tfs/utils.py</code> <pre><code>def focal_length_old(radius, energy, N=1):\n    \"\"\"\n    Calculate the focal length of a Beryllium lens\n    Ref: HR Beguiristain et al. OPTICS LETTERS, Vol. 27, No. 9 (2002)\n\n    Probably want to use pcdscalc instead eventually\n    \"\"\"\n    # Get scattering factors\n    f1, f2 = pt.Be.xray.scattering_factors(energy=energy/1000)\n\n    # Calculate delta (refraction index)\n    f = f1+f2*1j\n    f = f*p_be*NA/m_be\n    wavelength = (12389.4/energy)*1E-08  # [cm]\n    delta = (eRad * wavelength**2 * f / (2*np.pi)).real\n    # delta = be_calcs.get_delta(energy/1000, 'Be', p_be) # too slow\n\n    # f = R / (2N*delta)\n    return radius*1e-6/2/N/delta\n</code></pre>"},{"location":"xlj_fast.html","title":"Xlj fast","text":""},{"location":"xlj_fast.html#mfx.xlj_fast.xlj_fast_xyz","title":"<code>xlj_fast_xyz(orientation='horizontal', scale=0.1)</code>","text":""},{"location":"xlj_fast.html#mfx.xlj_fast.xlj_fast_xyz--parameters","title":"Parameters","text":"<p>orientation: str, optional     set orientation to change the x and y axis. horizontal by default     use only 'horizontal' of 'vertical'</p> float, optional <p>starting scale for the step size</p>"},{"location":"xlj_fast.html#mfx.xlj_fast.xlj_fast_xyz--operations","title":"Operations","text":"<p>Base function to control motors with the arrow keys.</p> <p>With three motors, you can use the right and left arrow keys to move right  and left, up and down arrow keys to move up and down, and Shift+up and  shift+down to move z in and out</p> <p>The scale for the tweak can be doubled by pressing + and halved by pressing -. Shift+right and shift+left can also be used, and the up and down keys will also adjust the scaling in one motor mode. The starting scale can be set with the keyword argument <code>scale</code>.</p> <p>Ctrl+c will stop an ongoing move during a tweak without exiting the tweak. Both q and ctrl+c will quit the tweak between moves.</p> Source code in <code>mfx/xlj_fast.py</code> <pre><code>def xlj_fast_xyz(orientation='horizontal', scale=0.1):\n    \"\"\"\n    Parameters\n    ----------\n    orientation: str, optional\n        set orientation to change the x and y axis. horizontal by default\n        use only 'horizontal' of 'vertical'\n\n    scale: float, optional\n        starting scale for the step size\n\n    Operations\n    ----------\n    Base function to control motors with the arrow keys.\n\n    With three motors, you can use the right and left arrow keys to move right \n    and left, up and down arrow keys to move up and down, and Shift+up and \n    shift+down to move z in and out\n\n    The scale for the tweak can be doubled by pressing + and halved by pressing\n    -. Shift+right and shift+left can also be used, and the up and down keys will\n    also adjust the scaling in one motor mode. The starting scale can be set\n    with the keyword argument `scale`.\n\n    Ctrl+c will stop an ongoing move during a tweak without exiting the tweak.\n    Both q and ctrl+c will quit the tweak between moves.\n    \"\"\"\n\n    if orientation == str('horizontal').lower():\n        xlj_fast_x = BypassPositionCheck(\"MFX:LJH:JET:X\", name=\"xlj_fast_x\")\n        xlj_fast_y = BypassPositionCheck(\"MFX:LJH:JET:Y\", name=\"xlj_fast_y\")\n\n    if orientation == str('vertical').lower():\n        xlj_fast_y = BypassPositionCheck(\"MFX:LJH:JET:X\", name=\"xlj_fast_x\")\n        xlj_fast_x = BypassPositionCheck(\"MFX:LJH:JET:Y\", name=\"xlj_fast_y\")\n\n    xlj_fast_z = BypassPositionCheck(\"MFX:LJH:JET:Z\", name=\"xlj_fast_z\")\n\n    xlj = BeckhoffJet('MFX:LJH', name='xlj')\n\n    up = \"\\x1b[A\"\n    down = \"\\x1b[B\"\n    right = \"\\x1b[C\"\n    left = \"\\x1b[D\"\n    shift_up = \"\\x1b[1;2A\"\n    shift_down = \"\\x1b[1;2B\"\n    shift_right = \"\\x1b[1;2C\"\n    shift_left = \"\\x1b[1;2D\"\n    alt_up = \"\\x1b[1;3A\"\n    alt_down = \"\\x1b[1;3B\"\n    alt_right = \"\\x1b[1;3C\"\n    alt_left = \"\\x1b[1;3D\"\n    ctrl_up = \"\\x1b[1;5A\"\n    ctrl_down = \"\\x1b[1;5B\"\n    ctrl_right = \"\\x1b[1;5C\"\n    ctrl_left = \"\\x1b[1;5D\"\n    plus = \"+\"\n    equal = \"=\"\n    minus = \"-\"\n    under = \"_\"\n\n    abs_status = '{}: {:.4f}'\n    exp_status = '{}: {:.4e}'\n\n    move_keys = (left, right, up, down, shift_up, shift_down)\n    scale_keys = (plus, minus, equal, under, shift_right, shift_left)\n    motors = [xlj_fast_x, xlj_fast_y, xlj_fast_z]\n\n\n    def show_status():\n        if scale &gt;= 0.0001:\n            template = abs_status\n        else:\n            template = exp_status\n        text = [template.format(mot.name, mot.wm()) for mot in motors]\n        text.append(f'scale: {scale}')\n        print('\\x1b[2K\\r' + ', '.join(text), end='')\n\n\n    def usage():\n        print()  # Newline\n        print(\" Left: move x motor left\")\n        print(\" Right: move x motor right\")\n        print(\" Down: move y motor down\")\n        print(\" Up: move y motor up\")\n        print(\" shift+up: Z upstream\")\n        print(\" shift+down: Z downstream\")\n        print(\" + or shift+right: scale*2\")\n        print(\" - or shift+left: scale/2\")\n        print(\" Press q to quit.\"\n              \" Press any other key to display this message.\")\n        print()  # Newline\n\n\n    def edit_scale(scale, direction):\n        \"\"\"Function used to change the scale.\"\"\"\n        if direction in (up, shift_right, plus, equal):\n            scale = scale*2\n        elif direction in (down, shift_left, minus, under):\n            scale = scale/2\n        return scale\n\n\n    def movement(scale, direction):\n        \"\"\"Function used to know when and the direction to move the motor.\"\"\"\n        try:\n            if direction == left:\n                if round(xlj.jet.x(), 2) != round(xlj_fast_x(), 2):\n                    logger.error(f'xlj.jet.x = {xlj.jet.x()}, xlj_fast_x = {xlj_fast_x()}')\n                    xlj_fast_x.umv(xlj.jet.x())\n                xlj_fast_x.umvr(-scale, log=False, newline=False)\n            elif direction == right:\n                if round(xlj.jet.x(), 2) != round(xlj_fast_x(), 2):\n                    logger.error(f'xlj.jet.x = {xlj.jet.x()}, xlj_fast_x = {xlj_fast_x()}')\n                    xlj_fast_x.umv(xlj.jet.x())\n                xlj_fast_x.umvr(scale, log=False, newline=False)\n            elif direction == up:\n                if round(xlj.jet.y(), 2) != round(xlj_fast_y(), 2):\n                    logger.error(f'xlj.jet.y = {xlj.jet.y()}, xlj_fast_y = {xlj_fast_y()}')\n                    xlj_fast_y.umv(xlj.jet.y())\n                xlj_fast_y.umvr(scale, log=False, newline=False)\n            elif direction == down:\n                if round(xlj.jet.y(), 2) != round(xlj_fast_y(), 2):\n                    logger.error(f'xlj.jet.y = {xlj.jet.y()}, xlj_fast_y = {xlj_fast_y()}')\n                    xlj_fast_y.umv(xlj.jet.y())\n                xlj_fast_y.umvr(-scale, log=False, newline=False)\n            elif direction == shift_up:\n                if round(xlj.jet.z(), 2) != round(xlj_fast_z(), 2):\n                    logger.error(f'xlj.jet.z = {xlj.jet.z()}, xlj_fast_z = {xlj_fast_z()}')\n                    xlj_fast_z.umv(xlj.jet.z())\n                xlj_fast_z.umvr(-scale, log=False, newline=False)\n            elif direction == shift_down:\n                if round(xlj.jet.z(), 2) != round(xlj_fast_z(), 2):\n                    logger.error(f'xlj.jet.z = {xlj.jet.z()}, xlj_fast_z = {xlj_fast_z()}')\n                    xlj_fast_z.umv(xlj.jet.z())\n                xlj_fast_z.umvr(scale, log=False, newline=False)\n        except Exception as exc:\n            logger.error('Error in tweak move: %s', exc)\n            logger.debug('', exc_info=True)\n\n    start_text = [f'{mot.name} at {mot.wm():.4f}' for mot in motors]\n    logger.info('Started tweak of ' + ', '.join(start_text))\n    usage()\n\n    # Loop takes in user key input and stops when 'q' is pressed\n    is_input = True\n    while is_input is True:\n        show_status()\n        inp = utils.get_input()\n        if inp in ('q'):\n            is_input = False\n        elif inp in move_keys:\n            movement(scale, inp)\n        elif inp in scale_keys:\n            scale = edit_scale(scale, inp)\n        elif inp in ('h'):\n            usage()\n        else:\n            logger.error('Not the way to use this. Press \"h\" to see how.')\n    print()\n    logger.info('Tweak complete')\n</code></pre>"},{"location":"yano.html","title":"Yano","text":""},{"location":"yano.html#mfx.yano.yano","title":"<code>yano</code>","text":"Source code in <code>mfx/yano.py</code> <pre><code>class yano:\n    def __init__(self):\n        from mfx.devices import LaserShutter\n        from pcdsdevices.evr import Trigger\n        self.delay = None\n\n        # Declare shutter objects\n        self.opo_shutter = LaserShutter('MFX:USR:ao1:6', name='opo_shutter')\n        self.evo_shutter1 = LaserShutter('MFX:USR:ao1:7', name='evo_shutter1')\n        self.evo_shutter2 = LaserShutter('MFX:USR:ao1:2', name='evo_shutter2')\n        self.evo_shutter3 = LaserShutter('MFX:USR:ao1:3', name='evo_shutter3')\n\n        # Trigger objects\n        self.opo = Trigger('MFX:LAS:EVR:01:TRIG6', name='opo_trigger')\n        self.evo = Trigger('MFX:LAS:EVR:01:TRIG5', name='evo_trigger')\n\n        # Laser parameter\n        self.opo_time_zero = 671765\n\n        # Event code switch logic for longer delay\n        self.opo_ec_short = 212\n        self.opo_ec_long = 211\n        self.opo_ec_longer = 210\n        self.PP = 197\n        self.DAQ = 198\n        self.WATER = 211\n        self.SAMPLE = 212\n        self.rep_rate = 20\n\n\n    @property\n    def shutter_status(self):\n        \"\"\"Show current shutter status\"\"\"\n        status = []\n        for shutter in (self.evo_shutter1, self.evo_shutter2,\n                        self.evo_shutter3, self.opo_shutter):\n            status.append(shutter.state.get())\n        return status\n\n\n    def configure_shutters(self, fiber1=False, fiber2=False, fiber3=False, free_space=None):\n        \"\"\"\n        Configure all four laser shutters\n\n        True means that the fiber will be used and the shutter is removed.\n        False means that the fiber will be blocked and the shutter is inserted \n           - default for evo laser fiber1, fiber2, fiber3\n        None means that the shutter will not be changed\n           - default for opo laser\n\n        Parameters\n        ----------\n        fiber1: bool\n            Controls ``evo_shutter1``\n\n        fiber2: bool\n            Controls ``evo_shutter2``\n\n        fiber3: bool\n            Controls ``evo_shutter3``\n\n        free_space: bool\n            Controls ``opo_shutter``\n        \"\"\"\n        from time import sleep\n        for state, shutter in zip((fiber1, fiber2, fiber3, free_space),\n                                  (self.evo_shutter1, self.evo_shutter2,\n                                   self.evo_shutter3, self.opo_shutter)):\n            if state is not None:\n                if state == True or state == 'OUT' or state == 2:\n                    shutter('OUT')\n                else:\n                    shutter('IN')\n        #logger.info(\"Shutters set to fiber1=%s, fiber2=%s, fiber3=%s, free_space=%s\", fiber1, fiber2, fiber3, free_space)\n        sleep(1)\n        return\n\n\n    def fiber_0(self):\n        return self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=None)\n\n\n    def fiber_1(self):\n        return self.configure_shutters(fiber1=False, fiber2=False, fiber3=True, free_space=None)\n\n\n    def fiber_2(self):\n        return self.configure_shutters(fiber1=False, fiber2=True, fiber3=True, free_space=None)\n\n\n    def fiber_3(self):\n        return self.configure_shutters(fiber1=True, fiber2=True, fiber3=True, free_space=None)\n\n\n    def _delaystr(self, delay):\n        \"\"\"\n        OPO delay string\n        \"\"\"\n        if self.opo_shutter.state.value == 'IN':\n            return 'No OPO Laser'\n        elif delay &gt;= 1e6:\n            return 'Laser delay is set to {:10.6f} ms'.format(delay/1.e6)\n        elif delay &gt;= 1e3:\n            return 'Laser delay is set to {:7.3f} us'.format(delay/1.e3)\n        elif delay &gt;= 0:\n            return 'Laser delay is set to {:4.0f} ns'.format(delay)\n        else:\n            return 'Laser delay is set to {:8.0f} ns (AFTER X-ray pulse)'.format(delay)\n\n\n    def _wrap_delay(self, delay, base_rate=120):\n        \"\"\"\n        given a delay in units of nanoseconds, wrap the delay so that\n        it is strictly less than the period of the base_rate\n        \"\"\"\n        if delay*1E-9 &gt; 1/base_rate:\n            adjusted_delay = delay - (1/base_rate)*1E9\n        else:\n            adjusted_delay = delay\n        return adjusted_delay \n\n\n    def set_delay(self, delay):\n        \"\"\"\n        Set the delay\n\n        Parameters\n        ----------\n        delay: float\n            Requested laser delay in nanoseconds.\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n        # Determine event code of inhibit pulse\n        logger.info(\"Setting delay %s ns (%s us)\", delay, delay/1000.)\n        self.delay = delay\n        opo_delay = self.opo_time_zero - delay\n        opo_ec = self.opo_ec_short\n        if delay &gt; self.opo_time_zero + 1e9/120:\n            opo_delay += 2e9/120\n            opo_ec = self.opo_ec_longer\n            logger.info('Laser is 2 buckets before the beam')\n        elif delay &gt; self.opo_time_zero:\n            opo_delay += 1e9/120\n            opo_ec = self.opo_ec_long\n            logger.info('Laser is 1 bucket before the beam')\n        else:\n            logger.info('Laser is in the same bucket as the beam')      \n\n\n        self.opo.ns_delay.put(opo_delay)\n        logger.info(\"Setting OPO delay %s ns\", opo_delay)\n        self.opo.eventcode.put(opo_ec)\n        logger.info(\"Setting OPO ec %s\", opo_ec)\n        logger.info(self._delaystr(delay))\n        return\n\n\n    def get_delay(self):\n        \"\"\"\n        Reads the current delay in ns\n\n        Parameters\n        ----------\n        delay: float\n            Requested laser delay in nanoseconds.\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n        if self.opo.eventcode.get() == self.opo_ec_long:\n            opo_delay = self.opo.ns_delay.get() - 1e9/120\n        else:\n            opo_delay = self.opo.ns_delay.get()\n        delay = self.opo_time_zero - opo_delay \n        logger.info(self._delaystr(delay))\n        return delay\n\n\n    def post(self, sample='?', run_number=None, post=False, inspire=False, add_note=''):\n        \"\"\"\n        Posts a message to the elog\n\n        Parameters\n        ----------\n        sample: str, optional\n            Sample Name\n\n        run_number: int, optional\n            Run Number. By default this is read off of the DAQ\n\n        post: bool, optional\n            set True to record/post message to elog\n\n        inspire: bool, optional\n            Set false by default because it makes Sandra sad. Set True to inspire\n\n        add_note: string, optional\n            adds additional note to elog message \n        \"\"\"\n        from mfx.db import daq, elog\n        from mfx.autorun import quote\n        post_template = \"\"\"\\\n        Run Number {}: {}\n\n        {}\n\n        While the laser shutters are:\n        EVO fiber 1 -&gt;  {}\n        EVO fiber 2 -&gt;  {}\n        EVO fiber 3 -&gt;  {}\n        OPO Shutter -&gt;  {}\n        \"\"\"\n        if add_note!='':\n            add_note = '\\n' + add_note\n        if inspire:\n            comment = f\"Running {sample}\\n{quote()['quote']}{add_note}\"\n        else:\n            comment = f\"Running {sample}{add_note}\"\n        delay = self.get_delay()\n        if run_number is None:\n            run_number = daq.run_number()\n        info = [run_number, comment, self._delaystr(delay)]\n        info.extend(self.shutter_status)\n        post_msg = post_template.format(*info)\n        print('\\n' + post_msg + '\\n')\n        if post:\n            elog.post(msg=post_msg, run=(run_number))\n        return post_msg\n\n\n    def begin(self, events=None, duration=300,\n              record=False, use_l3t=None, controls=None,\n              wait=False, end_run=False):\n        \"\"\"\n        Start the daq and block until the daq has begun acquiring data.\n\n        Optionally block with ``wait=True`` until the daq has finished aquiring\n        data. If blocking, a ``ctrl+c`` will end the run and clean up.\n\n        If omitted, any argument that is shared with `configure`\n        will fall back to the configured value.\n\n        Internally, this calls `kickoff` and manages its ``Status`` object.\n\n        Parameters\n        ----------\n        events: ``int``, optional\n            Number events to take in the daq.\n\n        duration: ``int``, optional\n            Time to run the daq in seconds, if ``events`` was not provided.\n\n        record: ``bool``, optional\n            If ``True``, we'll configure the daq to record data before this\n            run.\n\n        use_l3t: ``bool``, optional\n            If ``True``, we'll run with the level 3 trigger. This means that\n            if we specified a number of events, we will wait for that many\n            \"good\" events as determined by the daq.\n\n        controls: ``dict{name: device}`` or ``list[device...]``, optional\n            If provided, values from these will make it into the DAQ data\n            stream as variables. We will check ``device.position`` and\n            ``device.value`` for quantities to use and we will update these\n            values each time begin is called. To provide a list, all devices\n            must have a ``name`` attribute.\n\n        wait: ``bool``, optional\n            If ``True``, wait for the daq to finish aquiring data. A\n            ``KeyboardInterrupt`` (``ctrl+c``) during this wait will end the\n            run and clean up.\n\n        end_run: ``bool``, optional\n            If ``True``, we'll end the run after the daq has stopped.\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n        from time import sleep\n        from mfx.db import daq\n\n        logger.debug(('Daq.begin(events=%s, duration=%s, record=%s, '\n                      'use_l3t=%s, controls=%s, wait=%s)'),\n                     events, duration, record, use_l3t, controls, wait)\n        status = True\n        try:\n            if record is not None and record != daq.record:\n                old_record = daq.record\n                daq.preconfig(record=record, show_queued_cfg=False)\n            begin_status = daq.kickoff(events=events, duration=duration,\n                                        use_l3t=use_l3t, controls=controls)\n            try:\n                begin_status.wait(timeout=daq._begin_timeout)\n            except (StatusTimeoutError, WaitTimeoutError):\n                msg = (f'Timeout after {self._begin_timeout} seconds waiting '\n                       'for daq to begin.')\n                raise DaqTimeoutError(msg) from None\n\n            # In some daq configurations the begin status returns very early,\n            # so we allow the user to configure an emperically derived extra\n            # sleep.\n            sleep(daq.config['begin_sleep'])\n            if wait:\n                daq.wait()\n                if end_run:\n                    daq.end_run()\n            if end_run and not wait:\n                threading.Thread(target=daq._ender_thread, args=()).start()\n            return status\n        except KeyboardInterrupt:\n                status = False\n                return status\n\n\n    def yano_run(self, sample='?', run_length=300, record=True, runs=5, inspire=False, daq_delay=5, picker=None, fiber=-1, free_space=None, laser_delay=None):\n        \"\"\"\n        Perform a single run of the experiment\n\n        Parameters\n        ----------\n        sample: str, optional\n            Sample Name\n\n        run_length: int, optional\n            number of seconds for run 300 is default\n\n        record: bool, optional\n            set True to record\n\n        runs: int, optional\n            number of runs 5 is default\n\n        inspire: bool, optional\n            Set false by default because it makes Sandra sad. Set True to inspire\n\n        daq_delay: int, optional\n            delay time between runs. Default is 5 second but increase is the DAQ is being slow.\n\n        picker: str, optional\n            If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts\n\n        fiber: int, optional\n            Number of laser fibers. Default is -1. See ``configure_shutters`` for more\n            information\n\n        free_space: bool, optional\n            Sets the free_space laser shutter to Closed (False) or Open (True). Default is None.\n\n        laser_delay: float\n            Requested laser delay in nanoseconds.\n        Note\n        ----\n        0: (fiber1=False, fiber2=False, fiber3=False)\n        1: (fiber1=False, fiber2=False, fiber3=True)\n        2: (fiber1=False, fiber2=True, fiber3=True)\n        3: (fiber1=True, fiber2=True, fiber3=True)\n\n        For alternative laser configurations either use ``configure_shutters`` to set parameters\n        \"\"\"\n        import logging\n        logger = logging.getLogger(__name__)\n        from time import sleep\n        from mfx.db import daq, pp\n        from mfx.autorun import quote\n\n        # Configure the shutters\n        if fiber == 0:\n            self.fiber_0()\n        elif fiber == 1:\n            self.fiber_1()\n        elif fiber == 2:\n            self.fiber_2()\n        elif fiber == 3:\n            self.fiber_3()\n        else:\n            logger.warning(\"No proper fiber number set so defaulting to ``configure_shutters`` settings.\")\n\n        if free_space is not None:\n            if free_space == True or str(\n                free_space).lower()==str('out') or int(\n                    free_space) == 2 or str(\n                        free_space).lower()==str('open'):\n                self.opo_shutter('OUT')\n            else:\n                self.opo_shutter('IN')\n\n        if laser_delay is not None:\n            self.set_delay(laser_delay)\n        delay = self.get_delay()\n        logger.info(self._delaystr(delay))\n\n        if sample.lower()=='water' or sample.lower()=='h2o':\n            inspire=True\n        if picker=='open':\n            pp.open()\n        if picker=='flip':\n            pp.flipflop()\n\n        for i in range(runs):\n            logger.info(f\"Run Number {daq.run_number() + 1} Running {sample}......{quote()['quote']}\")\n            run_number = daq.run_number() + 1\n            status = self.begin(duration = run_length, record = record, wait = True, end_run = True)\n            if status is False:\n                pp.close()\n                self.post(sample, run_number, record, inspire, 'Run ended prematurely. Probably sample delivery problem')\n                self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n                logger.warning(\"[*] Stopping Run and exiting???...\")\n                sleep(5)\n                daq.stop()\n                daq.disconnect()\n                logger.warning('Run ended prematurely. Probably sample delivery problem')\n                break\n\n            self.post(sample, run_number, record, inspire)\n            try:\n                sleep(daq_delay)\n            except KeyboardInterrupt:\n                pp.close()\n                self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n                logger.warning(\"[*] Stopping Run and exiting???...\")\n                sleep(5)\n                daq.disconnect()\n                status = False\n                if status is False:\n                    logger.warning('Run ended prematurely. Probably sample delivery problem')\n                    break\n        if status:\n            pp.close()\n            self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n            daq.end_run()\n            daq.disconnect()\n            logger.warning('Finished with all runs thank you for choosing the MFX beamline!\\n')\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.shutter_status","title":"<code>shutter_status</code>  <code>property</code>","text":"<p>Show current shutter status</p>"},{"location":"yano.html#mfx.yano.yano.begin","title":"<code>begin(events=None, duration=300, record=False, use_l3t=None, controls=None, wait=False, end_run=False)</code>","text":"<p>Start the daq and block until the daq has begun acquiring data.</p> <p>Optionally block with <code>wait=True</code> until the daq has finished aquiring data. If blocking, a <code>ctrl+c</code> will end the run and clean up.</p> <p>If omitted, any argument that is shared with <code>configure</code> will fall back to the configured value.</p> <p>Internally, this calls <code>kickoff</code> and manages its <code>Status</code> object.</p>"},{"location":"yano.html#mfx.yano.yano.begin--parameters","title":"Parameters","text":"<p>events: <code>int</code>, optional     Number events to take in the daq.</p> <code>int</code>, optional <p>Time to run the daq in seconds, if <code>events</code> was not provided.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll configure the daq to record data before this run.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll run with the level 3 trigger. This means that if we specified a number of events, we will wait for that many \"good\" events as determined by the daq.</p> <code>dict{name: device}</code> or <code>list[device...]</code>, optional <p>If provided, values from these will make it into the DAQ data stream as variables. We will check <code>device.position</code> and <code>device.value</code> for quantities to use and we will update these values each time begin is called. To provide a list, all devices must have a <code>name</code> attribute.</p> <code>bool</code>, optional <p>If <code>True</code>, wait for the daq to finish aquiring data. A <code>KeyboardInterrupt</code> (<code>ctrl+c</code>) during this wait will end the run and clean up.</p> <code>bool</code>, optional <p>If <code>True</code>, we'll end the run after the daq has stopped.</p> Source code in <code>mfx/yano.py</code> <pre><code>def begin(self, events=None, duration=300,\n          record=False, use_l3t=None, controls=None,\n          wait=False, end_run=False):\n    \"\"\"\n    Start the daq and block until the daq has begun acquiring data.\n\n    Optionally block with ``wait=True`` until the daq has finished aquiring\n    data. If blocking, a ``ctrl+c`` will end the run and clean up.\n\n    If omitted, any argument that is shared with `configure`\n    will fall back to the configured value.\n\n    Internally, this calls `kickoff` and manages its ``Status`` object.\n\n    Parameters\n    ----------\n    events: ``int``, optional\n        Number events to take in the daq.\n\n    duration: ``int``, optional\n        Time to run the daq in seconds, if ``events`` was not provided.\n\n    record: ``bool``, optional\n        If ``True``, we'll configure the daq to record data before this\n        run.\n\n    use_l3t: ``bool``, optional\n        If ``True``, we'll run with the level 3 trigger. This means that\n        if we specified a number of events, we will wait for that many\n        \"good\" events as determined by the daq.\n\n    controls: ``dict{name: device}`` or ``list[device...]``, optional\n        If provided, values from these will make it into the DAQ data\n        stream as variables. We will check ``device.position`` and\n        ``device.value`` for quantities to use and we will update these\n        values each time begin is called. To provide a list, all devices\n        must have a ``name`` attribute.\n\n    wait: ``bool``, optional\n        If ``True``, wait for the daq to finish aquiring data. A\n        ``KeyboardInterrupt`` (``ctrl+c``) during this wait will end the\n        run and clean up.\n\n    end_run: ``bool``, optional\n        If ``True``, we'll end the run after the daq has stopped.\n    \"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    from time import sleep\n    from mfx.db import daq\n\n    logger.debug(('Daq.begin(events=%s, duration=%s, record=%s, '\n                  'use_l3t=%s, controls=%s, wait=%s)'),\n                 events, duration, record, use_l3t, controls, wait)\n    status = True\n    try:\n        if record is not None and record != daq.record:\n            old_record = daq.record\n            daq.preconfig(record=record, show_queued_cfg=False)\n        begin_status = daq.kickoff(events=events, duration=duration,\n                                    use_l3t=use_l3t, controls=controls)\n        try:\n            begin_status.wait(timeout=daq._begin_timeout)\n        except (StatusTimeoutError, WaitTimeoutError):\n            msg = (f'Timeout after {self._begin_timeout} seconds waiting '\n                   'for daq to begin.')\n            raise DaqTimeoutError(msg) from None\n\n        # In some daq configurations the begin status returns very early,\n        # so we allow the user to configure an emperically derived extra\n        # sleep.\n        sleep(daq.config['begin_sleep'])\n        if wait:\n            daq.wait()\n            if end_run:\n                daq.end_run()\n        if end_run and not wait:\n            threading.Thread(target=daq._ender_thread, args=()).start()\n        return status\n    except KeyboardInterrupt:\n            status = False\n            return status\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.configure_shutters","title":"<code>configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=None)</code>","text":"<p>Configure all four laser shutters</p> <p>True means that the fiber will be used and the shutter is removed. False means that the fiber will be blocked and the shutter is inserted     - default for evo laser fiber1, fiber2, fiber3 None means that the shutter will not be changed    - default for opo laser</p>"},{"location":"yano.html#mfx.yano.yano.configure_shutters--parameters","title":"Parameters","text":"<p>fiber1: bool     Controls <code>evo_shutter1</code></p> bool <p>Controls <code>evo_shutter2</code></p> bool <p>Controls <code>evo_shutter3</code></p> bool <p>Controls <code>opo_shutter</code></p> Source code in <code>mfx/yano.py</code> <pre><code>def configure_shutters(self, fiber1=False, fiber2=False, fiber3=False, free_space=None):\n    \"\"\"\n    Configure all four laser shutters\n\n    True means that the fiber will be used and the shutter is removed.\n    False means that the fiber will be blocked and the shutter is inserted \n       - default for evo laser fiber1, fiber2, fiber3\n    None means that the shutter will not be changed\n       - default for opo laser\n\n    Parameters\n    ----------\n    fiber1: bool\n        Controls ``evo_shutter1``\n\n    fiber2: bool\n        Controls ``evo_shutter2``\n\n    fiber3: bool\n        Controls ``evo_shutter3``\n\n    free_space: bool\n        Controls ``opo_shutter``\n    \"\"\"\n    from time import sleep\n    for state, shutter in zip((fiber1, fiber2, fiber3, free_space),\n                              (self.evo_shutter1, self.evo_shutter2,\n                               self.evo_shutter3, self.opo_shutter)):\n        if state is not None:\n            if state == True or state == 'OUT' or state == 2:\n                shutter('OUT')\n            else:\n                shutter('IN')\n    #logger.info(\"Shutters set to fiber1=%s, fiber2=%s, fiber3=%s, free_space=%s\", fiber1, fiber2, fiber3, free_space)\n    sleep(1)\n    return\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.get_delay","title":"<code>get_delay()</code>","text":"<p>Reads the current delay in ns</p>"},{"location":"yano.html#mfx.yano.yano.get_delay--parameters","title":"Parameters","text":"<p>delay: float     Requested laser delay in nanoseconds.</p> Source code in <code>mfx/yano.py</code> <pre><code>def get_delay(self):\n    \"\"\"\n    Reads the current delay in ns\n\n    Parameters\n    ----------\n    delay: float\n        Requested laser delay in nanoseconds.\n    \"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    if self.opo.eventcode.get() == self.opo_ec_long:\n        opo_delay = self.opo.ns_delay.get() - 1e9/120\n    else:\n        opo_delay = self.opo.ns_delay.get()\n    delay = self.opo_time_zero - opo_delay \n    logger.info(self._delaystr(delay))\n    return delay\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.post","title":"<code>post(sample='?', run_number=None, post=False, inspire=False, add_note='')</code>","text":"<p>Posts a message to the elog</p>"},{"location":"yano.html#mfx.yano.yano.post--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> int, optional <p>Run Number. By default this is read off of the DAQ</p> bool, optional <p>set True to record/post message to elog</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> string, optional <p>adds additional note to elog message</p> Source code in <code>mfx/yano.py</code> <pre><code>def post(self, sample='?', run_number=None, post=False, inspire=False, add_note=''):\n    \"\"\"\n    Posts a message to the elog\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    run_number: int, optional\n        Run Number. By default this is read off of the DAQ\n\n    post: bool, optional\n        set True to record/post message to elog\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    add_note: string, optional\n        adds additional note to elog message \n    \"\"\"\n    from mfx.db import daq, elog\n    from mfx.autorun import quote\n    post_template = \"\"\"\\\n    Run Number {}: {}\n\n    {}\n\n    While the laser shutters are:\n    EVO fiber 1 -&gt;  {}\n    EVO fiber 2 -&gt;  {}\n    EVO fiber 3 -&gt;  {}\n    OPO Shutter -&gt;  {}\n    \"\"\"\n    if add_note!='':\n        add_note = '\\n' + add_note\n    if inspire:\n        comment = f\"Running {sample}\\n{quote()['quote']}{add_note}\"\n    else:\n        comment = f\"Running {sample}{add_note}\"\n    delay = self.get_delay()\n    if run_number is None:\n        run_number = daq.run_number()\n    info = [run_number, comment, self._delaystr(delay)]\n    info.extend(self.shutter_status)\n    post_msg = post_template.format(*info)\n    print('\\n' + post_msg + '\\n')\n    if post:\n        elog.post(msg=post_msg, run=(run_number))\n    return post_msg\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.set_delay","title":"<code>set_delay(delay)</code>","text":"<p>Set the delay</p>"},{"location":"yano.html#mfx.yano.yano.set_delay--parameters","title":"Parameters","text":"<p>delay: float     Requested laser delay in nanoseconds.</p> Source code in <code>mfx/yano.py</code> <pre><code>def set_delay(self, delay):\n    \"\"\"\n    Set the delay\n\n    Parameters\n    ----------\n    delay: float\n        Requested laser delay in nanoseconds.\n    \"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    # Determine event code of inhibit pulse\n    logger.info(\"Setting delay %s ns (%s us)\", delay, delay/1000.)\n    self.delay = delay\n    opo_delay = self.opo_time_zero - delay\n    opo_ec = self.opo_ec_short\n    if delay &gt; self.opo_time_zero + 1e9/120:\n        opo_delay += 2e9/120\n        opo_ec = self.opo_ec_longer\n        logger.info('Laser is 2 buckets before the beam')\n    elif delay &gt; self.opo_time_zero:\n        opo_delay += 1e9/120\n        opo_ec = self.opo_ec_long\n        logger.info('Laser is 1 bucket before the beam')\n    else:\n        logger.info('Laser is in the same bucket as the beam')      \n\n\n    self.opo.ns_delay.put(opo_delay)\n    logger.info(\"Setting OPO delay %s ns\", opo_delay)\n    self.opo.eventcode.put(opo_ec)\n    logger.info(\"Setting OPO ec %s\", opo_ec)\n    logger.info(self._delaystr(delay))\n    return\n</code></pre>"},{"location":"yano.html#mfx.yano.yano.yano_run","title":"<code>yano_run(sample='?', run_length=300, record=True, runs=5, inspire=False, daq_delay=5, picker=None, fiber=-1, free_space=None, laser_delay=None)</code>","text":"<p>Perform a single run of the experiment</p>"},{"location":"yano.html#mfx.yano.yano.yano_run--parameters","title":"Parameters","text":"<p>sample: str, optional     Sample Name</p> int, optional <p>number of seconds for run 300 is default</p> bool, optional <p>set True to record</p> int, optional <p>number of runs 5 is default</p> bool, optional <p>Set false by default because it makes Sandra sad. Set True to inspire</p> int, optional <p>delay time between runs. Default is 5 second but increase is the DAQ is being slow.</p> str, optional <p>If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts</p> int, optional <p>Number of laser fibers. Default is -1. See <code>configure_shutters</code> for more information</p> bool, optional <p>Sets the free_space laser shutter to Closed (False) or Open (True). Default is None.</p> float <p>Requested laser delay in nanoseconds.</p>"},{"location":"yano.html#mfx.yano.yano.yano_run--note","title":"Note","text":"<p>0: (fiber1=False, fiber2=False, fiber3=False) 1: (fiber1=False, fiber2=False, fiber3=True) 2: (fiber1=False, fiber2=True, fiber3=True) 3: (fiber1=True, fiber2=True, fiber3=True)</p> <p>For alternative laser configurations either use <code>configure_shutters</code> to set parameters</p> Source code in <code>mfx/yano.py</code> <pre><code>def yano_run(self, sample='?', run_length=300, record=True, runs=5, inspire=False, daq_delay=5, picker=None, fiber=-1, free_space=None, laser_delay=None):\n    \"\"\"\n    Perform a single run of the experiment\n\n    Parameters\n    ----------\n    sample: str, optional\n        Sample Name\n\n    run_length: int, optional\n        number of seconds for run 300 is default\n\n    record: bool, optional\n        set True to record\n\n    runs: int, optional\n        number of runs 5 is default\n\n    inspire: bool, optional\n        Set false by default because it makes Sandra sad. Set True to inspire\n\n    daq_delay: int, optional\n        delay time between runs. Default is 5 second but increase is the DAQ is being slow.\n\n    picker: str, optional\n        If 'open' it opens pp before run starts. If 'flip' it flipflops before run starts\n\n    fiber: int, optional\n        Number of laser fibers. Default is -1. See ``configure_shutters`` for more\n        information\n\n    free_space: bool, optional\n        Sets the free_space laser shutter to Closed (False) or Open (True). Default is None.\n\n    laser_delay: float\n        Requested laser delay in nanoseconds.\n    Note\n    ----\n    0: (fiber1=False, fiber2=False, fiber3=False)\n    1: (fiber1=False, fiber2=False, fiber3=True)\n    2: (fiber1=False, fiber2=True, fiber3=True)\n    3: (fiber1=True, fiber2=True, fiber3=True)\n\n    For alternative laser configurations either use ``configure_shutters`` to set parameters\n    \"\"\"\n    import logging\n    logger = logging.getLogger(__name__)\n    from time import sleep\n    from mfx.db import daq, pp\n    from mfx.autorun import quote\n\n    # Configure the shutters\n    if fiber == 0:\n        self.fiber_0()\n    elif fiber == 1:\n        self.fiber_1()\n    elif fiber == 2:\n        self.fiber_2()\n    elif fiber == 3:\n        self.fiber_3()\n    else:\n        logger.warning(\"No proper fiber number set so defaulting to ``configure_shutters`` settings.\")\n\n    if free_space is not None:\n        if free_space == True or str(\n            free_space).lower()==str('out') or int(\n                free_space) == 2 or str(\n                    free_space).lower()==str('open'):\n            self.opo_shutter('OUT')\n        else:\n            self.opo_shutter('IN')\n\n    if laser_delay is not None:\n        self.set_delay(laser_delay)\n    delay = self.get_delay()\n    logger.info(self._delaystr(delay))\n\n    if sample.lower()=='water' or sample.lower()=='h2o':\n        inspire=True\n    if picker=='open':\n        pp.open()\n    if picker=='flip':\n        pp.flipflop()\n\n    for i in range(runs):\n        logger.info(f\"Run Number {daq.run_number() + 1} Running {sample}......{quote()['quote']}\")\n        run_number = daq.run_number() + 1\n        status = self.begin(duration = run_length, record = record, wait = True, end_run = True)\n        if status is False:\n            pp.close()\n            self.post(sample, run_number, record, inspire, 'Run ended prematurely. Probably sample delivery problem')\n            self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.stop()\n            daq.disconnect()\n            logger.warning('Run ended prematurely. Probably sample delivery problem')\n            break\n\n        self.post(sample, run_number, record, inspire)\n        try:\n            sleep(daq_delay)\n        except KeyboardInterrupt:\n            pp.close()\n            self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n            logger.warning(\"[*] Stopping Run and exiting???...\")\n            sleep(5)\n            daq.disconnect()\n            status = False\n            if status is False:\n                logger.warning('Run ended prematurely. Probably sample delivery problem')\n                break\n    if status:\n        pp.close()\n        self.configure_shutters(fiber1=False, fiber2=False, fiber3=False, free_space=False)\n        daq.end_run()\n        daq.disconnect()\n        logger.warning('Finished with all runs thank you for choosing the MFX beamline!\\n')\n</code></pre>"}]}